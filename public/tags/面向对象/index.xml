<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>面向对象 - 标签 - MeowRain Blog</title>
    <link>https://example.org/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
    <description>面向对象 - 标签 | MeowRain Blog</description>
    <generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>meowrain@126.com (meowrain)</managingEditor>
      <webMaster>meowrain@126.com (meowrain)</webMaster><lastBuildDate>Sat, 18 May 2024 13:12:26 &#43;0800</lastBuildDate><atom:link href="https://example.org/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="self" type="application/rss+xml" /><item>
  <title>Javascript 面向对象</title>
  <link>https://example.org/posts/178f51c/</link>
  <pubDate>Sat, 18 May 2024 13:12:26 &#43;0800</pubDate>
  <author>meowrain</author>
  <guid>https://example.org/posts/178f51c/</guid>
  <description><![CDATA[Javascript 面向对象(OOP) 语法 1 2 3 4 5 class 类名 { constructor(){ } } 举例:
1 2 3 4 5 6 7 8 9 10 11 //Person类专门用来创建人的对象 class Person { constructor(name,age,hooby){ this.name = name; this.age = age; this.hooby = hooby; } } //调用构造函数创建对象创建对象 const xiaoming = new Person(&#34;xiaoming&#34;,18,&#39;programming&#39;); console.log(xiaoming) instanceOf用法 可以用来检查一个对象是否是由某个类创建,如果某个对象是由某个类创建,那么我们称这个对象是这个类的实例
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //Person类专门用来创建人的对象 class Person { constructor(name,age,hooby){ this.]]></description>
</item>
<item>
  <title>Java面向对象基础(高级)</title>
  <link>https://example.org/posts/0112cbb/</link>
  <pubDate>Sat, 18 May 2024 13:09:43 &#43;0800</pubDate>
  <author>meowrain</author>
  <guid>https://example.org/posts/0112cbb/</guid>
  <description><![CDATA[Java面向对象(高级) 面型对象高级 面型对象中级 面型对象初级
类变量/类方法 类变量/类方法-博客园 类变量快速入门 介绍 类变量（又叫静态变量）是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量。
定义类变量：访问修饰符 static 数据类型 变量名; 静态变量是类加载的时候，就创建了,所以我们没有创建对象实例 定义一个变量 count ,是一个类变量(静态变量) static 静态 该变量最大的特点就是会被Child 类的所有的对象实例共享
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package cn.meowrain.classVariable; public class var01 { public static void main(String[] args) { Child child01 = new Child(&#34;mike&#34;); Child child02 = new Child(&#34;john&#34;); child01.count++; child02.count++; System.out.println(&#34;共有&#34; + Child.count + &#34;个小朋友参加了游戏&#34;); } } class Child { private String name; public static int count = 0; public Child(String name){ this.]]></description>
</item>
<item>
  <title>Java面向对象基础(中级)</title>
  <link>https://example.org/posts/f4f8ed5/</link>
  <pubDate>Sat, 18 May 2024 13:09:20 &#43;0800</pubDate>
  <author>meowrain</author>
  <guid>https://example.org/posts/f4f8ed5/</guid>
  <description><![CDATA[Java面向对象基础（中级） Consolas, &lsquo;Courier New&rsquo;, monospace
包 包的三大作用 1.区分相同名字的类
2.当类很多的时候，可以很好地管理类
3.控制访问范围
包的基本语法 1 2 1.package 关键字 2. com.xxxx 表示包名 包的本质分析 包的本质就是创建不同的文件夹和目录来保存类文件
包的命名 只能包含数字，下划线，小圆点，但不能用数字开头，也不能是关键字和保留字
命名规范：
com.xxxx.usr 用户模块
com.xxxx.utils 工具模块
域名反着写，最后加上模块名
常用的包 引入包 语法：import 包名.类名
案例：
1 2 3 4 5 6 7 8 9 10 11 package cn.meowrain.Object_.package_; import java.util.Scanner; public class package_01 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(); System.out.println(a); } } 访问修饰符 封装 封装介绍 封装就是把抽象出的数据[属性]和对数据的操作**[方法]封装在一起，数据被保护在内部，程序的其它部分只有通过被授权的操作[方法]**，才能对数据进行操作]]></description>
</item>
<item>
  <title>Java面向对象基础(初级)</title>
  <link>https://example.org/posts/61c8cb0/</link>
  <pubDate>Sat, 18 May 2024 13:08:20 &#43;0800</pubDate>
  <author>meowrain</author>
  <guid>https://example.org/posts/61c8cb0/</guid>
  <description><![CDATA[Java面向对象基础(初级) 对面向对象和面向过程的理解
谈谈你对面向过程和面向对象的理解_智十七°的博客-CSDN博客_面向对象和面向过程的理解
面向对象的三大特征 封装 (Encapsulation) 继承 (Inheritance) 多态 (Polymorphism)
初识对象和类 初次使用对象和类 如下，在下面这个代码中，我创建了一个猫类，然后利用猫类创建了两个猫对象，一个赋值给cat01，一个赋值给cat02
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package cn.meowrain.Object_; public class relean_01 { public static void main(String[] args) { //创建两猫对象 Cat cat01 = new Cat(); cat01.name = &#34;小花&#34;; cat01.age = 1; cat01.color = &#34;花色&#34;; Cat cat02 = new Cat(); cat02.]]></description>
</item>
<item>
  <title>C&#43;&#43;面向对象</title>
  <link>https://example.org/posts/ae3b30e/</link>
  <pubDate>Sat, 18 May 2024 13:05:42 &#43;0800</pubDate>
  <author>meowrain</author>
  <guid>https://example.org/posts/ae3b30e/</guid>
  <description><![CDATA[C++ OOP Class(1) private,protected,public private(默认就是 private) private 声明的类的私有成员只能由同一类的其他成员或者它们的朋友访问
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; #include &lt;string&gt; class Student { private: int score; public: std::string name; int age; Student(std::string _name,int _age,int _score) : name(_name),age(_age),score(_score){ } void getScore(){ std::cout &lt;&lt; score &lt;&lt; std::endl; } }; int main(void) { Student s(&#34;meow&#34;,18,100); s.getScore(); } 我们如果在 main 函数中直接用对象输出学生的分数，就不能
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; #include &lt;string&gt; class Student { private: int score; public: std::string name; int age; Student(std::string _name,int _age,int _score) : name(_name),age(_age),score(_score){ } void getScore(){ std::cout &lt;&lt; score &lt;&lt; std::endl; } }; int main(void) { Student s(&#34;meow&#34;,18,100); std::cout &lt;&lt; s.]]></description>
</item>
<item>
  <title>设计模式</title>
  <link>https://example.org/posts/a44e805/</link>
  <pubDate>Wed, 15 May 2024 19:31:42 &#43;0800</pubDate>
  <author>meowrain</author>
  <guid>https://example.org/posts/a44e805/</guid>
  <description><![CDATA[[TOC]
面向对象相关知识 面向对象类关系(继承、实现、依赖、关联、聚合、组合)：https://www.cnblogs.com/zhongj/p/11169780.html
UML: https://blog.csdn.net/quyingzhe0217/article/details/133683814
创建型模式 创建型设计模式包括以下几种常见的模式：
工厂模式（Factory Pattern）：通过工厂方法或抽象工厂来创建对象，将对象的创建过程封装起来，使得客户端代码与具体类解耦。
抽象工厂模式（Abstract Factory Pattern）：提供一个接口，用于创建相关或依赖对象的家族，而不需要指定具体类。
单例模式（Singleton Pattern）：确保一个类只有一个实例，并提供一个全局访问点来访问该实例。
建造者模式（Builder Pattern）：将一个复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。
原型模式（Prototype Pattern）：通过复制现有对象来创建新对象，而不是通过实例化来创建。
结构型模式 结构型设计模式主要包括以下几种常见的模式： 适配器模式（Adapter Pattern）：将一个类的接口转换成客户端所期望的另一个接口，使得原本不兼容的类可以一起工作。
桥接模式（Bridge Pattern）：将抽象部分与实现部分分离，使它们可以独立地变化，从而提高系统的灵活性。
组合模式（Composite Pattern）：将对象组合成树形结构，以表示“部分-整体”的层次结构，使得客户端可以统一地处理单个对象和组合对象。
装饰器模式（Decorator Pattern）：动态地给对象添加额外的职责，同时又不改变其接口。
外观模式（Facade Pattern）：提供一个统一的接口，用于访问子系统中的一组接口，从而简化客户端与子系统之间的交互。
享元模式（Flyweight Pattern）：通过共享细粒度的对象，以减少内存使用和提高性能。
代理模式（Proxy Pattern）：为其他对象提供一个代理，以控制对这个对象的访问。
行为模式 行为型设计模式主要包括以下几种常见的模式：
观察者模式（Observer Pattern）：定义了一种一对多的依赖关系，使得多个观察者对象可以同时监听并收到被观察者对象的通知。
策略模式（Strategy Pattern）：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，从而使算法的变化独立于使用算法的客户端。
命令模式（Command Pattern）：将请求封装成对象，以使得可以用不同的请求对客户端进行参数化，同时支持请求的排队、记录和撤销。
迭代器模式（Iterator Pattern）：提供一种顺序访问聚合对象中各个元素的方法，而又不暴露该对象的内部表示。
状态模式（State Pattern）：允许对象在内部状态发生改变时改变其行为，使对象看起来像是修改了其类。
责任链模式（Chain of Responsibility Pattern）：将请求的发送者和接收者解耦，使多个对象都有机会处理请求，从而避免请求的发送者与接收者之间的耦合关系。
访问者模式（Visitor Pattern）：在不改变被访问类的前提下，定义了一种新的访问操作，使得可以在不修改被访问类的情况下对其进行操作。
中介者模式（Mediator Pattern）：定义了一个中介对象，封装了一组对象之间的交互方式，使其能够独立地改变交互方式。
备忘录模式（Memento Pattern）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可以在以后恢复到这个状态。
解释器模式（Interpreter Pattern）：给定一个语言，定义它的文法的一种表示，并定义一个解释器，用于解释语言中的句子。
工厂方法模式 factory_method 工厂方法模式是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。
问题： 假设你正在开发一款物流管理应用。 最初版本只能处理卡车运输， 因此大部分代码都在位于名为 卡车的类中。
一段时间后， 这款应用变得极受欢迎。 你每天都能收到十几次来自海运公司的请求， 希望应用能够支持海上物流功能。]]></description>
</item>
</channel>
</rss>
