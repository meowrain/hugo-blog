<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>MeowRain Blog</title>
    <link>https://example.org/</link>
    <description>MeowRain Blog</description>
    <generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>meowrain@126.com (meowrain)</managingEditor>
      <webMaster>meowrain@126.com (meowrain)</webMaster><lastBuildDate>Tue, 18 Jun 2024 04:58:45 &#43;0000</lastBuildDate>
      <atom:link href="https://example.org/index.xml" rel="self" type="application/rss+xml" />
    <item>
  <title>Tinyhttpd源码解析</title>
  <link>https://example.org/posts/913f95d/</link>
  <pubDate>Tue, 18 Jun 2024 04:58:45 &#43;0000</pubDate>
  <author>meowrain</author>
  <guid>https://example.org/posts/913f95d/</guid>
  <description><![CDATA[HTTP HTTP请求头 当然，下面是一个带有 \r\n 行结尾的 HTTP 请求头示例：
1 2 3 4 5 6 7 8 9 GET /index.html HTTP/1.1\r\n Host: www.example.com\r\n User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\r\n Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\r\n Accept-Language: en-US,en;q=0.5\r\n Accept-Encoding: gzip, deflate\r\n Connection: keep-alive\r\n Upgrade-Insecure-Requests: 1\r\n \r\n 解释 每一行都是一个 HTTP 头字段，使用 \r\n（回车符和换行符）来表示行结束。 最后一行的 \r\n 表示头部结束，之后的内容（如果有）是请求的主体。 分解示例 请求行:
1 GET /index.html HTTP/1.1\r\n GET 是 HTTP 方法。 /index.html 是请求的路径。 HTTP/1.1 是 HTTP 版本。 头字段:]]></description>
</item>
<item>
  <title>C intptr_t类型</title>
  <link>https://example.org/posts/1df4bf9/</link>
  <pubDate>Tue, 18 Jun 2024 04:34:32 &#43;0000</pubDate>
  <author>meowrain</author>
  <guid>https://example.org/posts/1df4bf9/</guid>
  <description><![CDATA[intptr_t 是一种在 C 和 C++ 标准库中定义的整数类型。它是专门设计用来存储指针的整数类型，确保能够存储任何指针的整数值。这个类型定义在 &lt;stdint.h&gt; 头文件中。
详细解释 定义：
intptr_t 是一个有符号整数类型，能够存储任何指针转换成的整数值。 对应的无符号类型是 uintptr_t。 用途：
通常用于需要将指针值存储为整数或者从整数恢复指针值的场景。 在进行指针与整数之间的转换时，使用 intptr_t 可以确保程序的可移植性和类型的安全性。 头文件：
在 C 中：#include &lt;stdint.h&gt; 在 C++ 中：#include &lt;cstdint&gt; 示例 下面是一个简单的示例，展示如何使用 intptr_t 类型：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;stdio.h&gt; #include &lt;stdint.h&gt; int main() { int a = 42; int *p = &amp;a; // 将指针转换为整数 intptr_t int_value = (intptr_t)p; printf(&#34;Pointer as integer: %ld\n&#34;, (long)int_value); // 将整数转换回指针 int *new_p = (int *)int_value; printf(&#34;Value through new pointer: %d\n&#34;, *new_p); return 0; } 解释 int a = 42; 定义一个整数变量 a。 int *p = &amp;a; 定义一个指针 p，指向变量 a。 (intptr_t)p 将指针 p 转换为整数类型 intptr_t。 printf(&quot;Pointer as integer: %ld\n&quot;, (long)int_value); 输出指针转换后的整数值。 (int *)int_value 将整数值 int_value 转换回指针类型。 printf(&quot;Value through new pointer: %d\n&quot;, *new_p); 输出通过新指针 new_p 访问的值。 使用 intptr_t 和 uintptr_t 可以确保指针和整数之间的转换在不同平台上都是安全和可移植的。]]></description>
</item>
<item>
  <title>C Stat函数使用</title>
  <link>https://example.org/posts/7484d0b/</link>
  <pubDate>Mon, 17 Jun 2024 16:01:47 &#43;0000</pubDate>
  <author>meowrain</author>
  <guid>https://example.org/posts/7484d0b/</guid>
  <description><![CDATA[C stat函数使用 头文件：#include&lt;sys/stat.h&gt; #include&lt;uninstd.h&gt;
定义函数：int stat(const char * file_name, struct stat *buf);
函数说明：stat()用来将参数file_name 所指的文件状态, 复制到参数buf 所指的结构中。
struct stat *buf
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct stat { dev_t st_dev; //device 文件的设备编号 ino_t st_ino; //inode 文件的i-node mode_t st_mode; //protection 文件的类型和存取的权限 nlink_t st_nlink; //number of hard links 连到该文件的硬连接数目, 刚建立的文件值为1. uid_t st_uid; //user ID of owner 文件所有者的用户识别码 gid_t st_gid; //group ID of owner 文件所有者的组识别码 dev_t st_rdev; //device type 若此文件为装置设备文件, 则为其设备编号 off_t st_size; //total size, in bytes 文件大小, 以字节计算 unsigned long st_blksize; //blocksize for filesystem I/O 文件系统的I/O 缓冲区大小.]]></description>
</item>
<item>
  <title>Linux C网络编程</title>
  <link>https://example.org/posts/12b8a48/</link>
  <pubDate>Fri, 14 Jun 2024 08:03:26 &#43;0000</pubDate>
  <author>meowrain</author>
  <guid>https://example.org/posts/12b8a48/</guid>
  <description><![CDATA[转换ip inet_pton() inet_pton 函数用于将字符串表示的 IP 地址转换为网络字节序的二进制格式。与 inet_ntop 相反，inet_pton 的用途是从人类可读的字符串格式转换到机器可读的二进制格式。
函数原型 1 2 3 #include &lt;arpa/inet.h&gt; int inet_pton(int af, const char *src, void *dst); 参数 af：地址家族，可以是 AF_INET（表示 IPv4）或 AF_INET6（表示 IPv6）。 src：指向以字符串形式表示的地址（如 &quot;192.168.1.1&quot; 或 &quot;2001:db8::1&quot;）。 dst：指向存储转换后地址的缓冲区。 返回值 成功时返回 1。 如果输入的字符串不是有效的网络地址，返回 0。 失败时返回 -1，并设置 errno 来指示错误。 使用示例 以下是使用 inet_pton 的示例，展示如何将 IPv4 和 IPv6 地址从字符串格式转换为二进制格式：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include &lt;stdio.]]></description>
</item>
<item>
  <title>计算机网络基础知识</title>
  <link>https://example.org/posts/297df01/</link>
  <pubDate>Sun, 26 May 2024 20:41:07 &#43;0800</pubDate>
  <author>meowrain</author>
  <guid>https://example.org/posts/297df01/</guid>
  <description><![CDATA[基础知识 MAC 地址 （1）计算机联网必须的硬件是安装在计算机上的网卡
（2）通信中，用来标识主机身份的地址就是制作在网卡上的一个硬件地址。每块网卡在 生产出来后，都有一个全球唯一的编号来标识自己，这个地址就是 MAC 地址，即网卡的 物理地址
（3）MAC 地址由 48 位二进制数组成，通常分成六段，用 16 进制表示，其中前 24 位是生 产厂商向 IEEE 申请的厂商编号，后 24 位是网络接口卡序列号
（4）MAC 地址的第 8 位为 0 时，表示该 MAC 地址为单播地址；为 1 时，表示该 MAC 地址 为组播 MAC 地址。
（5）单播的发送方式为一对一，即一台主机发送的数据只发送给另一台主机。
（6）广播方式为一对多，即一台主机发送一个数据，在这个网段的所有主机都能收到
（7）组播方式介于单播和广播之间，也是一对多，但接收者不是网段上的全体成员，而 是一个特定的组的成员。 以太网帧格式： IP IP 在 TCP/IP 参考模型中处于第三层，也就是网络层。
网络层的主要作用是：实现主机与主机之间的通信，也叫点对点（end to end）通信。
IP 包格式 IP 地址的基础知识 IP 地址（IPv4 地址）由 32 位正整数来表示，IP 地址在计算机是以二进制的方式处理的。 人类为了方便记忆采用了点分十进制的标记方式，也就是将 32 位 IP 地址以每 8 位为组，共分为 4 组，每组以「.」隔开，再将每组转换成十进制。 IP 地址分类 A 类: 0.]]></description>
</item>
<item>
  <title>Java Spring笔记06 Bean的实例化模式 Spring</title>
  <link>https://example.org/posts/6607266/</link>
  <pubDate>Thu, 23 May 2024 12:17:13 &#43;0800</pubDate>
  <author>meowrain</author>
  <guid>https://example.org/posts/6607266/</guid>
  <description><![CDATA[Bean的实例化模式 Spring为Bean提供了多种实例化方式，通常包括4种方式。（也就是说在Spring中为Bean对象的创建准备了多种方案，目的是：更加灵活）
● 第一种：通过构造方法实例化 ● 第二种：通过简单工厂模式实例化 ● 第三种：通过factory-bean实例化 ● 第四种：通过FactoryBean接口实例化
通过构造方法实例化 1 2 3 4 5 6 7 8 ConstructorBean.java package com.powercode.spring6.beans; public class ConstructorBean { public ConstructorBean(){ } } 1 2 3 4 5 6 &lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; &lt;beans xmlns=&#34;http://www.springframework.org/schema/beans&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:schemaLocation=&#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&#34;&gt; &lt;bean id=&#34;constructorBean&#34; class=&#34;com.powercode.spring6.beans.ConstructorBean&#34;&gt;&lt;/bean&gt; &lt;/beans&gt; 1 2 3 4 5 6 7 8 9 测试程序` @Test public void testConstrucotrBean(){ Logger logger = LoggerFactory.getLogger(FirstSpringTest.class); ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&#34;spring9.]]></description>
</item>
<item>
  <title>Java Spring笔记05 工厂模式 设计模式</title>
  <link>https://example.org/posts/b5d8f62/</link>
  <pubDate>Thu, 23 May 2024 12:16:38 &#43;0800</pubDate>
  <author>meowrain</author>
  <guid>https://example.org/posts/b5d8f62/</guid>
  <description><![CDATA[工厂模式的三种形态 工厂模式通常有三种形态：
● 第一种：简单工厂模式（Simple Factory）：不属于23种设计模式之一。简单工厂模式又叫做：静态 工厂方法模式。简单工厂模式是工厂方法模式的一种特殊实现。
● 第二种：工厂方法模式（Factory Method）：是23种设计模式之一。
● 第三种：抽象工厂模式（Abstract Factory）：是23种设计模式之一。
简单工厂模式 简单工厂模式的角色包括三个：
● 抽象产品 角色
● 具体产品 角色
● 工厂类 角色
抽象产品角色：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package com.powernode.factory; /** * 武器（抽象产品角色） * @author 动力节点 * @version 1.0 * @className Weapon * @since 1.0 **/ public abstract class Weapon { /** * 所有的武器都有攻击行为 */ public abstract void attack(); } 具体产品角色：]]></description>
</item>
<item>
  <title>Java Spring笔记04 Spring引入外部属性配置文件</title>
  <link>https://example.org/posts/102939e/</link>
  <pubDate>Thu, 23 May 2024 12:15:03 &#43;0800</pubDate>
  <author>meowrain</author>
  <guid>https://example.org/posts/102939e/</guid>
  <description><![CDATA[Spring引入外部属性配置文件 我们都知道编写数据源的时候是需要连接数据库的信息的，例如：driver url username password等信息。这些信息可以单独写到一个属性配置文件中吗，这样用户修改起来会更加的方便。当然可以。
第一步：写一个数据源类，提供相关属性。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 MyDataSource.]]></description>
</item>
<item>
  <title>Java Spring笔记03 Spring三种命名空间</title>
  <link>https://example.org/posts/bb23c8c/</link>
  <pubDate>Thu, 23 May 2024 12:14:31 &#43;0800</pubDate>
  <author>meowrain</author>
  <guid>https://example.org/posts/bb23c8c/</guid>
  <description><![CDATA[p命名空间注入 目的：简化配置。 使用p命名空间注入的前提条件包括两个：
● 第一：在XML头部信息中添加p命名空间的配置信息：xmlns:p=&ldquo;http://www.springframework.org/schema/p"
● 第二：p命名空间注入是基于setter方法的，所以需要对应的属性提供setter方法。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Customer.java package com.powercode.spring6.beans; public class Customer { private String name; private int age; public void setName(String name) { this.name = name; } public void setAge(int age){ this.age = age; } @Override public String toString() { return &#34;Customer{&#34; + &#34;name=&#39;&#34; + name + &#39;\&#39;&#39; + &#34;, age=&#34; + age + &#39;}&#39;; } } 1 2 3 4 5 6 7 8 spring3.]]></description>
</item>
<item>
  <title>Java Spring笔记02 Spring自动装配</title>
  <link>https://example.org/posts/84be7f4/</link>
  <pubDate>Thu, 23 May 2024 12:14:02 &#43;0800</pubDate>
  <author>meowrain</author>
  <guid>https://example.org/posts/84be7f4/</guid>
  <description><![CDATA[基于的XML自动装配 根据名称自动装配 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 UserDao.java package com.powercode.spring6.dao; import org.slf4j.Logger; import org.slf4j.LoggerFactory; /* * Bean * * */ public class UserDao { private static final Logger logger = LoggerFactory.getLogger(UserDao.class); public void insert() { //用log4j2日志框架 logger.info(&#34;数据库正在插入用户信息&#34;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 UserService.]]></description>
</item>
</channel>
</rss>
