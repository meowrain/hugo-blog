[{"categories":["Javascript","面向对象"],"content":"Javascript 面向对象(OOP)\r","date":"2024-05-18","objectID":"/posts/178f51c/:0:0","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"语法\rclass 类名 { constructor(){ } } 举例: //Person类专门用来创建人的对象 class Person { constructor(name,age,hooby){ this.name = name; this.age = age; this.hooby = hooby; } } //调用构造函数创建对象创建对象 const xiaoming = new Person(\"xiaoming\",18,'programming'); console.log(xiaoming) ","date":"2024-05-18","objectID":"/posts/178f51c/:1:0","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"instanceOf用法\r可以用来检查一个对象是否是由某个类创建,如果某个对象是由某个类创建,那么我们称这个对象是这个类的实例 //Person类专门用来创建人的对象 class Person { constructor(name,age,hooby){ this.name = name; this.age = age; this.hooby = hooby; } } class Dog { } //调用构造函数创建对象创建对象 const xiaoming = new Person(\"xiaoming\",18,'programming'); const dog1 = new Dog(); console.log(xiaoming instanceof Person); //true console.log(dog1 instanceof Person); //false ","date":"2024-05-18","objectID":"/posts/178f51c/:2:0","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"属性\r//Person类专门用来创建人的对象 class Person { //在类中写属性,每次创建对象,它都会带有这些实例属性 //实例属性只能通过实例访问 name = \"meowrian\"; age = 17; hobby = \"game\" } const meowrain = new Person(); console.log(meowrain); console.log(meowrain.name,meowrain.age,meowrain.hobby); ","date":"2024-05-18","objectID":"/posts/178f51c/:3:0","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"静态属性\r//Person类专门用来创建人的对象 class Person { //静态属性只能通过类名去访问 static test = \"test静态属性\"; } const meowrain = new Person(); console.log(Person.test); ","date":"2024-05-18","objectID":"/posts/178f51c/:3:1","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"方法\r//Person类专门用来创建人的对象 class Person { name = \"meowrain\"; sayHello = ()=\u003e{ console.log(\"Hello~\"); } } const p1 = new Person(); console.log(p1) p1.sayHello(); ","date":"2024-05-18","objectID":"/posts/178f51c/:4:0","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"两种添加方法的方式:\rclass Person { name = \"meowrain\"; sayHello = ()=\u003e{ console.log(\"Hello~\"); } sayGoodbye(){ console.log(\"Goodbye~\"); } //这种方式直接打印实例对象看不到这个方法 } const p1 = new Person(); console.log(p1) p1.sayHello(); p1.sayGoodbye(); ","date":"2024-05-18","objectID":"/posts/178f51c/:4:1","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"静态方法(类方法)\r//Person类专门用来创建人的对象 class Person { static sayGG = ()=\u003e{ console.log(\"GG~\",this);//静态方法中,this指向的是我们的当前类 } } console.log(Person.sayGG()); //只能通过类名来调用 ","date":"2024-05-18","objectID":"/posts/178f51c/:4:2","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"构造函数\rclass Person { //在类中添加一个特殊的方法constructor //该方法我们称为构造函数 //构造函数会在我们调用类创建对象时候执行 constructor(name, age, gender) { this.name = name; this.age = age; this.gender = gender; console.log(\"构造函数执行了\"); } } const p1 = new Person(\"meowrian\", 18, \"男\"); //调用类创建一次对象 const p2 = new Person(\"meow\", 10, \"男\"); //调用类创建一次对象 console.log(p1.name); ","date":"2024-05-18","objectID":"/posts/178f51c/:5:0","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"封装\r//1. 封装 // - 对象就是一个用来存储不同属性的容器 //对象不仅负责属性,还要负责数据的安全 //直接添加到对象中的属性并不安全,因为它们可以被任意修改 // 如何确保数据安全 //提供setter和getter方法,来开放我们对数据的操作 /*实现封装的方式 * 1. 属性私有化 # * 通过getter和setter方法来操作属性 * get 属性名(){ * return this.#属性名; * } * set 属性名(value){ * this._属性名 = value; * } * */ class Person { //用#表示是私有属性 private,只能在类的内部访问 #name; #age; #gender; constructor(name, age, gender) { this.#name = name; this.#age = age; this.#gender = gender; this._name = name; this._age = age; this._gender = gender; } //getter方法,用来读取属性 get name() { return this.#name; } //这样写getter方法,在访问的时候直接用 实例.属性名就能获得 get age() { return this.#age; } get gender() { return this.#gender; } //setter方法,用来设置属性 set name(value) { this._name = value; } set age(value) { this._age = value; } set gender(value) { this._gender = value; } } const p1 = new Person(\"meow\", 17, \"男\"); console.log(p1.name, p1.age, p1.gender); //这些都是调用的getter方法 p1.name = \"meowmeow\"; //这里调用的是上面的setter方法 console.log(p1.name); ","date":"2024-05-18","objectID":"/posts/178f51c/:6:0","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"多态\r//多态 /* * 在JS中不会检查参数的类型,所以这就意味着任何数据都可以作为参数传递 * 要调用某个函数,无需指定的类型,只需要对象满足某些条件计即可 * * */ class Person { constructor(name) { this.name = name; } } class Dog { constructor(name) { this.name = name; } } class Test { } const dog = new Dog('旺财'); const person = new Person(\"喵雨\"); const test = new Test(); // console.log(dog); // console.log(person); /*定义一个函数,这个函数将会接受一个对象作为参数,可以输出hello,并且打印name属性*/ const sayHello = (obj)=\u003e { if (obj.name == undefined) { console.log(\"没有name属性,hello毛呢\") } else if(obj instanceof Person){ console.log(\"Hello 人:\" + obj.name); }else { console.log(\"Hello \"+ obj.name); } } sayHello(dog); sayHello(person); sayHello(test); ","date":"2024-05-18","objectID":"/posts/178f51c/:7:0","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"继承\rclass Animal { constructor(name) { this.name = name; } sayHello() { console.log(\"Animal\") } } class Dog extends Animal{ constructor(name) { super(name); } sayHello() { console.log(\"旺\") } //重写父类方法 } class Cat extends Animal{ constructor(name) { super(name); } sayHello() { console.log(\"meow\") } } const dog = new Dog(\"旺财\"); const cat = new Cat(\"汤姆\"); dog.sayHello(); cat.sayHello(); ","date":"2024-05-18","objectID":"/posts/178f51c/:8:0","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"对象的结构\r对象中存储属性的区域实际有两个: 对象自身 直接通过对象添加的属性,位于对象自身中 在类中通过x = y的形式添加的属性,位于对象自身中 class Person { name = \"meowrian\" age = 18 fun = ()=\u003e{ console.log('ffff'); } constructor(hobby) { this.hobby = hobby } } const p = new Person(\"打篮球\"); - 原型对象(prototype) 对象中还有一些内容,会存储在其他的对象里(原型对象) 在对象中会有一个属性用来存储原型对象,这个属性叫做 __proto__ class Person { fun(){ console.log(\"hello\") } //添加到原型中 constructor(hobby) { this.hobby = hobby } } const p = new Person(\"打篮球\"); console.log(p) 会添加到原型对象中的情况: 在类中通过xxx(){}方式添加的方法,位于原型中 主动向原型中添加的属性和方法 ","date":"2024-05-18","objectID":"/posts/178f51c/:9:0","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"原型\r相关链接:__proto__和prototype的区别 ","date":"2024-05-18","objectID":"/posts/178f51c/:10:0","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"__proto__\rclass Person { name = \"meowrain\" sayHello(){kde ubuntu console.log(\"hello,我是\" + this.name); } } const p = new Person(); /* * 访问一个对象的原型对象 对象.__proto__ * console.log(Object.getPrototypeOf(对象)); * */ console.log(p.__proto__);//{constructor: ƒ, sayHello: ƒ} console.log(Object.getPrototypeOf(p));//{constructor: ƒ, sayHello: ƒ} 原型的作用； 原型就相当于是一个公共的区域，可以被所有该类实例访问 可以将一个该类实例中所有的公共属性统一存储到原型中 这样我们只需要创建一个属性，即可被所有实例访问 ","date":"2024-05-18","objectID":"/posts/178f51c/:10:1","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"prototype\rclass Person { sayHello(){ console.log(\"hello\") } } const p1 = new Person(); console.log(Person.prototype); console.log(Person.prototype === p1.__proto__); //true 可以通过上面两种方式完成类的修改 ","date":"2024-05-18","objectID":"/posts/178f51c/:10:2","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"Object.hasOwn用法\r用来检查一个对象的自身是否含有某个属性 MDN文档-Object.hasOwn class Man { name = \"liming\"; } const man1 = new Man(); console.log(Object.hasOwn(man1, \"name\")) //true ","date":"2024-05-18","objectID":"/posts/178f51c/:10:3","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"旧类\r早期js中,直接通过函数来定义类 一个函数如果直接调用xx(),那么这个函数就是一个普通函数 一个函数如果通过调用new xxx()那么这个函数就是一个构造函数 function Person (){ } const p = new Person(); 上面的等价于下面的 class Person { } const p = new Person(); function Person(name,age){ //构造函数里面写的内容就是class中constructor写的内容 this.name = name; this.age = age; this.sayHello = function (){ console.log(\"hello\") } } //向原型中添加 Person.prototype.sayNice = function (){ console.log(\"nice\") } const p = new Person(\"meowrain\",12); console.log(p.name); // meowrain console.log(p.age); // 12 p.sayHello(); //hello p.sayNice();//nice console.log(p); 如上图,从上图我们可以看到,sayNice方法被添加到原型中了 ","date":"2024-05-18","objectID":"/posts/178f51c/:11:0","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"旧类静态属性,静态方法…\rvar Person = ( function () { //构造函数 function Person(name, age) { this.name = name; this.age = age; } //静态属性 Person.staticProperty = \"hobby\"; Person.hobby = \"nice\"; console.log(Person.hobby);//nice //静态方法 Person.staticMethod = function () { console.log(\"good\"); }; Person.staticMethod(); // good //创建实例 const p = new Person(\"meowrain\", 12); console.log(p.name); console.log(p.age); //返回对象 return Person; })(); 继承: var Animal = (function () { function Animal(name, age) { this.name = name; this.age = age; } return Animal; })(); var Cat = (function () { function Cat(name, age) { this.name = name; this.age = age; } //继承Animal Cat.prototype = new Animal(); return Cat; })(); const cat1 = new Cat(\"meow\", 2); console.log(cat1); ","date":"2024-05-18","objectID":"/posts/178f51c/:11:1","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"new运算符\rnew运算符是创建对象时候使用的运算符 new运算符-MDN docs ","date":"2024-05-18","objectID":"/posts/178f51c/:12:0","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Java","面向对象"],"content":"Java面向对象(高级)\r面型对象高级 面型对象中级 面型对象初级 ","date":"2024-05-18","objectID":"/posts/0112cbb/:0:0","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"类变量/类方法\r类变量/类方法-博客园 ","date":"2024-05-18","objectID":"/posts/0112cbb/:1:0","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"类变量快速入门\r介绍\r类变量（又叫静态变量）是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量。 定义类变量：访问修饰符 static 数据类型 变量名; 静态变量是类加载的时候，就创建了,所以我们没有创建对象实例 定义一个变量 count ,是一个类变量(静态变量) static 静态 该变量最大的特点就是会被Child 类的所有的对象实例共享 package cn.meowrain.classVariable; public class var01 { public static void main(String[] args) { Child child01 = new Child(\"mike\"); Child child02 = new Child(\"john\"); child01.count++; child02.count++; System.out.println(\"共有\" + Child.count + \"个小朋友参加了游戏\"); } } class Child { private String name; public static int count = 0; public Child(String name){ this.name = name; } public void join() { System.out.println(\"小朋友\" + name + \"加入了游戏....\"); } } 输出: 共有2个小朋友参加了游戏 访问类变量\r可以通过 类名.类变量名 或者 对象名.类变量名 来访问，但Java设计者推荐我们使用 类名.类变量名 的方式来访问。 package cn.meowrain.classVariable; public class var01 { public static void main(String[] args) { Child child01 = new Child(\"mike\"); Child child02 = new Child(\"john\"); child01.join(); child02.join(); System.out.println(\"共有\" + Child.count + \"个小朋友参加了游戏\"); //通过 对象名.类变量名 来访问 } } class Child { private String name; public static int count = 0; public Child(String name){ this.name = name; } public void join() { System.out.println(\"小朋友\" + name + \"加入了游戏....\"); count++; } } ","date":"2024-05-18","objectID":"/posts/0112cbb/:1:1","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"类方法\r介绍\r类变量也叫静态变量。 定义格式如下：访问修饰符 static 数据返回类型 方法名(){} 类方法经典使用场景\r（1）当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率。 （2）比如工具类中的方法 utils Math类、Arrays类、Collections集合类 （3）在实际开发中，往往将一些通用的方法，设计成静态方法，这样我们不需要创建对象就可以使用，比如打印一维数组，冒泡排序等等 类方法和普通方法的区别\r类方法中不允许使用和对象有关的关键字， 比如this 和super。普通方法(成员方法)可以。 类方法中，只能访问 静态变量 或 静态方法；而普通方法既可以访问普通变量（方法），也可以访问静态的。 类方法可以重写吗？\r可以被继承，但是不能被重写，如果父子类静态方法名相同，则会隐藏derive类方法（调用base类的方法） 静态方法是编译时绑定的，方法重写是运行时绑定的。 https://blog.csdn.net/m0_37974032/article/details/81157433 类方法的使用： 使用： 如下： package cn.meowrain.classVariable; public class var02 { } class Caculate { public static void main(String[] args) { int sum01 = sum(1, 2); int sum02 = sum(5, 10, 20); System.out.println(sum01 + \" \" + sum02);//3 35 } public static int sum(int a, int b) { return a + b; } public static int sum(int a, int b, int c) { return a + b + c; } } ","date":"2024-05-18","objectID":"/posts/0112cbb/:1:2","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"理解main方法\r直接看下面这个文章就行了，写得很不错 https://www.cnblogs.com/ffforward/p/15253293.html ","date":"2024-05-18","objectID":"/posts/0112cbb/:2:0","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"Java代码块\r基本介绍\r代码块又称为初始化块，属于类中的成员，类似于方法，把逻辑语句封装在方法体中，通过{}包围起来 其在创建对象时隐式调用 基本语法\r[修饰符]{\r代码\r}\r说明： (1) 修饰符可选，要写的话，也只能写static (2) 代码块分为两类，使用static修饰的叫静态代码块，没有static修饰的，叫普通代码块 (3) 逻辑语句可以为任何逻辑语句（输入、输出、方法调用、循环、判断等 (4) 分号；可以写上，也可以省略 代码块的好处\r（1）相当于另外一种形式的构造器（对构造器的补充机制），可以做初始化的操作。 （2）如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的复用性 实际使用： 如下，我们的三个构造器中都含有System.out.println(\"Welcome to Code World!\");，这使得代码很冗杂，使用代码块，就能让这个代码更好看一些，代码块会在每次类创建时调用 package cn.meowrain.codeBlock; public class code01 { public static void main(String[] args) { code01_child child01 = new code01_child(\"mike\"); code01_child child02 = new code01_child(\"meme\", 15); code01_child child03 = new code01_child(\"meow\", 18, \"bear\"); } } class code01_child { String name; int age; String love; public code01_child(String name) { this.name = name; System.out.println(\"Welcome to Code World!\"); System.out.println(\"hello \" + name); } public code01_child(String name, int age) { this.name = name; this.age = age; System.out.println(\"Welcome to Code World!\"); System.out.println(\"hello \" + name); } public code01_child(String name,int age,String love) { this.name = name; this.love = love; this.age = age; System.out.println(\"Welcome to Code World!\"); System.out.println(\"hello \" + name); } } ·············修改版··················· package cn.meowrain.codeBlock; public class code01 { public static void main(String[] args) { code01_child child01 = new code01_child(\"mike\"); code01_child child02 = new code01_child(\"meme\", 15); code01_child child03 = new code01_child(\"meow\", 18, \"bear\"); } } class code01_child { String name; int age; String love; { System.out.println(\"Welcome to Code World!\"); } public code01_child(String name) { this.name = name; System.out.println(\"hello \" + name); } public code01_child(String name, int age) { this.name = name; this.age = age; System.out.println(\"hello \" + name); } public code01_child(String name,int age,String love) { this.name = name; this.love = love; this.age = age; System.out.println(\"hello \" + name); } } 输出结果： Welcome to Code World! hello mike Welcome to Code World! hello meme Welcome to Code World! hello meow static 代码块\rstatic代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，并且只会执行一次。 实际使用： package cn.meowrain.codeBlock; public class code01 { public static void main(String[] args) { code01_child child01 = new code01_child(\"mike\"); code01_child child02 = new code01_child(\"meme\", 15); code01_child child03 = new code01_child(\"meow\", 18, \"bear\"); } } class code01_child { String name; int age; String love; static{ System.out.println(\"Welcome to Code World!\"); } public code01_child(String name) { this.name = name; System.out.println(\"hello \" + name); } public code01_child(String name, int age) { this.name = name; this.age = age; System.out.println(\"hello \" + name); } public code01_child(String name,int age,String love) { this.name = name; this.love = love; this.age = age; System.out.println(\"hello \" + name); } } 输出结果： 因为静态代码块只执行一次，所以只输出一次 Welcome to Code World! Welcome to Code World! hello mike hello meme hello meow ","date":"2024-05-18","objectID":"/posts/0112cbb/:3:0","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"代码块使用注意事项\rstatic代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，只会执行一次。如果是普通代码块，每创建一个对象，就执行一次。可以看上面的代码和运行结果 类什么时候被加载？ 创建对象实例 new 的时候 创建子类对象实例，父类也会被加载 使用类的静态成员时（静态属性，静态方法） package cn.meowrain.codeBlock; public class code02 { public static void main(String[] args) { int c = A.sum(109, 10); } } class A { static{ System.out.println(\"hello\"); } public static int sum(int a,int b){ return a+b; } } class B extends A{ } 运行结果： hello 由上可见,静态代码块会在类加载的时候执行 普通的代码块，在创建对象实例（new的时候），会被隐式调用，如果只是单纯使用类中的静态变量，普通代码块不会被执行 package cn.meowrain.codeBlock; public class code02 { public static void main(String[] args) { int c = A.sum(109, 10); } } class A { { System.out.println(\"hello\"); } static int a = 10; public static int sum(int a, int b) { return a + b; } } class B extends A { } 输出结果： 无 创建一个对象的时候，在一个类的调用顺序是: 调用静态代码块和静态属性初始化，按照顺序调用 调用普通代码块和普通属性的初始化，按照顺序调用 调用构造方法 package cn.meowrain.codeBlock; public class code03 { public static void main(String[] args) { AB ab = new AB(); } } class AB { static { System.out.println(\"静态代码块初始化\"); } static int a = getN1(); public static int getN1(){ System.out.println(\"静态方法getN1初始化\"); return 100; } int c = getN2(); public int getN2() { System.out.println(\"普通方法getN2初始化\"); return 200; } public AB(){ System.out.println(\"构造器被调用\"); } } 运行结果如下 静态代码块初始化 静态方法getN1初始化 普通方法getN2初始化 构造器被调用 ","date":"2024-05-18","objectID":"/posts/0112cbb/:3:1","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"单例设计模式\r参考https://www.cnblogs.com/ffforward/p/15259948.html ","date":"2024-05-18","objectID":"/posts/0112cbb/:4:0","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"介绍：\r单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法 单例模式有两种： 饿汉式 懒汉式 ","date":"2024-05-18","objectID":"/posts/0112cbb/:4:1","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"实现方式\r构造器私有化 类的内部创建对象 向外暴露一个静态的公共方法 ","date":"2024-05-18","objectID":"/posts/0112cbb/:4:2","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"饿汉式\r类加载的时候实例化，并且创建单例对象 构造器私有化 在类的内部直接创建对象，该对象为static 提供一个公共的static方法，返回这个对象 package cn.meowrain.singlecasemode; class test { public static void main(String[] args) { Hungry hungry = Hungry.getInstance(); System.out.println(hungry.name); } } public class Hungry { public String name; private Hungry(String name){ this.name = name; } //构造器私有化 private static Hungry hungry = new Hungry(\"hello\"); public static Hungry getInstance(){ return hungry; } } ","date":"2024-05-18","objectID":"/posts/0112cbb/:4:3","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"懒汉式\r懒汉式： 默认不会实例化，什么时候用什么时候new 构造器私有化 定义一个static静态属性对象 提供一个public的static方法，可以返回一个该类对象 懒汉式，只有当用户使用getInstance时，才返回对象，后面再次调用时，会返回上次创建的该类对象，从而保证单例 package cn.meowrain.singlecasemode; class test02 { public static void main(String[] args) { Lazy lazy = Lazy.getInstanceOf(); System.out.println(lazy.name); } } public class Lazy { public String name; private Lazy(String name){ this.name = name; } private static Lazy lazy = null; public static Lazy getInstanceOf(){ if(lazy==null){ lazy = new Lazy(\"mmm\"); } return lazy; } } ","date":"2024-05-18","objectID":"/posts/0112cbb/:4:4","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"饿汉式和懒汉式的区别\r（1）二者最主要的区别在于创建对象的时机不同： 饿汉式是在类加载时就创建了对象实例， 而懒汉式是在使用时才创建。 （2）饿汉式不存在线程安全问题，懒汉式存在线程安全问题。 （3）饿汉式存在浪费资源的可能（没有使用到这个对象实例），而懒汉式不存在这个问题。 （4）在javaSE标准类中，java.lang.Runtime就是经典的单例模式。 ","date":"2024-05-18","objectID":"/posts/0112cbb/:4:5","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"final关键字\r","date":"2024-05-18","objectID":"/posts/0112cbb/:5:0","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"基本介绍：\rfinal可以修饰类，属性，方法和局部变量 使用环境： 1. 当不希望类被继承时，可以用final修饰\r2. 当不希望父类的某个方法被子类覆盖/重写时，可以用final关键字修饰\r3. 当不希望类的某个属性的值被修改，可用final修饰\r4. 当不希望某个局部变量被修改，可以用final修饰\r","date":"2024-05-18","objectID":"/posts/0112cbb/:5:1","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"final使用注意事项\rfinal修饰的属性又叫常量 final修饰的属性在定义的时候，必须赋初值，并且以后不能再修改 如果final修饰的属性是静态的，则初始化的位置只能是 1.定义时 2.在静态代码块中可以赋值，不能在构造器中赋值 final类不能继承，但是可以实例化对象 如果类不是final类，但是有final方法，则该方法虽然不能重写，但可以被继承 6.final和static往往搭配使用，效率更高，不会导致类加载，底层编译器做了优化处理 包装类(Integer,Double,Float,Boolean等都是final)，String也是final类 Java内部类\r","date":"2024-05-18","objectID":"/posts/0112cbb/:5:2","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"1.内部类定义\r把一个类定义在另一个类内部称为内部类 ","date":"2024-05-18","objectID":"/posts/0112cbb/:6:0","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"2.内部类分类\r成员内部类\r成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式： class Circle { private double radius = 0; public Circle(double radius) { this.radius = radius; } class Draw { //内部类 public void drawSahpe() { System.out.println(\"drawshape\"); } } } 类Draw像是类Circle的一个成员，Circle称为外部类。 ** 成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。** class Circle { private double radius = 0; public Circle(double radius) { this.radius = radius; } public void calculateArea() { System.out.println(Math.PI * radius * radius); } class Draw { //内部类 public void drawSahpe() { System.out.println(\"drawshape\"); calculateArea(); } } } class Test { public static void main(String[] args) { Circle circle = new Circle(12); circle.new Draw().drawSahpe(); } } 当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。 如果要访问外部类的同名成员，需要以下面的形式进行访问： 外部类.this.成员变量 外部类.this.成员方法 class Shape { private String shape; public Shape(String shape) { this.shape = shape; } public void getShape() { System.out.println(\"The shape is \" + shape + \"in OuterClass\"); } class Circle { //内部类 private String shape; private int radius; public Circle(int radius,String shape) { this.radius = radius; this.shape = shape; } public void getShape() { System.out.println(\"The shape is Circle in InnerClass\"); } public void getArea() { getShape(); //调用内部类的方法 Shape.this.getShape(); //调用外部类的方法 System.out.println(Math.PI*radius*radius); } } } class Test { public static void main(String[] args) { Shape shape = new Shape(\"Circle\"); Shape.Circle circle = shape.new Circle(2,\"CircleInnerClass\"); circle.getArea(); } } 像这样，可以看到，内部类和外部类有同名方法和属性，我们使用内部类调用了内部类的getArea方法，然后getShape()先取得是内部类得方法，如果想调用外部类方法，就只能用`外部类.this.xxx方法/属性名来调用外部类得同名方法了。 外部类访问内部类\r虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问： class Circle { private double radius = 0; public Circle(double radius) { this.radius = radius; new Draw().drawSahpe(); //必须先创建成员内部类的对象，再进行访问 } class Draw { //内部类 public void drawSahpe() { System.out.println(radius); //外部类的private成员 } } } 成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下： class Outer { public Inner getInnerInstance() { return new Inner(); } class Inner { } } public class Test { public static void main(String[] args) { Outer o = new Outer(); Outer.Inner in = o.new Inner(); //第一种 Outer.Inner in2 = o.getInnerInstance(); //第二种 } } 内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。比如上面的例子，如果成员内部类Inner用private修饰，则只能在外部类的内部访问，如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。 局部内部类\r局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。 public class Test { public static void main(String[] args) { People man = new People(\"meowrain\").createMan(\"meowrain\", 20); man.outputInfo(); } } class People { String name; public People(String name) { this.name = name; } public void outputInfo() { System.out.println(\"The man's name is \" + name + \"\\n\"); } public People createMan(String name, int age) { class Man extends People { int age; public Man(String name, int age) { super(name); this.age = age; } public void outputInfo() { System.out.println(\"The man's name is \" + name + \"\\n\" + \"age is :\" + age); } } return new Man(name, age); } } 匿名内部类\r匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。 不使用匿名内部类 interface func { public void sayHello(); public void PlayGames(); } class Human implements func { String name; int age; public Human(String name, int age) { this.name = name; this.age = age; } @Override public void sayHello() { System.out.println(\"Hello World\"); } @Override public void PlayGames() { System.out.println(\"Playing Games now\"); } public void outputInfo() { System.out.println(\"The human's name is \" + name + \"\\n\" + \"The human's age is \" + age); } } public class Anoymous { public static void main(String[] args) { Human human = new Human(\"meowrain\", 20); human.PlayGames(); human.sayHello(); human.outputInfo(); } } 》 在上面的代码中，我们没有使用匿名内部类，但是实现了func接口 接下来我们使用匿名内部类 //可以直接访问外部类的所有成员，包含私有的 //如果外部类和匿名内部类的成员重名时，匿名内部类访问的话， //默认遵循就近原则，如果想访问外部类的成员，则","date":"2024-05-18","objectID":"/posts/0112cbb/:6:1","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"Java面向对象基础（中级）\rConsolas, ‘Courier New’, monospace ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:0:0","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"包\r","date":"2024-05-18","objectID":"/posts/f4f8ed5/:1:0","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"包的三大作用\r1.区分相同名字的类 2.当类很多的时候，可以很好地管理类 3.控制访问范围 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:1:1","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"包的基本语法\r1.package 关键字 2. com.xxxx 表示包名 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:1:2","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"包的本质分析\r包的本质就是创建不同的文件夹和目录来保存类文件 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:1:3","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"包的命名\r只能包含数字，下划线，小圆点，但不能用数字开头，也不能是关键字和保留字 命名规范： com.xxxx.usr 用户模块 com.xxxx.utils 工具模块 域名反着写，最后加上模块名 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:1:4","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"常用的包\r","date":"2024-05-18","objectID":"/posts/f4f8ed5/:1:5","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"引入包\r语法：import 包名.类名 案例： package cn.meowrain.Object_.package_; import java.util.Scanner; public class package_01 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(); System.out.println(a); } } ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:1:6","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"访问修饰符\r","date":"2024-05-18","objectID":"/posts/f4f8ed5/:2:0","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"封装\r","date":"2024-05-18","objectID":"/posts/f4f8ed5/:3:0","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"封装介绍\r封装就是把抽象出的数据[属性]和对数据的操作**[方法]封装在一起，数据被保护在内部，程序的其它部分只有通过被授权的操作[方法]**，才能对数据进行操作 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:3:1","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"封装的理解和好处\r隐藏实现细节 可以对数据进行验证，保证安全合理 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:3:2","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"封装实现的步骤\r将属性进行私有化（不能直接修改属性） 提供一个公共的(public)set方法，用于对属性判断并赋值 public void setXXX(类型 参数名) { // XXX表示某个属性 //加入数据验证的业务逻辑 属性 = 参数名; } 提供一个公共的(public)get方法，用于获取属性的值 public 数据类型 getXXX(){ //权限判断，xxx某个属性 return xxx; } ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:4:0","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"快速入门案例\rpackage cn.meowrain.Encap_; public class encap_01 { public static void main(String[] args) { Person person = new Person(); person.setName(\"meowrainyyds\"); person.setAge(-1); } } class Person { public String name; private int age; private double salary; private String job; public void setName(String name) { if(name.length()\u003e=6||name.length()\u003c=2){ System.out.println(\"名字的长度错误，长度需要在2-6之间\"); }else { this.name = name; } } public void setAge(int age) { if(age\u003c=1||age\u003e=120){ System.out.println(\"输入年龄错误(1-120)\"); }else { this.age = age; } } public void setSalary(double salary) { this.salary = salary; } public void setJob(String job) { this.job = job; } public String getName() { return name; } public int getAge() { return age; } public double getSalary() { return salary; } public String getJob() { return job; } public void getInfo() { System.out.println(name + \" \" + \"is\" + age + \"years old\"); } } ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:4:1","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"把构造器和封装结合\r在构造器中添加 setName(name); setAge(age); 即可实现构造的时候调用这两个函数，从而判断输入的数据是否符合要求，然后使用这两个函数进行赋值 package cn.meowrain.Encap_; public class encap_01 { public static void main(String[] args) { Person person = new Person(\"meowrainyyds\", -1); person.getInfo(); } } class Person { public String name; private int age; private double salary; private String job; public Person(String name, int age) { setName(name); setAge(age); } public void setName(String name) { if (name.length() \u003e= 6 || name.length() \u003c= 2) { System.out.println(\"名字的长度错误，长度需要在2-6之间\"); } else { this.name = name; } } public void setAge(int age) { if (age \u003c= 1 || age \u003e= 120) { System.out.println(\"输入年龄错误(1-120)\"); } else { this.age = age; } } public void setSalary(double salary) { this.salary = salary; } public void setJob(String job) { this.job = job; } public String getName() { return name; } public int getAge() { return age; } public double getSalary() { return salary; } public String getJob() { return job; } public void getInfo() { System.out.println(name + \" \" + \"is\" + age + \"years old\"); } } ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:4:2","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"课堂练习\rpackage cn.meowrain.Encap_; public class encap_02 { } class Account { String name; int balance; public Account(String name, int balance) { setName(name); setBalance(balance); } public void setName(String name) { if (name.length() \u003e= 2 \u0026\u0026 name.length() \u003c= 4) { this.name = name; }else{ System.out.println(\"名字长度在2-4位之间，你输入的名字不合法\"); } } public void setBalance(int balance) { if(balance\u003e20){ this.balance = balance; }else { System.out.println(\"余额必须大于20\"); } } public void getInfo(){ System.out.println(name + \" \" + balance); } } class AccountTest { public static void main(String[] args) { Account account = new Account(\"meowrain\", 24); account.getInfo(); } } ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:4:3","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"继承\r","date":"2024-05-18","objectID":"/posts/f4f8ed5/:5:0","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"为什么需要继承\r","date":"2024-05-18","objectID":"/posts/f4f8ed5/:5:1","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"继承的基本介绍和示意图\r","date":"2024-05-18","objectID":"/posts/f4f8ed5/:5:2","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"继承的基本语法\rclass 子类 extends 父类{ } 1.子类就会自动拥有父类定义的属性和方法 2.父类又叫超类和基类 3.子类又叫做派生类 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:5:3","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"快速入门案例\rpackage cn.meowrain.extends_; public class extends_01 { public static void main(String[] args) { Student student = new Student(\"mike\", 17, 100); student.eat(); //mike is eating } } class Human { String name; int age; public Human(String name, int age) { this.name = name; this.age = age; } //下面这个eat方法是共有的方法 public void eat(){ System.out.println(name + \" is \" + \"eating\"); } } class Student extends Human { //Student继承了父类Human的所有属性 double grades; public Student(String name, int age, double grades) { super(name, age);//构造器要使用super this.grades = grades; } } ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:5:4","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"继承给编程带来的便利\r复用性增强 代码的扩展性和维护性提高 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:5:5","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"细节问题\r子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问，要通过父类提供公共的方法去访问 子类必须调用父类的构造器，完成父类的初始化 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用super去指定使用父类的哪个构造器完成对父类的初始化工作，否则编译不会通过 如果希望指定去调用父类的某个构造器，则显式地调用一下：super(参数列表) super在使用时，必须放在构造器第一行（super只能在构造器中使用） super()和this()都只能放在构造器的第一行，因此这两个方法不能共存在一个构造器 super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。 this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。 java所有类都是 Object类的子类，Object类是所有类的基类 父类构造器的调用不限于直接父类，将一直往上追溯直到 Object类 子类最多只能继承一个父类 不能滥用继承，子类和父类之间必须满足is-a的逻辑关系 package cn.meowrain.extends_; public class extends_02 { } class Base { int n1; int n2; String name; public Base() { }// 无参构造器 public Base(int n1) { this.n1 = n1; } public Base(int n1, int n2) { this.n1 = n1; this.n2 = n2; } public Base(int n1, int n2, String name) { this(n1, n2); /* * 这个this(n1,n2); * 相当于调用上面的 this.n1 = n1; this.n2 = n2; */ this.name = name; } } class kids extends Base { int age; public kids(int n1,int n2,int age){ super(n1,n2); /* super(n1,n2); * 相当于 * this.n1 = n1; this.n2 = n2; */ this.age = age; } } class adult extends Base { public adult(int n1,int n2,String name){ super(n1,n2,name); } } class little_kids extends kids { String love; public little_kids(int n1,int n2,int age,String love){ super(n1,n2,age); this.love = love; } } ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:5:6","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"继承的本质分析\r看下面这些代码 package com.hspedu.extend_; /** * 讲解继承的本质 */ public class ExtendsTheory { public static void main(String[] args) { Son son = new Son();// 内存的布局 // ?-\u003e 这时请大家注意，要按照查找关系来返回信息 // (1) 首先看子类是否有该属性 // (2) 如果子类有这个属性，并且可以访问，则返回信息 // (3) 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回信息..) // (4) 如果父类没有就按照(3)的规则，继续找上级父类，直到 Object... // System.out.println(son.name);//返回就是大头儿子 // System.out.println(son.age);//返回的就是 39 // System.out.println(son.getAge());//返回的就是 39 System.out.println(son.hobby);// 返回的就是旅游 } } class GrandPa { // 爷类 String name = \"大头爷爷\"; String hobby = \"旅游\"; } class Father extends GrandPa {// 父类 String name = \"大头爸爸\"; private int age = 39; public int getAge() { return age; } } class Son extends Father { // 子类 String name = \"大头儿子\"; } 子类创建的内存布局 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:5:7","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"练习\r会输出 a b name b 分析：B类无参构造器中，其实第一句是隐藏的super()，所以会先执行A类的无参构造器，输出a，然后执行this(\"abc\")，调用B类本类下的有参构造器，输出b name，接着执行System.out.println(\"b\")，输出b 编写 Computer 类，包含 CPU、内存、硬盘等属性，getDetails 方法用于返回 Computer 的详细信息 编写 PC 子类，继承 Computer 类，添加特有属性【品牌 brand】 编写 NotePad 子类，继承 Computer 类，添加特有属性【color】 编写 Test 类，在 main 方法中创建 PC 和 NotePad 对象，分别给对象中特有的属性赋值，以及从 Computer 类继承的属性赋值，并使用方法并打印输出信息 package cn.meowrain.extends_; class Test { public static void main(String[] args) { PC pc = new PC(\"i5\", 16, 512, \"Lenovo\"); Notepad notepad = new Notepad(\"j1900\", 8, 64, \"white\"); pc.getDetails(); notepad.getDetails(); } } public class Computer { String brand; String cpu; int memory; int disk_size; public Computer(String cpu, int memory, int disk_size) { this.cpu = cpu; this.memory = memory; this.disk_size = disk_size; } public void getDetails() { System.out.println(\"the computer's\" + \" \" + \"cpu is \" + cpu + \" \" + \"the memory size is \" + memory + \" \" + \"the disk size is\" + \" \" + disk_size); } } class PC extends Computer { String brand; public PC(String cpu, int memory, int disk_size, String brand) { super(cpu, memory, disk_size); this.brand = brand; } public void getDetails() { System.out.println(\"the computer's brand is\" + brand + \" \" + \"cpu is \" + cpu + \" \" + \"the memory size is \" + memory + \" \" + \"the disk size is\" + \" \" + disk_size); } } class Notepad extends Computer { String color; public Notepad(String cpu, int memory, int disk_size, String color) { super(cpu, memory, disk_size); this.color = color; } public void getDetails() { System.out.println(\"the computer's color is\" + color + \" \" + \"cpu is \" + cpu + \" \" + \"the memory size is \" + memory + \" \" + \"the disk size is\" + \" \" + disk_size); } } ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:5:8","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"super关键字\r","date":"2024-05-18","objectID":"/posts/f4f8ed5/:6:0","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"基本介绍\rsuper代表父类的引用，用于访问父类的属性，方法和构造器 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:6:1","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"基本语法\r访问父类的属性，但是不能访问父类的 private属性 使用：super.属性名 访问父类的方法，不能访问父类的private方法 使用：super.方法名(参数列表) 访问父类的构造器 使用：super(参数列表) 只能放在构造器的第一句，只能出现一句 案例： package cn.meowrain.extends_; public class super_ { public static void main(String[] args) { Child_01 child = new Child_01(); child.getRes(); } } class Base_01 { public String name = \"mike\"; private int age = 8; public int getSum(int a,int b) { return a+b; } } class Child_01 extends Base_01 { public String name = super.name;//把父类的name属性的值赋值给自雷的name属性 // public int age = super.age; 报错 public void getRes(){ System.out.println(super.getSum(19, 20));//调用并且输出父类中getSum方法的返回值 } } ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:6:2","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"super给编程带来的便利\r","date":"2024-05-18","objectID":"/posts/f4f8ed5/:6:3","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"super和this的比较\r","date":"2024-05-18","objectID":"/posts/f4f8ed5/:6:4","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"方法重写（Override）\r","date":"2024-05-18","objectID":"/posts/f4f8ed5/:7:0","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"基本介绍\r方法重写就是子类有一个方法，和父类的某个方法的名称，返回类型，参数一样，那么我们就说子类的这个方法覆盖了父类的方法 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:7:1","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"快速入门\rpackage cn.meowrain.extends_; public class override_ { public static void main(String[] args) { Child_02 child_02 = new Child_02(); child_02.getInfo(); } } class Base_02 { public void getInfo() { System.out.println(\"hello my friends\"); } } class Child_02 extends Base_02 { @Override public void getInfo() { System.out.println(\"hello my good friends\"); } } ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:7:2","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"注意项\r子类方法不能缩小父类方法的访问权限 子类方法的形参列表，方法名称，要和父类方法的形参列表，方法名称完全一样 子类方法的返回类型和父类方法的返回类型要一样，或者是父类返回类型的子类，比如：父类返回类型是Object，子类方法返回的类型是String ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:7:3","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"方法重写和重载的区别\r重载是 https://meowrain.cn/archives/java-mian-xiang-dui-xiang-ji-chu--chu-ji- 中的内容，回顾清看上面链接的内容 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:7:4","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"多态\r","date":"2024-05-18","objectID":"/posts/f4f8ed5/:8:0","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"基本介绍\r方法或对象具有多种形态，是面向对象的第三大特征，多态是建立在封装和继承基础上的 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:8:1","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"多态存在的三个必要条件\r继承 重写 父类引用指向子类对象：Parent p = new Child(); ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:8:2","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"多态的具体体现\r方法的多态\r上图代码实现： Shap.java package cn.meowrain.Poly; public class Shape { public void draw(){ System.out.println(\"画图形\"); } } Circle.java package cn.meowrain.Poly; public class Circle extends Shape{ public void draw(){ System.out.println(\"画圆形\"); } } Square.java package cn.meowrain.Poly; public class Square extends Shape{ public void draw(){ System.out.println(\"画方形\"); } } Triangle.java package cn.meowrain.Poly; public class Triangle extends Shape{ public void draw(){ System.out.println(\"画三角形\"); } } Runner.java package cn.meowrain.Poly; public class Runner { public static void main(String[] args) { Shape circle = new Circle(); circle.draw(); Shape triangle = new Triangle(); triangle.draw(); Shape square = new Square(); square.draw(); } } 注意： 1.一个对象的编译类型和运行类型可以不一致 2.编译类型在定义对象时就确定了，不能改变 3.运行类型是可以变化的 4.编译类型看定义时候=号的左边，运行类型看=号的右边 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:8:3","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"多态注意事项和细节讨论\r多态的前提是： 两个对象（类）存在继承关系 多态的向上转型\r本质：父类的引用指向了子类的对象 语法：==父类类型 引用名 = new 子类类型();== 特点：编译类型看左边，运行类型看右边 可以调用父类中的所有成员（需遵守访问权限） 不能调用子类中的特有成员–\u003e只能调用子类和父类共有的成员 最终运行效果看子类的具体实现 多态的向下转型\r语法： ==子类类型 引用名 = (子类类型)父类引用;== 只能强制转父类的引用，不能强转父类的对象 要求父类的引用必须指向的是当前目标类型的对象 当向下转型后，可以调用子类类型中所有成员 案例演示: Animal.java package cn.meowrain.Poly.poly02; public class Animal { String name = \"动物\"; int age = 10; public void sleeper() { System.out.println(\"睡\"); } public void run() { System.out.println(\"跑\"); } public void eat(){ System.out.println(\"吃\"); } public void show() { System.out.println(\"hello 你好\"); } } Cat.java package cn.meowrain.Poly.poly02; public class Cat extends Animal{ public void eat(){ //方法重写 System.out.println(\"猫吃鱼\"); } public void catchMouse() {//cat特有方法 System.out.println(\"猫抓老鼠\"); } } PolyDetail.java package cn.meowrain.Poly.poly02; public class PolyDetail { public static void main(String[] args) { //向上转型,父类的引用指向了子类的对象 Animal animal = new Cat(); //animal.catchMouse() 错误,只能调用共同的属性 //因为在编译阶段,能调用哪些成员,是由编译类型决定的 //最终运行效果看运行类型的具体实现 animal.eat(); animal.run(); animal.show(); animal.sleeper(); //如果想调用Cat的catchMouse方法 //多态的向下转型 //子类类型 引用名 = (子类类型)父类引用 Cat cat = (Cat)animal; cat.catchMouse(); } } 注意: 属性没有重写只说! 属性的值看编译类型,也就是左侧 看下面的代码: package cn.meowrain.Poly.poly03; public class item { public static void main(String[] args) { Base base = new Sub(); //属性的值看编译类型 System.out.println(base.count);//120 } } class Base {//父类 int count = 120; } class Sub extends Base { //子类 int count = 234; } instanceOf比较操作符\r介绍: instanceOf比较操作符,用于判断对象的运行类型是否为XX类型的子类型 举个例子: package cn.meowrain.Poly.poly03; public class PolyDetail03 { public static void main(String[] args) { BB bb = new BB(); //运行类型是BB System.out.println(bb instanceof BB); //true System.out.println(bb instanceof AA); //true //向上转型 //AA是编译类型,BB是运行类型 AA aa = new BB();//运行类型是BB System.out.println(aa instanceof AA); //true System.out.println(aa instanceof BB);// true //向下转型 BB ab = (BB)aa;//运行类型是BB System.out.println(ab instanceof AA); //true System.out.println(ab instanceof BB); //true AA am = new AA(); //运行类型是AA System.out.println(am instanceof AA);// true System.out.println(am instanceof BB); //false } } class AA { } class BB extends AA { } ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:8:4","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"java的动态绑定\r当调用对象方法的的时候，该方法回和该都西昂的内存地址/运行类型绑定 当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用 在向上转型情况下的动态绑定示例\r父类方法，对象类型：class cn.meowrain.bind.Son package cn.meowrain.bind; public class bind01 { public static void main(String[] args) { Father sample = new Son();//向上转型 sample.method(); } } class Father { public void method(){ System.out.println(\"父类方法，对象类型：\" + this.getClass()); } } class Son extends Father { } 声明的是父类的引用，但是调用了子类对象，调用method，子类中没有这个方法，就去父类中去找，然后进行调用 接下来我们修改子类，在子类中重写method方法 package cn.meowrain.bind; public class bind01 { public static void main(String[] args) { Father sample = new Son();//向上转型 sample.method(); } } class Father { public void method(){ System.out.println(\"父类方法，对象类型：\" + this.getClass()); } } class Son extends Father { @Override public void method() { System.out.println(\"子类方法，对象类型： \" +this.getClass()); } } 子类方法，对象类型： class cn.meowrain.bind.Son 掉用子类对象，子类中含有method方法，所以调用子类中的这个method方法 注意： 下面说到的不属于动态绑定 运行时（动态）绑定针对的范畴只是对象的方法。 接下来我们来看一看属性绑定 package cn.meowrain.bind; public class bind01 { public static void main(String[] args) { Father sample = new Son();//向上转型 System.out.println(sample.name); } } class Father { String name = \"父类属性\"; } class Son extends Father { String name = \"子类属性\"; } 运行结果： 父类属性 从上面我们可以看出，输出是由编译类型决定的 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:9:0","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"多态的应用\r多态数组\r数组的定义类型是父类类型，里面保存的实际元素类型为子类类型 应用实例：： 现有一个结构如下，要求创建1个Person对象，2个Student对象和2个Teacher对象，统一放在数组中，并调用每个对象的say方法 package cn.meowrain.bind; public class bind02 { public static void main(String[] args) { Person[] persons = new Person[5]; persons[0] = new Person(\"jack\", 20); persons[1] = new Student(\"mike\", 18, 100); persons[2] = new Student(\"meowrain\", 19, 150); persons[3] = new Teacher(\"gac\", 24, 110); persons[4] = new Teacher(\"jjj\", 25, 123); // persons[i]编译类型是Person，运行类型是根据实际情况通过JVM判断的 for (int i = 0; i \u003c persons.length; i++) { System.out.println(persons[i].say());// 动态绑定机制 if (persons[i] instanceof Student) { Student student = (Student) persons[i];//向下转型 student.study(); //可以用下面这个替代 // ((Student)persons[i]).study(); } else if (persons[i] instanceof Teacher) { Teacher teacher = (Teacher) persons[i];//向下转型 teacher.teach(); //可以用下面这个替代 // ((Teacher)persons[i]).teach(); } } } } class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String say() { return \"Perosn \" + getName() + \" is \" + getAge() + \"years old\"; } } class Student extends Person { private int score; public Student(String name, int age, int score) { super(name, age); this.score = score; } public int getScore() { return score; } public void setScore(int score) { this.score = score; } @Override public String say() { return \"Student \" + getName() + \" \" + \"is\" + \" \" + \"learning\" + \" \" + \"his score is \" + getScore(); } public void study() { System.out.println(\"student \" + getName() + \"is learning\"); } } class Teacher extends Person { private double salary; public Teacher(String name, int age, double salary) { super(name, age); this.salary = salary; } public double getSalary() { return salary; } public void setSalary(double salary) { this.salary = salary; } @Override public String say() { return \"Teacher \" + getName() + \"is teaching\" + \" \" + \"his salary is \" + getSalary(); } public void teach() { System.out.println(\"Teacher \" + getName() + \"is teaching\"); } } 多态参数\r方法定义的形参类型为父类类型，实参类型允许为子类类型 定义员工类Employee,包含姓名和月工资（private)，以及计算年工资getAnnual的方法，普通员工和经理继承了员工，经理类多了奖金bonus和管理manage方法，普通员工多了work方法，普通员工和经理类要求分别重写getAnnual方法 测试类中添加一个方法showEmpAnnual(Employee e),实现获取任何员工对象的年工资，并在main方法中调用该方法[e.getAnnual] 测试类中添加一个方法，testWork,如果是普通员工，就调用那个work方法。如果是经理，就调用manage方法 Test.java package cn.meowrain.Poly.poly04; public class Test { public double showEmpAnnual(Employee e) { return e.getAnnual(); } public void testWork(Employee e){ if(e instanceof NormalEmployee){ ((NormalEmployee)e).work(); }else if (e instanceof Manager){ ((Manager)e).manage(); } } public static void main(String[] args) { NormalEmployee worker = new NormalEmployee(\"mike\", 4000); Manager manager = new Manager(\"john\", 4300, 5000); Test test = new Test(); System.out.println(\"管理者工资： \" + test.showEmpAnnual(manager)); System.out.println(\"工人工资： \" + test.showEmpAnnual(worker)); test.testWork(manager); test.testWork(worker); } } Employee.java package cn.meowrain.Poly.poly04; public class Employee { private String name; private double salary; public Employee(String name, double salary) { this.name = name; this.salary = salary; } public String getName() { return name; } public void setName(String name) { this.name = name; } public double getSalary() { return salary; } public void setSalary(double salary) { this.salary = salary; } public double getAnnual () { return salary*12; } } Manager.java package cn.meowrain.Poly.poly04; public class Manager extends Employee{ private double bonus; public Manager(String name, double salary, double bonus) { super(name, salary); this.bonus = bonus; } public double getBonus() { return bonus; } public void setBonus(double bonus) { this.bonus = bonus; } public void manage(){ System.out.println(\"Manager \" + getName() + \" \" + \"is managing\"); } @Ove","date":"2024-05-18","objectID":"/posts/f4f8ed5/:9:1","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"Object类详解\r","date":"2024-05-18","objectID":"/posts/f4f8ed5/:10:0","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"equals方法\r== 是一个比较运算符 在看下面这个东西之前，我们先抛出一个问题 String属于什么数据类型？ https://zhuanlan.zhihu.com/p/136468277 引用类型 基本数据类型和引用数据类型详见Java数据类型：基本数据类型和引用数据类型 (biancheng.net) 区分 package com.hsp.object; public class Equals_exercise02 { public static void main(String[] args) { String name_1 = \"hello\"; String name_2 = \"hello\"; System.out.println(name_2 == name_1);//true /* * String str1 = \"abcd\"的实现过程：首先栈区创建str引用， * 然后在String池（独立于栈和堆而存在，存储不可变量） * 中寻找其指向的内容为\"abcd\"的对象，如果String池中没有， * 则创建一个，然后str指向String池中的对象， * 如果有，则直接将str1指向\"abcd\"\"； * 如果后来又定义了字符串变量 str2 = \"abcd\", * 则直接将str2引用指向String池中已经存在的“abcd”， * 不再重新创建对象；当str1进行了赋值（str1=“abc”）， * 则str1将不再指向\"abcd\"，而是重新指String池中的\"abc\"， * 此时如果定义String str3 = \"abc\",进行str1 == str3操作， * 返回值为true，因为他们的值一样，地址一样， * 但是如果内容为\"abc\"的str1进行了字符串的+连接str1 = str1+\"d\" * ；此时str1指向的是在堆中新建的内容为\"abcd\"的对象， * 即此时进行str1==str2，返回值false，因为地址不一样。 String str3 = new String(\"abcd\")的实现过程： * 直接在堆中创建对象。 * 如果后来又有 * String str4 = new String(\"abcd\")，str4不会指向之前的对象， * 而是重新创建一个对象并指向它， * 所以如果此时进行str3==str4返回值是false， * 因为两个对象的地址不一样，如果是str3.equals(str4)， * 返回true,因为内容相同。 * */ String name_3 = new String(\"hello\"); String name_4 = new String(\"hello\"); System.out.println(name_3 == name_4);//false System.out.println(name_3.equals(name_4)); System.out.println(name_1.equals(name_2)); } } ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:10:1","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"hashCode方法\r提高具有哈希结构的容器效率 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的 两个引用，如果指向的是不同的对象，则哈希值是不一样的 哈希值主要根据地址号来的，不能将哈希值等价于地址 package com.hsp.object; public class HashCode { public static void main(String[] args) { AA aa = new AA(); AA aa2 = new AA(); System.out.println(aa.hashCode()); System.out.println(aa2.hashCode()); /*460141958 1163157884*/ } } class AA {} ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:10:2","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"toString方法\r基本介绍： 默认返回： 全类名 + @ + 哈希值的十六进制 子类往往重写toString方法，用于返回对象的属性信息 package com.hsp.object; public class toString { public static void main(String[] args) { Monster monster = new Monster(\"妖怪\",\"保安\",1000); System.out.println(monster.toString());//com.hsp.object.Monster@1b6d3586 } } class Monster { private String name; private String job; private double sal; public Monster(String name, String job, double sal) { this.name = name; this.job = job; this.sal = sal; } } 重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式 package com.hsp.object; public class toString { public static void main(String[] args) { Monster monster = new Monster(\"妖怪\",\"保安\",1000); System.out.println(monster.toString());//Monster{name='妖怪', job='保安', sal=1000.0} } } class Monster { private String name; private String job; private double sal; // 重写toString方法 @Override public String toString() { return \"Monster{\" + \"name='\" + name + '\\'' + \", job='\" + job + '\\'' + \", sal=\" + sal + '}'; } public Monster(String name, String job, double sal) { this.name = name; this.job = job; this.sal = sal; } } 当直接输出一个对象时候，toString方法会被默认的调用 package com.hsp.object; public class toString { public static void main(String[] args) { Monster monster = new Monster(\"妖怪\", \"保安\", 1000); System.out.println(monster); } } class Monster { private String name; private String job; private double sal; // 重写toString方法 @Override public String toString() { return \"Monster{\" + \"name='\" + name + '\\'' + \", job='\" + job + '\\'' + \", sal=\" + sal + '}'; } public Monster(String name, String job, double sal) { this.name = name; this.job = job; this.sal = sal; } } ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:10:3","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"finalize()\r当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法 1.当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作 2.什么时候被回收：当某个对象没有任何引用的时候，则jvm就认为这个对象是一个垃圾对象，就会用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用finalize方法 3.垃圾回收机制的调用，是由系统来决定，也可以由System.gc()主动触发垃圾回收机制 实际开发中基本不会运用，应付面试 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:10:4","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["面向对象","Java"],"content":"Java面向对象基础(初级)\r对面向对象和面向过程的理解 谈谈你对面向过程和面向对象的理解_智十七°的博客-CSDN博客_面向对象和面向过程的理解 ","date":"2024-05-18","objectID":"/posts/61c8cb0/:0:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"面向对象的三大特征\r封装 (Encapsulation) 继承 (Inheritance) 多态 (Polymorphism) ","date":"2024-05-18","objectID":"/posts/61c8cb0/:1:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"初识对象和类\r","date":"2024-05-18","objectID":"/posts/61c8cb0/:2:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"初次使用对象和类\r如下，在下面这个代码中，我创建了一个猫类，然后利用猫类创建了两个猫对象，一个赋值给cat01，一个赋值给cat02 package cn.meowrain.Object_; public class relean_01 { public static void main(String[] args) { //创建两猫对象 Cat cat01 = new Cat(); cat01.name = \"小花\"; cat01.age = 1; cat01.color = \"花色\"; Cat cat02 = new Cat(); cat02.name = \"小白\"; cat02.age = 2; cat02.color = \"白色\"; //访问对象属性 System.out.println(cat01.name); System.out.println(cat02.name); cat01.eat(); cat02.eat(); } } class Cat { public String name; public int age; public String color; public void eat(){ System.out.println(name + \"吃饭\"); } public void drink(){ System.out.println(name + \"喝水\"); } } new Cat() //创建一只猫对象 Cat cat01 = new Cat();//把创建的猫对象赋值给cat01 cat01是对象名(对象引用) ","date":"2024-05-18","objectID":"/posts/61c8cb0/:3:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"如何创建一个对象\r1) 先声明再创建 Cat cat ; //声明对象 cat cat = new Cat(); //创建 2) 直接创建 Cat cat = new Cat(); 补充：Java中实例化对象是什么意思 在Java语言中使用new关键字创建/构造对象的过程叫做类的实例化，该过程的本质，会在内存空间的堆区申请一块存储区域，用于记录该对象独有的成员变量信息。 通俗点就是，实例化：使用关键字new来创建对象。 例如： Person person = new Person(); 这样的语句称为创建对象。 对象是根据类创建的。在Java中使用关键字new创建对象。 new Person(); 是 声明一个Person类型的对象，在堆区区域。 new Person(); ()是指创建Person类型的对象后，自动调用Person类中的构造方法，来进行成员变量的初始化。 Person person ，Person为类名，person 为引用变量名。 ———————————————— 版权声明：本文为CSDN博主「智十七°」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/weixin_45812336/article/details/113954823 ","date":"2024-05-18","objectID":"/posts/61c8cb0/:3:1","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"对象在内存中的存在形式\r","date":"2024-05-18","objectID":"/posts/61c8cb0/:4:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"属性，成员变量\rpackage cn.meowrain.Object_; public class relearn_02 { } class Hunman { //下面都属于Human类的属性 String name; double salary; int age; String country; } 属性是类的一个组成部分，一般是基本数据类型,也可是引用类型(对象，数组)。上面这个代码中的name,salary等都是这个Human类的属性 属性的定义语法同变量， 示例：访问修饰符 属性类型 属性名 访问修饰符详情见Java 访问修饰符 - 喵雨の小屋|木更老婆！！！ (meowrain.cn) 属性的定义类型可以为任意类型，包含基本类型或引用类型 基本数据类型和引用数据类型详见Java数据类型：基本数据类型和引用数据类型 (biancheng.net) Java数据类型（八种基本数据类型 + 四种引用数据类型）_火火笔记的博客-CSDN博客_引用数据类型有哪几种 属性如果不赋值，有默认值，规则和数组一致。 具体: ==int 0，short 0, byte 0, long 0, float 0.0,double 0.0，char \\u0000， boolean false，String null== ","date":"2024-05-18","objectID":"/posts/61c8cb0/:5:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"如何访问属性\r基本语法 对象名.属性名; 示范： package cn.meowrain.Object_; public class relearn_02 { Human human01 = new Human(); human01.name = \"mike\"; human01.age = 20; System.out.println(human.name + \"is\" + human01.age + \"years old\") } class Hunman { //下面都属于Human类的属性 String name; double salary; int age; String country; } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:5:1","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"类和对象的内存分配机制\r我们定义一个人类(Person)(包括 名字,年龄) package cn.meowrain.Object_; public class relearn_03 { public static void main(String[] args) { Person p1 = new Person(); p1.age = 10; p1.name = \"小明\"; Person p2 = p1; System.out.println(p2.age); } } class Person { public int age; public String name; } 问题：p2.age 究竟是多少，画出内存图 ","date":"2024-05-18","objectID":"/posts/61c8cb0/:6:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"Java 内存的结构分析\r栈： 一般存放基本数据类型(局部变量) 堆： 存放对象(Cat cat , 数组等) 方法区：常量池(常量，比如字符串)， 类加载信息 Java 创建对象的流程简单分析\r","date":"2024-05-18","objectID":"/posts/61c8cb0/:6:1","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"方法重载\rjava中允许同一个类中，多个同名方法的存在，但是要求形参列表不一致 通过重载，我们减轻了起名的麻烦 案例： package cn.meowrain.Object_; public class relearn_06 { public static void main(String[] args) { rel rel = new rel(); int m = rel.getSum(1,2,3); System.out.println(m); int n = rel.getSum(1,2); } } class rel { public int getSum(int n1,int n2){ return n1+n2; } public int getSum(int n1,int n2,int n3){ return n1+n2+n3; } } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:7:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"可变参数\rjava允许把同一个类中多个同名同功能但是参数个数不同的方法，封装成一个方法 基本语法： //int... 表示接受的是可变参数，类型是int，即可以接收多个int\r//使用可变参数时候，可以当数组来使用，nums可以当做数组\rpackage cn.meowrain.Object_; public class relearn_07 { public static void main(String[] args) { rel_07 rel = new rel_07(); int m = rel.getSum(1,2,3,4);//10 int n = rel.getSum(5,6,7);//18 int b = rel.getSum(0,1);//1 System.out.println(m); System.out.println(n); System.out.println(b); } } class rel_07 { //int... 表示接受的是可变参数，类型是int，即可以接收多个int //使用可变参数时候，可以当数组来使用，nums可以当做数组 public int getSum(int... nums){ int res = 0; for(int i = 0;i\u003cnums.length;i++){ res+=nums[i]; } return res; } } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:7:1","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"作用域\rpackage cn.meowrain.Object_; public class relearn_08 { public static void main(String[] args) { } } class Dog { //全局变量：也就是属性，作用域为整个类体Cat类，cry eat等方法使用属性 //属性在定义时，可以直接赋值 int age = 10; double weight;//默认是0.0 public void hi() { //局部变量必须赋值后才能使用，因为没有默认值 //局部变量一般是指在成员方法中定义的变量 int num = 1; String address = \"Beijing's Dog\"; System.out.println(\"num=\" + num); System.out.println(\"address\" + address); System.out.println(\"weight=\" + weight); } public void cry() { int n = 10; String name = \"jack\"; System.out.println(name + \"cry for\" + n + \"times\"); } public void eat() { String name = \"meow\"; System.out.println(name + \"eat\"); } } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:8:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"注意事项和使用细节\r属性可以加修饰符，但是局部变量不能加修饰符 ","date":"2024-05-18","objectID":"/posts/61c8cb0/:8:1","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"构造器\r构造方法又叫构造器(constructor)，是类的一种特殊的方法， 它的主要作用是完成对新对象的初始化。它有几个特点： 方法名和类名相同 没有返回值 在创建对象时，系统会自动的调用该类的构造器完成对象的初始化。 基本语法： [修饰符] 方法名(形参列表) { 方法体 } 案例： package cn.meowrain.Object_; public class relearn_09 { public static void main(String[] args) { rel_09 rel = new rel_09(\"meowrain\", 18); rel_09 rel_1 = new rel_09(\"meow\", 20, \"mouse\"); rel.getInfo(); rel_1.getItem(); } } class rel_09 { String name; int age; String item; public rel_09(String name, int age) { this.name = name; this.age = age; } // 构造器重载 public rel_09(String name, int age, String item) { this.name = name; this.age = age; this.item = item; } public void getInfo() { System.out.println(this.name + \" \" + this.age); } public void getItem() { System.out.println(this.item); } } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:9:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"练习题：\rpackage cn.meowrain.Object_; public class relearn_10 { public static void main(String[] args) { Person_n person01 = new Person_n(\"meow\", 12); Person_n person02 = new Person_n(); System.out.println(person01.name + \" is \" + person01.age + \"years old\"); System.out.println(person02.name + \" is \" + person02.age + \"years old\"); } } class Person_n { String name; int age; public Person_n() { this.age = 18; } public Person_n(String name, int age) { this.name = name; this.age = age; } } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:9:1","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"对象创建的流程分析\r","date":"2024-05-18","objectID":"/posts/61c8cb0/:10:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"this关键字\r什么是this? ==简单说：哪个对象调用，this就代表哪个对象== package cn.meowrain.Object_; public class relearn12 { } class This01 { public static void main(String[] args) { Dog_new dog_new = new Dog_new(\"大黄\", 1); dog_new.info(); } } class Dog_new { String name; int age; public Dog_new(String name,int age) { this.name = name; this.age = age; } public void info(){ System.out.println(\"this.hashCode=\" + this.hashCode()); System.out.println(name + \"\\t\" + age + \"\\t\"); } } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:11:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"练习题：\rpackage cn.meowrain.Object_; public class relearn13 { public static void main(String[] args) { person_01 p1 = new person_01(\"mary\", 18); person_01 p2 = new person_01(\"mary\",18); System.out.println(p1.compareTo(p2)); //true } } class person_01 { String name; int age; public person_01(String name, int age) { this.name = name; this.age = age; } public boolean compareTo(person_01 p){ if(this.name.equals(p.name)\u0026\u0026this.age == p.age) { return true; } return false; } } 作业\r","date":"2024-05-18","objectID":"/posts/61c8cb0/:11:1","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"作业1\rpackage cn.meowrain.Object_.homework; public class h1 { public static void main(String[] args) { double[] arr = { 1.0, -2.0, 4.5 }; A01 a01 = new A01(); double max = a01.max(arr); System.out.println(max); } } class A01 { public double max(double[] a) { double m = a[0]; for (int i = 0; i \u003c a.length; i++) { if (a[i] \u003e m) m = a[i]; } return m; } } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:12:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"作业2\rpackage cn.meowrain.Object_.homework; public class h2 { public static void main(String[] args) { String[] strArr = {\"helloworld\",\"meowrain\"}; A02 a02 = new A02(); int a = a02.find(strArr); if(a == 0){ System.out.println(true); }else { System.out.println(false); } } } class A02 { public int find(String []arr){ for (int i = 0; i \u003c arr.length; i++){ if(arr[i].equals(\"helloworld\")){ return i; } } return -1; } } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:13:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"作业3\rpackage cn.meowrain.Object_.homework; public class h3 { public static void main(String[] args) { Book book = new Book(\"猫的故事\", 200); Book book2 = new Book(\"狗的故事\", 120); Book book3 = new Book(\"驴的故事\", 20); book.updatePrice(book.price); book2.updatePrice(book2.price); book3.updatePrice(book3.price); System.out.println(book.name + \" : \" + book.price); System.out.println(book2.name + \" : \" + book2.price); System.out.println(book3.name + \" : \" + book3.price); /* * 猫的故事 : 150.0 狗的故事 : 100.0 驴的故事 : 20.0 * */ } } class Book { String name; double price; public Book(String name,double price) { this.name = name; this.price = price; } public void updatePrice(double price){ if(price \u003e 150){ this.price = 150; }else if(price \u003e 100) { this.price = 100; } } } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:14:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"作业4\rpackage cn.meowrain.Object_.homework; public class h4 { public static void main(String[] args) { A03 a03 = new A03(); int[] arr = {1,2,3,4,5}; int[] a1 = a03.copyArr(arr); for(int i=0;i\u003ca1.length; i++){ System.out.println(a1[i]); } } } class A03 { public int[] copyArr(int[] arr) { int[] a = new int[arr.length]; for (int i = 0; i \u003c arr.length; i++){ a[i] = arr[i]; } return a; } } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:15:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"作业5\rpackage cn.meowrain.Object_.homework; public class h5 { public static void main(String[] args) { Circle circle = new Circle(2); double perimeter = circle.perimeter(); double area = circle.area(); System.out.printf(\"%.2f\\n\",perimeter); System.out.printf(\"%.2f\\n\",area); /* * 12.57 12.57 */ } } class Circle { double r; public Circle(double r) { this.r = r; } public double perimeter() { return Math.PI*r*2; } public double area() { return Math.PI * r * r; } } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:16:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"作业6\rpackage cn.meowrain.Object_.homework; public class h6 { public static void main(String[] args) { Cale cale01 = new Cale(5, 2); Cale cale02 = new Cale(1, 0); cale01.divide(); cale02.divide(); } } class Cale { int a, b; public Cale(int a, int b) { this.a = a; this.b = b; } public int sum() { return a + b; } public int multiply() { return a * b; } public void divide() { if (b == 0) { System.out.println(\"输入的除数不能为0！\"); } else { System.out.println(a * 1.0 / b); } } } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:17:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"作业7\rpackage cn.meowrain.Object_.homework; public class h7 { public static void main(String[] args) { Dog dog = new Dog(\"mike\",\"white\",2); dog.show(); } } class Dog { String name; String color; int age; public Dog(String name,String color,int age){ this.name = name; this.color = color; this.age = age; } public void show(){ System.out.println(\"the dog \" + name + \" is \" + age + \" \" + \"years old and its color is \" + color); } } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:18:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"作业8\r","date":"2024-05-18","objectID":"/posts/61c8cb0/:19:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"作业9\rpackage cn.meowrain.Object_.homework; public class h9 { public static void main(String[] args) { Music music01 = new Music(\"青花瓷\", \"4:00\"); Music music02 = new Music(\"鸡你太美\", \"3:00\"); music01.getInfo(); music01.play(); } } class Music { String name; String times; public Music(String name,String times){ this.name = name; this.times = times; } public void play(){ System.out.println(name + \"is palying for \" + times); } public void getInfo(){ System.out.println(\"the music name is \" + name + \"times is : \" + times); } } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:20:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"作业10\rpackage cn.meowrain.Object_.homework; public class h8 { int i = 100; public void m(){ int j = i++; System.out.println(\"i=\" + i); System.out.println(\"j=\" + j); } } class Test { public static void main(String[] args) { h8 demo = new h8(); h8 demo2 = new h8(); demo.m(); System.out.println(demo.i); System.out.println(demo2.i); } } i=101 j=100 101 100 ","date":"2024-05-18","objectID":"/posts/61c8cb0/:21:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"作业11\r不做了 ","date":"2024-05-18","objectID":"/posts/61c8cb0/:22:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"作业12\rpackage cn.meowrain.Object_.homework; public class h12 { Employee_ emp1 = new Employee_(\"经理\", \"10000\"); } class Employee_ { String name; String sex; int age; String position; String salary; public Employee_(String name, String sex, int age, String position, String salary) { this.name = name; this.sex = sex; this.age = age; this.position = position; this.salary = salary; } public Employee_(String name, String sex, int age) { this.name = name; this.sex = sex; this.age = age; } public Employee_(String position, String salary) { this.position = position; this.salary = salary; } } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:23:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"作业13\rpackage cn.meowrain.Object_.homework; public class h13 { public static void main(String[] args) { Circle01 circle = new Circle01(); PassObject pass = new PassObject(); pass.printAreas(circle, 5); } } class Circle01 { public double radius; public double findArea(){ return radius*radius*Math.PI; } } class PassObject { public void printAreas(Circle01 c,int times) { for(int i = times;i\u003e0;i--){ c.radius = i; System.out.println(\"r:\" + i + \" \" + \"S=\" + c.findArea()); } } } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:24:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["C++","面向对象"],"content":"C++ OOP\r","date":"2024-05-18","objectID":"/posts/ae3b30e/:0:0","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"Class(1)\r","date":"2024-05-18","objectID":"/posts/ae3b30e/:1:0","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"private,protected,public\rprivate(默认就是 private)\rprivate 声明的类的私有成员只能由同一类的其他成员或者它们的朋友访问 #include \u003ciostream\u003e #include \u003cstring\u003e class Student { private: int score; public: std::string name; int age; Student(std::string _name,int _age,int _score) : name(_name),age(_age),score(_score){ } void getScore(){ std::cout \u003c\u003c score \u003c\u003c std::endl; } }; int main(void) { Student s(\"meow\",18,100); s.getScore(); } 我们如果在 main 函数中直接用对象输出学生的分数，就不能 #include \u003ciostream\u003e #include \u003cstring\u003e class Student { private: int score; public: std::string name; int age; Student(std::string _name,int _age,int _score) : name(_name),age(_age),score(_score){ } void getScore(){ std::cout \u003c\u003c score \u003c\u003c std::endl; } }; int main(void) { Student s(\"meow\",18,100); std::cout \u003c\u003c s.score \u003c\u003c std::endl; } protected\rprotected 受保护的成员可以从同一类的其他成员（或从他们的“朋友”）访问，也可以从其派生类的成员访问。 #include \u003ciostream\u003e #include \u003cstring\u003e class Human { protected: std::string name; public: Human(std::string _name): name(_name){} void getHumanInfo() { std::cout \u003c\u003c \"Human name is: \" \u003c\u003c name \u003c\u003c std::endl; } //同一类成员访问 }; class Student:Human{ public: int score; Student(std::string _name,int _score): Human(_name),score(_score) { } void getStudentInfo() { std::cout \u003c\u003c \"Student name is :\" \u003c\u003c name \u003c\u003c \"\\tStudent score is :\" \u003c\u003c score \u003c\u003c std::endl; } }; //派生类成员访问 int main(void) { Student s(\"meow\",100); s.getStudentInfo(); Human h(\"meow\"); h.getHumanInfo(); return 0; } public\r公共成员可以从对象可见的任何地方访问。 这里不作代码解释了。😊 ","date":"2024-05-18","objectID":"/posts/ae3b30e/:1:1","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"实现类成员函数\r#include \u003ciostream\u003e class Square { int width; int height; public: void setWidth(int _width) { width = _width; } void setHeight(int _height) { height = _height; } int getArea(); int getPerimeter(); }; int Square::getArea() { return width * height; } int Square::getPerimeter() { return 2*(width + height); } int main() { Square s; s.setHeight(10); s.setWidth(19); std::cout \u003c\u003c s.getArea() \u003c\u003c std::endl; } 当然了，构造函数也可以在外面实现!😊 #include \u003ciostream\u003e #include \u003cstring\u003e class Student { public: std::string name; int age; Student(std::string,int); void getStudentInfo() { std::cout \u003c\u003c name \u003c\u003c \" \" \u003c\u003c age \u003c\u003c std::endl; } }; //在外面实现类的构造函数 Student::Student(std::string _name, int _age) : name(_name),age(_age){} int main() { Student s(\"meow\",10); s.getStudentInfo(); return 0; } ","date":"2024-05-18","objectID":"/posts/ae3b30e/:1:2","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"构造器（Constructors）\rc++ 构造器（最简单的实例）\r#include \u003ciostream\u003e class Rectangle { int width; int height; public: Rectangle(int,int); void getArea(); }; Rectangle::Rectangle(int _w, int _h) { width = _w; height = _h; } void Rectangle::getArea() { std::cout \u003c\u003c width * height \u003c\u003c std::endl; } int main(void) { Rectangle r(100,100); r.getArea(); } 上面是 c++构造器一个简单的用法 重载构造器（包括成员初始化列表）\r试想一下，假如我要求用 Rectangle r创建对象的时候，默认 width = 5,height = 5,但是又要求能给 Rectangle 对象的成员变量赋值，比如让width = 10,height = 20,Rectangle r(10,20). 我们就得这么写 #include \u003ciostream\u003e class Rectangle { int width; int height; public: Rectangle(); Rectangle(int,int); void getArea(){ std::cout \u003c\u003c width*height \u003c\u003c std::endl; } }; Rectangle::Rectangle() { width = 5; height = 5; } Rectangle::Rectangle(int w, int h) { width = w; height = h; } int main(void) { Rectangle r; r.getArea(); //25 Rectangle r2(10,15); r2.getArea(); //150 } 当然了，我们可以不在外面实现构造函数，直接在类里面写也是可以的 #include \u003ciostream\u003e class Rectangle { int width; int height; public: Rectangle() { width = 5; height = 5; } Rectangle(int _w,int _h) { width = _w; height = _h; } void getArea(){ std::cout \u003c\u003c width*height \u003c\u003c std::endl; } }; int main(void) { Rectangle r; r.getArea(); //25 Rectangle r2(10,15); r2.getArea(); //150 } 😊 有没有发现这样很麻烦呢？ 其实在 c++中有一个东西，叫 成员初始化列表，看到上面的重载的第二个构造函数了吗？我们可以像下面这样写 Rectangle(int _w, int _h) : width(_w), height(_h) {}; 这样就大大简化了我们的构造函数书写啦！😊 ","date":"2024-05-18","objectID":"/posts/ae3b30e/:1:3","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"指向类的指针（Pointers to Class)\r在 c++中，我们也 能用指针去指向类，然后通过指针调用类 #include \u003ciostream\u003e #include \u003cstring\u003e class Human { std::string name; public: Human(std::string _name):name(_name){}; void getHumanInfo() { std::cout \u003c\u003c \"Human name is :\" \u003c\u003c name \u003c\u003c std::endl; } }; int main() { //创建Human对象 Human h(\"Mike\"); Human *human = \u0026h; human-\u003egetHumanInfo(); //通过指针调用类的成员函数 //Human name is :Mike return 0; } 😊 既然这样，那我们就可以创建类数组啦 #include \u003ciostream\u003e class Rectangle { int width,height; public: Rectangle(int _w,int _h):width(_w),height(_h){}; void getArea() { std::cout \u003c\u003c width*height \u003c\u003c std::endl; } }; int main(void) { Rectangle r(10,20); Rectangle *ptr = new Rectangle[2]{{2,5},{3,6}}; ptr[0].getArea(); //10 ptr[1].getArea(); //18 delete []ptr; return 0; } 关于指针和 new 这个我会后面参考 c++ primer plus进行进一步说明 ","date":"2024-05-18","objectID":"/posts/ae3b30e/:1:4","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"静态函数\rC++ 中的静态函数是指在类中使用static关键字修饰的成员函数。它与类的实例无关，可以通过类名直接调用，不需要创建类的对象 静态函数的声明和定义方式与普通成员函数相同，只需要在函数前面加上static关键字就行。静态函数可以访问类的静态成员变量和静态成员函数，但是不能访问非静态成员变量和成员函数。 静态函数不能使用关键字this，因为它没有隐含的指向对象 的指针 #include \u003ciostream\u003e class Student { public: Student(char* name,int age,float score); void show(); public: static int getTotal(); static float getPoints(); private: static int m_total; static float m_points; private: char *m_name; int m_age; float m_score; }; int Student::m_total = 0; float Student::m_points = 0.0; Student::Student(char *name,int age,float score): m_name(name),m_age(age),m_score(score){ m_total++; m_points += score; } void Student::show() { std::cout \u003c\u003c m_name \u003c\u003c \" 's age is \" \u003c\u003c m_age \u003c\u003c \", score is \" \u003c\u003c m_score \u003c\u003c std::endl; } //Define static member function float Student::getPoints(){ return m_points; } int Student::getTotal() { return m_total; } int main(){ (new Student(\"xiaoming\",15,90.7))-\u003eshow(); int total = Student::getTotal(); float points = Student::getPoints(); std::cout \u003c\u003c \"now there is \" \u003c\u003c total \u003c\u003c \" students ,their total score is \" \u003c\u003c points \u003c\u003c std::endl; return 0; } ","date":"2024-05-18","objectID":"/posts/ae3b30e/:1:5","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"析构函数\rC++中析构函数是一种特殊的成员函数，用于在对象被销毁时执行清理工作。析构函数的名称和类名相同，但在名称前面加上一个波浪号~ #include \u003ciostream\u003e class MyClass { public: MyClass() { std::cout \u003c\u003c \"Constructor\" \u003c\u003c std::endl; } ~MyClass() { std::cout \u003c\u003c \"Destructor\" \u003c\u003c std::endl; } }; int main() { MyClass obj; return 0; } 析构函数的应用 #include \u003ciostream\u003e class MyClass { public: MyClass() { std::cout \u003c\u003c \"Constructor \" \u003c\u003c std::endl; data = new int[10]; } ~MyClass() { std::cout \u003c\u003c \"DestructorL: data内存已被释放\" \u003c\u003c std::endl; delete[] data; } void insertNum(int x) { if (top \u003e 9) return; data[top++] = x; } void printData() { for (int i = 0; i \u003c= top; i++) { std::cout \u003c\u003c data[i] \u003c\u003c \" \"; } std::cout \u003c\u003c std::endl; } private: int *data; int top = 0; }; int main(void) { MyClass obj; obj.insertNum(1); obj.insertNum(2); obj.insertNum(3); obj.insertNum(4); obj.insertNum(5); obj.insertNum(6); obj.printData(); return 0; } ","date":"2024-05-18","objectID":"/posts/ae3b30e/:1:6","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"C++成员对象和封闭类\r一个类的成员变量如果是另一个类的对象，就称之为“成员对象”。包含成员对象的类叫封闭类（enclosed class） 封闭类对象生成时，先执行所有成员对象的构造函数，然后才执行封闭类自己的构造函数。成员对象构造函数的执行次序和成员对象在类定义中的次序一致，与它们在构造函数初始化列表中出现的次序无关。 当封闭类对象消亡时，先执行封闭类的析构函数，然后再执行成员对象的析构函数，成员对象析构函数的执行次序和构造函数的执行次序相反，即先构造的后析构，这是 C++ 处理此类次序问题的一般规律。 #include\u003ciostream\u003e using namespace std; class Tyre { public: Tyre() { cout \u003c\u003c \"Tyre constructor\" \u003c\u003c endl; } ~Tyre() { cout \u003c\u003c \"Tyre destructor\" \u003c\u003c endl; } }; class Engine { public: Engine() { cout \u003c\u003c \"Engine constructor\" \u003c\u003c endl; } ~Engine() { cout \u003c\u003c \"Engine destructor\" \u003c\u003c endl; } }; class Car { private: Engine engine; Tyre tyre; public: Car() { cout \u003c\u003c \"Car constructor\" \u003c\u003c endl; } ~Car() { cout \u003c\u003c \"Car destructor\" \u003c\u003c endl; } }; int main() { Car car; return 0; } ","date":"2024-05-18","objectID":"/posts/ae3b30e/:1:7","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"Class(2)\r","date":"2024-05-18","objectID":"/posts/ae3b30e/:2:0","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"封装\r定义了一个 Circle 类，包含了数据成员 radius 和成员函数 getRadius()、setRadius() 和 getArea()。其中，getRadius() 和 setRadius() 分别用于获取和设置半径的值，getArea() 用于计算圆的面积。可以看出，radius 数据成员被隐藏在类的私有部分，外部的调用者无法直接访问和修改它，只能通过公共的成员函数进行操作，从而实现了数据的封装。 在 main() 函数中，定义了一个 Circle 对象 c，并通过公共的成员函数获取并修改了半径的值，并计算圆的面积。可以看出，外部调用者只能通过公共的接口来访问和操作数据，无法直接访问和修改私有成员变量，从而保证了数据的安全性和可维护性。 通过封装，C++ 中的类可以将数据和操作数据的方法封装在一起，隐藏实现细节，提高代码的安全性和可维护性。需要注意的是，在设计类的接口时，应该尽可能地隐藏实现细节，只暴露必要的接口，避免外部调用者误操作数据，从而提高程序的健壮性和可靠性。 #include \u003ciostream\u003e class Circle { public: Circle(double r) : radius(r) {} double getRadius() const { return radius; } void setRadius(double r) { radius = r; } double getArea() const { return 3.14 * radius * radius; } private: double radius; }; int main() { Circle c(2.0); std::cout \u003c\u003c \"Radius = \" \u003c\u003c c.getRadius() \u003c\u003c std::endl; std::cout \u003c\u003c \"Area = \" \u003c\u003c c.getArea() \u003c\u003c std::endl; c.setRadius(3.0); std::cout \u003c\u003c \"Radius = \" \u003c\u003c c.getRadius() \u003c\u003c std::endl; std::cout \u003c\u003c \"Area = \" \u003c\u003c c.getArea() \u003c\u003c std::endl; return 0; } ","date":"2024-05-18","objectID":"/posts/ae3b30e/:2:1","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"常函数\u0026常对象\r测试常函数\r不加mutable，编译错误 加上mutable，编译通过 测试常对象\r可见常对象只能调用常函数 ","date":"2024-05-18","objectID":"/posts/ae3b30e/:2:2","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"继承\rC++ 中的继承是面向对象编程中的一个重要概念，它允许通过派生类来扩展基类的功能，从而实现代码的重用和扩展。 #include \u003ciostream\u003e class Animal { public: Animal(const std::string\u0026 _name) : name(_name){}; virtual void speak() const { std::cout \u003c\u003c \"I am an animal.\" \u003c\u003c std::endl; } protected: std::string name; }; class Dog : public Animal { public: Dog(const std::string\u0026 _name,const std::string\u0026 _breed) : Animal(_name),breed(_breed){}; virtual void speak() const { std::cout \u003c\u003c \"Woof! I am a dog.\" \u003c\u003c std::endl; } private: std::string breed; }; class Cat : public Animal { public: Cat(const std::string\u0026 _name,const std::string\u0026 _color) : Animal(_name),color(_color) {}; virtual void speak() const { std::cout \u003c\u003c \"Meow! I am a Cat.\" \u003c\u003c std::endl; } private: std::string color; }; int main(void) { Animal* animals[3]; animals[0] = new Animal(\"Generic Animal\"); animals[1] = new Dog(\"Rover\", \"Golden Retriever\"); animals[2] = new Cat(\"Fluffy\", \"White\"); for (int i = 0; i \u003c 3; ++i) { animals[i]-\u003espeak(); } delete animals[0]; delete animals[1]; delete animals[2]; } 继承中的静态变量\r#include \u003ciostream\u003e class Parent { public: static int staticVar; }; int Parent::staticVar = 10; class Child : public Parent { }; int main() { std::cout \u003c\u003c Parent::staticVar \u003c\u003c std::endl; std::cout \u003c\u003c Child::staticVar \u003c\u003c std::endl; Child::staticVar = 30; std::cout \u003c\u003c Parent::staticVar \u003c\u003c std::endl; std::cout \u003c\u003c Child::staticVar \u003c\u003c std::endl; } 可见静态变量是父类和子类共享的。 关于继承时候加public,private,protected的区别\r在C++中，继承时使用public、private和protected关键字可以控制基类成员对派生类的可访问性。这三个关键字的使用对于派生类中继承的成员的可见性和访问权限有不同的影响。 public继承： 公有继承时使用public关键字，派生类可以继承基类的公有成员和保护成员。基类的公有成员在派生类中仍然是公有的，保护成员在派生类中仍然是保护的。 基类的私有成员对派生类是不可访问的。 class Child : public Parent { // 可以访问 Parent 的公有成员和保护成员 }; private继承： 私有继承时使用private关键字，派生类可以继承基类的公有成员和保护成员，但它们在派生类中都将变为私有成员。 基类的私有成员对派生类是不可访问的。 class Child : private Parent { // 可以访问 Parent 的公有成员和保护成员，但它们在 Child 中都变为私有成员 }; protected继承： 保护继承时使用protected关键字，派生类可以继承基类的公有成员和保护成员，它们在派生类中都将变为保护成员。 基类的私有成员对派生类是不可访问的。 class Child : protected Parent { // 可以访问 Parent 的公有成员和保护成员，但它们在 Child 中都变为保护成员 }; 需要注意的是，上述访问控制关键字只影响派生类对基类成员的访问权限，而不影响基类内部对成员的访问权限。无论使用哪种访问控制关键字，在派生类中都可以访问基类的公有和保护成员，只是它们在派生类中的可见性和外部访问权限会有所不同。 继承时选择合适的访问控制关键字取决于设计需求和继承关系的语义。根据需要，可以选择public、private或protected继承来满足对基类成员的访问要求。 这里我来浅浅介绍一下virtual这个关键字 虚函数 virtual function\r在 C++ 中，virtual 是一个关键字，用于定义虚函数。虚函数是一种特殊的成员函数，它通过动态绑定（dynamic binding）机制来实现多态，允许使用基类指针或引用调用派生类对象的成员函数，从而实现同一函数名在不同对象上具有不同的行为。 在使用 virtual 关键字定义虚函数时，需要注意以下几点： 只有类的成员函数才能被定义为虚函数，而普通的全局函数和静态成员函数不能被定义为虚函数。 虚函数必须在基类中声明，可以在派生类中重新定义，但是必须保持函数名、参数类型和返回类型相同，否则无法实现动态绑定。 基类的析构函数应该声明为虚函数，以保证在使用基类指针或引用删除派生类对象时，能够正确地调用派生类的析构函数。 在上面写继承得时候，就已经体现出了虚函数得作用 ","date":"2024-05-18","objectID":"/posts/ae3b30e/:2:3","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"抽象类\r在 C++ 中，抽象类（Abstract Class）指的是包含至少一个纯虚函数的类，不能直接实例化对象，只能作为基类被继承。纯虚函数是在类中声明但没有定义的虚函数，其语法格式如下： virtual 返回类型 函数名 (参数列表) = 0; 需要注意的是，纯虚函数没有函数体，只是一个声明，其作用是强制派生类实现该函数，从而实现多态。 抽象类一般用于定义接口和规范派生类的行为，其派生类必须实现基类的纯虚函数，否则也会成为抽象类。抽象类不能直接创建对象，但是可以定义指向派生类对象的指针或引用，通过动态绑定实现多态。 需要注意的是，在定义抽象类时，应该将基类的析构函数声明为虚函数，以保证正确释放派生类对象的内存。同时，抽象类的派生类必须实现基类的纯虚函数，否则也会成为抽象类。 ","date":"2024-05-18","objectID":"/posts/ae3b30e/:2:4","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"接口 Interface\r在 C++ 中，接口（Interface）指的是一个抽象类，包含纯虚函数和（或）常量数据成员，没有数据成员和函数实现。接口定义了一组规范，规定了派生类需要实现的函数和数据成员，用于实现类的多态和封装。 接口在 C++ 中通常使用抽象类来定义，其中的纯虚函数和常量数据成员用于描述派生类需要实现的接口规范。派生类必须实现所有的纯虚函数，否则也会成为抽象类。 抽象类和接口的主要区别在于，抽象类可以包含非纯虚函数和数据成员，而接口只能包含纯虚函数和常量数据成员。 使用案例： 在下面的示例中，定义了一个接口 Printable，包含了纯虚函数 print()。然后定义了一个抽象类 Shape，继承了接口 Printable，包含了纯虚函数getArea()。然后定义了两个派生类 Rectangle 和 Circle，分别实现了基类的纯虚函数，并添加了自己的数据成员和成员函数。在主函数中，定义了一个 Printable 类型的数组，分别用基类和派生类对象初始化数组元素。然后使用一个循环来遍历数组，并通过基类指针调用虚函数 print() 和 getArea()，实现了多态的效果。 在这个示例中，Printable 接口规定了 print() 函数，Shape 抽象类继承了 Printable 接口，并规定了 getArea() 函数，Rectangle 和 Circle 派生类分别实现了 Shape 抽象类的 getArea() 和 print() 函数。在主函数中，定义了一个 Printable 类型的数组，包含了 Rectangle 和 Circle 两种类型的对象，并通过循环实现了多态的效果。 #include \u003ciostream\u003e class Printable { public: virtual void print() const = 0; }; class Shape : public Printable { public: virtual double getArea() const = 0; }; class Rectangle : public Shape { public: Rectangle(double w, double h) : width(w), height(h) {} virtual double getArea() const { return width * height; } virtual void print() const { std::cout \u003c\u003c \"Rectangle (\" \u003c\u003c width \u003c\u003c \" x \" \u003c\u003c height \u003c\u003c \")\" \u003c\u003c std::endl; } private: double width; double height; }; class Circle : public Shape { public: Circle(double r) : radius(r) {} virtual double getArea() const { return 3.14 * radius * radius; } virtual void print() const { std::cout \u003c\u003c \"Circle (\" \u003c\u003c radius \u003c\u003c \")\" \u003c\u003c std::endl; } private: double radius; }; int main() { Printable* shapes[2]; shapes[0] = new Rectangle(2.0, 3.0); shapes[1] = new Circle(1.5); for (int i = 0; i \u003c 2; ++i) { shapes[i]-\u003eprint(); std::cout \u003c\u003c \"Area = \" \u003c\u003c dynamic_cast\u003cShape*\u003e(shapes[i])-\u003egetArea() \u003c\u003c std::endl; } delete shapes[0]; delete shapes[1]; return 0; } ","date":"2024-05-18","objectID":"/posts/ae3b30e/:2:5","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"多态\r多态（Polymorphism）是面向对象编程中的一个重要概念，指的是同一函数名在不同对象上具有不同的行为. #include \u003ciostream\u003e class Shape { public: virtual double getArea() const = 0; virtual void print() const = 0; virtual ~Shape(){}; }; class Rectangle : public Shape { public: Rectangle(double w, double h) : width(w), height(h) {} virtual double getArea() const { return width * height; } virtual void print() const { std::cout \u003c\u003c \"Rectangle (\" \u003c\u003c width \u003c\u003c \" x \" \u003c\u003c height \u003c\u003c \")\" \u003c\u003c std::endl; } private: double width; double height; }; class Circle : public Shape { public: Circle(double r) : radius(r) {} virtual double getArea() const { return 3.14 * radius * radius; } virtual void print() const { std::cout \u003c\u003c \"Circle (\" \u003c\u003c radius \u003c\u003c \")\" \u003c\u003c std::endl; } private: double radius; }; int main() { Shape* shapes[2]; shapes[0] = new Rectangle(2.0, 3.0); shapes[1] = new Circle(1.5); for (int i = 0; i \u003c 2; ++i) { shapes[i]-\u003eprint(); std::cout \u003c\u003c \"Area = \" \u003c\u003c shapes[i]-\u003egetArea() \u003c\u003c std::endl; } delete shapes[0]; delete shapes[1]; return 0; } ","date":"2024-05-18","objectID":"/posts/ae3b30e/:2:6","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"重载运算符（overloading operators)\r可重载运算符 为了方便说明，我这里直接拿牛客网的题来说明了，包括重载运算符有什么用 重载加号 #include \u003ciostream\u003e class Number { private: int value; public: Number() :value(0) {} Number(int val):value(val){} int getValue() const { return value; } //成员函数重载运算符 //重载加号运算符 Number operator+(const Number\u0026 num) { Number result; result.value = this-\u003evalue + num.value; return result; } //重载前置加号运算符 Number operator++() { value = value + 1; return *this; } //重载后置加号运算符 Number operator++(int) { Number tmp = *this; ++(*this); return tmp; } }; //全局函数实现运算符重载 Number operator+(Number \u0026num1,int num2) { int num = num1.getValue() + num2; num1 = Number(num); return num1; } int main(void) { Number num(10); Number num2(20); Number num3 = num + num2; //相当于num.operator+(num2); num3++; num3 = num3 + 20; //相当于 operator(num3,20) int val = num3.getValue(); std::cout \u003c\u003c val \u003c\u003c std::endl; } 重载» #include \u003ciostream\u003e class Person { public: std::string name; int age; Person(std::string name, int age); }; Person::Person(std::string name, int age) { this-\u003ename = name; this-\u003eage = age; } std::ostream\u0026 operator\u003c\u003c(std::ostream \u0026out, const Person \u0026p) { out \u003c\u003c \"name: \" \u003c\u003c p.name \u003c\u003c \", age: \" \u003c\u003c p.age; return out; } int main() { Person pe(\"meowrain\", 234); std::cout \u003c\u003c pe \u003c\u003c std::endl; return 0; } 我们前面说过，类的属性应该用private，但是这样的话，我们重载的«就没办法用了，怎么办呢？用友元 #include \u003ciostream\u003e class Person { private: std::string name; int age; friend std::ostream\u0026 operator\u003c\u003c(std::ostream \u0026out,const Person \u0026p); public: Person(std::string name, int age); }; Person::Person(std::string name, int age) { this-\u003ename = name; this-\u003eage = age; } std::ostream\u0026 operator\u003c\u003c(std::ostream \u0026out, const Person \u0026p) { out \u003c\u003c \"name: \" \u003c\u003c p.name \u003c\u003c \", age: \" \u003c\u003c p.age; return out; } int main() { Person pe(\"meowrain\", 234); std::cout \u003c\u003c pe \u003c\u003c std::endl; return 0; } 重载= #include \u003ciostream\u003e class Human { private: int *m_age; public: Human(int age){ m_age = new int(age); } ~Human() { if (m_age != nullptr) { delete m_age; m_age = nullptr; } } Human(const Human\u0026 human) { m_age = new int(*human.m_age); } void getAge(){ std::cout \u003c\u003c *m_age \u003c\u003c std::endl; } Human\u0026 operator=(const Human\u0026 human) { if(this != \u0026human) { delete this-\u003em_age; this-\u003em_age = new int(*human.m_age); } return *this; } }; int main(void) { Human h1(12); Human h2(14); h2 = h1; h1.getAge(); h2.getAge(); } 重载小于号__牛客网 (nowcoder.com) #include \u003ciostream\u003e using namespace std; class Time { public: int hours; // 小时 int minutes; // 分钟 Time() { hours = 0; minutes = 0; } Time(int h, int m) { this-\u003ehours = h; this-\u003eminutes = m; } void show() { cout \u003c\u003c hours \u003c\u003c \" \" \u003c\u003c minutes \u003c\u003c endl; } // write your code here...... bool operator\u003c(Time b){ if(hours \u003e b.hours \u0026\u0026 minutes \u003e b.minutes){ return false; } else if(hours == b.hours \u0026\u0026 minutes == b.minutes) return false; else return true; } }; int main() { int h, m; cin \u003e\u003e h; cin \u003e\u003e m; Time t1(h, m); Time t2(6, 6); if (t1\u003ct2) cout\u003c\u003c\"yes\"; else cout\u003c\u003c\"no\"; return 0; } 加号运算符重载__牛客网 (nowcoder.com) #include \u003ciostream\u003e using namespace std; class Time { public: int hours; // 小时 int minutes; // 分钟 Time() { hours = 0; minutes = 0; } Time(int h, int m) { this-\u003ehours = h; this-\u003eminutes = m; } void show() { cout \u003c\u003c hours \u003c\u003c \" \" \u003c\u003c minutes \u003c\u003c endl; } // write your code here...... Time operator+(Time b) { int sum_hours = hours + b.hours; int sum_minutes = minutes + b.minutes; if (sum_minutes \u003e= 60) { sum_minutes -= 60; sum_hours += 1; } Time sum(sum_hours, sum_minutes); return sum; } }; int main() { int h, m; cin \u003e\u003e h; cin \u003e\u003e m; Time t1(h, m); Time t2(2, 20); Time t3 = t1 + t2; t3.show(); return 0; } 加号运算符重载\r","date":"2024-05-18","objectID":"/posts/ae3b30e/:2:7","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"Copy Constructor\r拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于： 通过使用另一个同类型的对象来初始化新创建的对象。 复制对象把它作为参数传递给函数。 复制对象，并从函数返回这个对象。 如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。拷贝构造函数的最常见形式如下： classname (const classname \u0026obj) { // 构造函数的主体 } #include \u003ciostream\u003e using namespace std; class Person { public: string name; int age; Person() { name = \"meow\"; age = 10; } Person(string _name,int _age) { name = _name; age = _age; } Person(const Person\u0026 other) { name = other.name; age = other.age; } void getInfo() { cout \u003c\u003c name \u003c\u003c \" \" \u003c\u003c age \u003c\u003c \" \" \u003c\u003c endl; } }; int main() { Person p(\"mew\",19); Person p1 = p; Person p2(p); p.getInfo(); p1.getInfo(); p2.getInfo(); return 0; } p1 是通过使用赋值语句来初始化的，即 Person p1 = p;。这实际上是一种隐式的赋值操作，编译器会使用 copy constructor 来创建 p1 对象，并将 p 对象的值复制到 p1 对象中。 而 p2 是通过直接调用 copy constructor 来初始化的，即 Person p2(p);。这是一种显式调用 copy constructor 的方法，它直接使用现有对象 p 来创建新对象 p2，不需要使用赋值语句。 ","date":"2024-05-18","objectID":"/posts/ae3b30e/:2:8","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"Copy assignment(复制赋值操作符)\r是 C++中的一个运算符，用于将一个对象的值复制到另一个对象中。它通常用于将一个已经存在的对象的值赋给另一个已经存在的对象，从而使它们具有相同的值。 语法格式： classname\u0026 operator=(const classname\u0026 other) 默认情况下，C++会提供一个浅复制的 copy assignment 运算符 看一个例子： #include \u003ciostream\u003e #include \u003cstring\u003e class Person { public: std::string name; int age; Person() { name = \"meo\"; age = 12; } Person(std::string _name, int _age) : name(_name), age(_age) { } // copy constructor Person(const Person \u0026other) { name = other.name; age = other.age; } // copy assignment Person \u0026operator=(const Person \u0026other) { name = other.name; age = other.age; return *this; } }; int main(void) { Person p1(\"meow\", 12); Person p2; p2 = p1; std::cout \u003c\u003c \"p1.name \" \u003c\u003c p1.name \u003c\u003c \" age: \" \u003c\u003c p1.age \u003c\u003c std::endl; std::cout \u003c\u003c \"p2.name \" \u003c\u003c p2.name \u003c\u003c \" age: \" \u003c\u003c p2.age \u003c\u003c std::endl; return 0; } 浅复制是指简单地将现有对象的成员变量的值复制到新对象中。如果成员变量是基本类型，那么浅复制是没有问题的，因为它们只是简单的值。但是，如果成员变量是指针，浅复制可能会导致问题。在这种情况下，浅复制只会复制指针本身，而不会复制指针指向的数据。这意味着新对象和现有对象将共享同一块数据，这可能会导致内存泄漏或数据损坏。 深复制是指将现有对象的成员变量的值复制到新对象中，并复制指针指向的数据。这意味着新对象将有自己的数据副本，与现有对象完全独立。这通常需要手动实现，因为 C++默认提供的复制构造函数和赋值运算符只会执行浅复制。 ","date":"2024-05-18","objectID":"/posts/ae3b30e/:2:9","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"友元\r友元是一种特殊的访问权限，允许一个函数或类访问另一个类的私有或受保护成员。 友元有三种： 友元函数 友元类 友元成员函数 友元函数\r创建友元函数得第一步 hi 把原型放在类声明中，在原型声明前面加上 friend 需要注意的是，友元函数并不是 MyClass 的成员函数，它是一个独立的函数，只是被声明为 MyClass 的友元函数。 #include \u003ciostream\u003e class Person { private: std::string name; int age; public: Person(std::string _name,int _age) : name(_name),age(_age){} friend void printValue(Person \u0026p) { std::cout \u003c\u003c \"Person name: \" \u003c\u003c p.name \u003c\u003c \"\\t\" \u003c\u003c \"Person age: \" \u003c\u003c p.age \u003c\u003c std::endl; } /* 在友元函数中，我们能访问Person类的私有成员变量 */ }; int main(void) { Person p(\"meow\",18); printValue(p); //友元函数不是类Person的成员函数 return 0; } 友元类\r友元类是指一个类可以访问另一个类的私有成员，这使得它们之间的关系更加密切。 例子： #include \u003ciostream\u003e class Me { private: std::string name; int age; protected: std::string hobby; public: Me(){ name = \"meowrain\"; age = 20; hobby = \"playing computer\"; } void playGames(){ std::cout \u003c\u003c \"I'm playing games\" \u003c\u003c std::endl; } friend class MyFriend; }; class MyFriend { private: std::string name; int age; public: MyFriend(){ name = \"meow\"; age = 2; } void eat(){ std::cout \u003c\u003c name \u003c\u003c \" is eating !\" \u003c\u003c std::endl; } void play(Me\u0026 me){ std::cout \u003c\u003c name \u003c\u003c \" is playing with \" \u003c\u003c me.name \u003c\u003c std::endl; std::cout \u003c\u003c \"while \" \u003c\u003c me.name \u003c\u003c \" is \" \u003c\u003c me.hobby \u003c\u003c std::endl; } }; int main(void) { Me me; MyFriend my_friend; my_friend.play(me); return 0; } 友元成员函数\rfriend void Me::getFriendGirlFriend(MyFriend\u0026 my_friend);重点在这句代码，必须在那个类里面添加友元成员函数才可以保证需要用这个类的私有属性的类的成员函数能用到这个需要用的类的私有属性 在 Me 类中声明了一个友元成员函数 getFriendGirlFriend，而为了让这个成员函数能够访问 MyFriend 类的私有属性，需要在 MyFriend 类中进行友元函数的声明。 #include \u003ciostream\u003e class MyFriend; class Me { private: std::string girlFriend; public: std::string name; int age; public: Me(); void play() const; void getFriendGirlFriend(MyFriend\u0026 my_friend); }; class MyFriend { private: std::string girlFriend; friend void Me::getFriendGirlFriend(MyFriend\u0026 my_friend); public: std::string name; int age; public: MyFriend(); }; MyFriend::MyFriend() { name = \"jack chan\"; age = 20; girlFriend = \"洛天依\"; }; Me::Me() { name = \"meowrain\"; age = 20; girlFriend = \"miku\"; }; void Me::play() const { std::cout \u003c\u003c name \u003c\u003c \" is playing\" \u003c\u003c std::endl; } void Me::getFriendGirlFriend(MyFriend\u0026 my_friend) { std::cout \u003c\u003c \"My Friend's girl friend is \" \u003c\u003c my_friend.girlFriend \u003c\u003c std::endl; } int main(void) { Me me; MyFriend myFriend; me.getFriendGirlFriend(myFriend); } ","date":"2024-05-18","objectID":"/posts/ae3b30e/:2:10","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"转换函数\r在 C++ 中，转换函数（conversion function）是一种特殊的成员函数，用于将一个对象转换为另一个类型的对象。转换函数可以将一个类对象转换为基本数据类型或另一个用户自定义类型的对象，或者将一个类对象转换为指向类对象的指针或引用。转换函数允许程序员在类中定义自己的类型转换规则，从而增强类的灵活性和可扩展性。 转换函数的命名规则与构造函数和成员函数相同，使用类名作为函数名，并在函数名称前面加上要转换的类型的名称。转换函数可以具有任何返回类型，但不能具有任何参数。转换函数可以被显式调用，也可以在需要时自动调用。 #include \u003ciostream\u003e //转换函数 class MyInt { private: int data; public: explicit MyInt(int n = 0) : data(n) { } operator int() const { return data; } }; int main(void) { MyInt a(10); int b = a; //调用转换函数把MyInt对象转换成int类型 using std::cout; using std::endl; cout \u003c\u003c b \u003c\u003c endl; return 0; } #include \u003ciostream\u003e class Feet { private: int feet; public: Feet(int n = 0): feet(n) {}; int getFeet() const { return feet; } }; class Meters { public: Meters(double m = 0.0) : meters(m) {} Meters(const Feet\u0026 f) : meters(f.getFeet() * 0.3048) {} //转换函数，把Feet对象转换为Meters对象 double getMeters() const { return meters; } private: double meters; }; int main(void) { Feet f(10); Meters m = f; using std::cout,std::endl; cout \u003c\u003c m.getMeters() \u003c\u003c endl; return 0; } ","date":"2024-05-18","objectID":"/posts/ae3b30e/:2:11","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"explicit关键字\r在C++中，构造函数的调用方式分为显式调用和隐式调用。 ","date":"2024-05-18","objectID":"/posts/ae3b30e/:3:0","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"显式调用构造函数：\r直接调用： 构造函数可以通过类名和参数列表直接调用来创建对象。 class MyClass { public: MyClass(int x) { /* ... */ } }; int main() { MyClass obj1(10); // 直接调用构造函数创建对象 MyClass obj2 = MyClass(20); // 通过构造函数显式创建对象 return 0; } 使用 new 运算符： 在堆内存上分配对象时，可以使用 new 运算符显式调用构造函数。 MyClass* ptr = new MyClass(30); // 在堆上分配内存并调用构造函数创建对象 ","date":"2024-05-18","objectID":"/posts/ae3b30e/:3:1","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"隐式调用构造函数：\r使用 = 进行赋值： 当使用 = 进行对象初始化或赋值时，会隐式地调用构造函数。 MyClass obj = 40; // 隐式调用构造函数将整数转换为 MyClass 对象 函数调用时的参数传递： 当函数需要参数并且传递的参数类型与函数参数不匹配时，会隐式调用构造函数来执行类型转换。 void func(MyClass obj) { /* ... */ } int main() { func(50); // 隐式调用构造函数将整数转换为 MyClass 对象并传递给 func 函数 return 0; } explicit 关键字可以防止构造函数的隐式调用，只有在需要时才能显式地调用构造函数。这可以避免一些意外的类型转换和可能导致错误的行为。 在 C++ 中，explicit 是一个关键字，通常用于防止编译器执行隐式类型转换。它可以应用于单参数构造函数或转换运算符。主要作用有两点： 禁止隐式转换： 当一个构造函数被声明为 explicit 时，它不再能够隐式地将其参数转换为所需的类类型。这样可以防止意外的类型转换，避免意想不到的行为。 class MyClass { public: explicit MyClass(int x) { /* ... */ } }; void func(const MyClass\u0026 obj) { /* ... */ } int main() { // MyClass obj = 10; // 这里会导致编译错误，因为构造函数是 explicit 的 MyClass obj(10); // 必须显式调用构造函数 func(10); // 这里也会导致编译错误，因为构造函数是 explicit 的 func(MyClass(10)); // 必须显式地创建 MyClass 对象 return 0; } 明确表达意图： 使用 explicit 关键字可以使代码更加清晰明了，明确地表达出了构造函数或转换运算符不会进行隐式转换，需要显式地进行调用或转换。 当你希望避免隐式类型转换，或者想要更明确地表达构造函数的使用方式时，可以考虑使用 explicit 关键字。这在设计类时特别有用，可以避免一些潜在的错误或者意外行为。 ","date":"2024-05-18","objectID":"/posts/ae3b30e/:3:2","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["Go"],"content":" https://courses.calhoun.io/courses/cor_gophercises 1. Quiz\rhttps://github.com/gophercises/quiz 第一部分： 编写一个程序，该程序能够读取通过CSV文件提供的测验（详细信息如下），并向用户展示此测验。程序需记录用户答对和答错的题目数量。无论答案正确与否，都应立即提出下一题。 默认情况下，CSV文件名为problems.csv，但用户应能通过标志自定义文件名。 CSV文件的格式如下：第一列是问题，同一行的第二列则是该问题的答案。 你可以假设测验相对较短（少于100题），且答案为单个词或数字。 测验结束时，程序应输出答对的问题总数和总问题数。对于给出无效答案的问题，视为回答错误。 第二部分： 根据第一部分的要求调整你的程序以添加计时器功能。默认时间限制应为30秒，但也可通过标志进行自定义设置。 一旦超过时间限制，测验应立即停止。也就是说，不应等待用户回答最后一个问题，而应在理想情况下完全停止测验，即使当时正在等待用户的答案也应如此处理。 在计时开始前，应提示用户按下回车键（或其他键）启动计时器；然后题目应逐一出示在屏幕上直至用户提供答案为止。无论答案正确与否都将继续下一题的提问过程直到全部完成测试内容为止！最后依然需要统计出本次答题过程中总共答对了多少道题目以及一共出现了多少道题目信息并展示给参与者查看结果情况哦~同时也要注意那些没有被有效解答过的或者是根本就没有来得及去作答的部分也都算作是错误的哟！ package main import ( \"context\" \"encoding/csv\" \"flag\" \"fmt\" \"log\" \"os\" \"strconv\" \"time\" ) func CommandLine() (string, int) { csvFileName := flag.String(\"csv\", \"problems.csv\", \"put the filename after this\") limitValue := flag.Int(\"limit\", 4, \"the time limit for the quiz in seconds\") flag.Parse() return *csvFileName, *limitValue } func main() { csvFileName, timeLimit := CommandLine() ctx, cancel := context.WithTimeout(context.Background(), time.Duration(timeLimit)*time.Second) defer cancel() file, err := os.Open(csvFileName) if err != nil { log.Fatalf(\"Error opening file: %v\", err) } defer file.Close() reader := csv.NewReader(file) lines, err := reader.ReadAll() if err != nil { log.Fatalf(\"Error reading CSV: %v\", err) } var correct, incorrect int for idx, line := range lines { select { case \u003c-ctx.Done(): fmt.Println(\"\\nTime's up!\") printResults(correct, incorrect) return default: formula := line[0] answerChan := make(chan int) go func() { var result int fmt.Printf(\"Question:%d/%d\\tFormula: %v = \", idx+1, len(lines), formula) fmt.Scanln(\u0026result) answerChan \u003c- result }() answer, err := strconv.Atoi(line[1]) if err != nil { log.Fatalf(\"Invalid answer in CSV: %v\", err) } select { case \u003c-ctx.Done(): fmt.Println(\"\\nTime's up!\") printResults(correct, incorrect) return case result := \u003c-answerChan: if result == answer { correct++ } else { incorrect++ } } } } printResults(correct, incorrect) } func printResults(correct, incorrect int) { fmt.Printf(\"\\nYou got %d correct and %d incorrect.\\n\", correct, incorrect) } ","date":"2024-05-18","objectID":"/posts/33dc7d7/:0:0","tags":["Go-exercises","Go"],"title":"Go Gophercises","uri":"/posts/33dc7d7/"},{"categories":["Go"],"content":"就是一直刷新当前行 package main import ( \"fmt\" \"time\" ) func main() { // 模拟一些操作，比如循环计数 for i := 0; i \u003c= 100; i++ { // 返回到行首 fmt.Print(\"\\r\") // 输出其他内容 fmt.Printf(\"Prefix: \") // 输出进度 fmt.Printf(\"Progress: %d%%\", i) // 强制刷新输出缓冲区 fmt.Print(\"\\033[0m\") // 重置 ANSI 颜色，防止影响后续输出 time.Sleep(100 * time.Millisecond) } fmt.Println(\"\\nDone!\") // 完成后换行 } ","date":"2024-05-18","objectID":"/posts/fc29587/:0:0","tags":["Go"],"title":"Go语言打印进度","uri":"/posts/fc29587/"},{"categories":["Go"],"content":"panic,recover\r在 Go 语言中，panic 和 recover 是用于处理程序错误和恢复的两个关键机制。 panic： panic 是一个内建函数，用于表示程序发生了无法处理的错误。当发生 panic 时，程序会立即停止执行当前函数的剩余代码，并开始在调用栈中向上逐层执行 deferred 函数，直到达到当前协程的最顶层（即程序的入口函数），然后程序将终止并输出 panic 信息。 panic 通常用于表示不可恢复的错误，比如空指针引用、数组越界等，或者是程序运行过程中的一些不合法操作。 recover： recover 也是一个内建函数，用于在 defer 延迟执行的函数中捕获 panic 引起的错误，使程序能够继续执行而不会被终止。 recover 只能在 defer 中调用，并且只在发生 panic 时才会生效。如果在没有 panic 的情况下调用 recover，它将返回 nil。 当 recover 在 defer 中调用时，如果有 panic 发生，它将会返回被传递给 panic 的值，并且程序将继续执行而不会终止。 package main import ( \"fmt\" ) func recoverFromPanic() { if r := recover(); r != nil { fmt.Println(\"Recovered from panic:\", r) } } func divide(a, b int) int { // defer语句用于注册在当前函数返回时调用的函数 defer recoverFromPanic() if b == 0 { panic(\"Cannot divide by zero!\") } return a / b } func processDivision(x, y int) { result := divide(x, y) fmt.Println(\"Result of division:\", result) } func main() { // Case 1: Valid division processDivision(10, 2) // Case 2: Division by zero processDivision(10, 0) fmt.Println(\"Program continues after division.\") } ","date":"2024-05-18","objectID":"/posts/8a369fa/:0:0","tags":["Go","Go错误处理"],"title":"Go 错误处理","uri":"/posts/8a369fa/"},{"categories":["Go"],"content":"介绍\rGo的gob是Go语言标准库中的一种序列化/反序列化格式，主要用于在编码和解码时传输和存储Go数据结构。Gob格式专为Go语言设计，提供了一种高效的二进制编码方式，特别适合在网络通信和文件存储中使用。 以下是Go的gob包的一些关键特性和使用方法： 特性 高效的二进制编码：Gob格式比JSON和XML等文本格式更为紧凑和高效，因为它使用二进制表示数据。 面向Go语言：Gob格式支持Go语言中的复杂数据结构，包括嵌套结构、切片、映射等。 自动化的编码和解码：使用gob包可以自动处理编码和解码过程，无需手动序列化和反序列化。 例子\rpackage main import ( \"bytes\" \"encoding/gob\" \"fmt\" \"log\" \"os\" ) type Person struct { Name string Age int } func main() { // 创建一个Person实例 person := Person{Name: \"Alice\", Age: 30} // 创建一个缓冲区来存储编码后的数据 var buf bytes.Buffer // 创建一个新的编码器并对缓冲区进行编码 encoder := gob.NewEncoder(\u0026buf) err := encoder.Encode(person) if err != nil { fmt.Println(\"编码错误:\", err) } // 打印编码后的数据 fmt.Println(\"编码后的数据:\", buf.Bytes()) // 把编码后的数据写入文件中 file, err := os.OpenFile(\"data.gob\", os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0666) if err != nil { log.Fatal(\"打开文件错误:\", err) } defer file.Close() // 确保文件在程序结束时关闭 encoder2 := gob.NewEncoder(file) err = encoder2.Encode(person) if err != nil { log.Fatal(\"编码错误:\", err) } // 解码 file2, err := os.Open(\"data.gob\") if err != nil { log.Fatal(\"打开文件错误:\", err) } defer file2.Close() // 确保文件在程序结束时关闭 decoder2 := gob.NewDecoder(file2) var person2 Person err = decoder2.Decode(\u0026person2) if err != nil { log.Fatal(\"解码错误:\", err) } // 打印解码后的数据 fmt.Println(\"解码后的数据:\", person2) // 将解码后的数据写入 \"test.txt\" 文件 file3, err := os.OpenFile(\"test.txt\", os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0666) if err != nil { log.Fatal(\"打开文件错误:\", err) } defer file3.Close() // 确保文件在程序结束时关闭 _, err = fmt.Fprintf(file3, \"Name: %s, Age: %d\\n\", person2.Name, person2.Age) if err != nil { log.Fatal(\"写入文件错误:\", err) } } 代码解释 创建和编码Person实例：创建 Person 实例并编码成字节缓冲区。 打印编码后的数据：打印编码后的数据字节切片（注意：这是二进制数据，不是人类可读的格式）。 将编码数据写入文件：将编码后的数据写入 “data.gob” 文件。 解码数据：从 “data.gob” 文件中读取数据并解码回 Person 实例。 打印解码后的数据：打印解码后的 Person 实例数据。 写入解码数据到test.txt：将解码后的 Person 实例数据写入 “test.txt” 文件，以人类可读的格式输出。 ","date":"2024-05-18","objectID":"/posts/a47021b/:0:0","tags":["Go"],"title":"Go Gob","uri":"/posts/a47021b/"},{"categories":["Go"],"content":" vcard.go package vcard import ( \"time\" ) type Address struct { Street string HouseNumber uint32 HouseNumberAddOn string POBox string ZipCode string City string Country string } type VCard struct { FirstName string LastName string NickName string BirtDate time.Time Photo string Addresses map[string]*Address } jsonUtil.go package utils import ( \"encoding/json\" ) func ToJson(data any) string { js, _ := json.Marshal(data) return string(js) } main.go package main import ( . \"awesomeProject/utils\" . \"awesomeProject/vcard\" \"encoding/json\" \"fmt\" \"os\" \"time\" ) func main() { pa := \u0026Address{Street: \"private\", HouseNumber: 10086, HouseNumberAddOn: \"Belgium\"} wa := \u0026Address{Street: \"work\", HouseNumber: 10008611, HouseNumberAddOn: \"Belgium\"} vc := VCard{FirstName: \"Jan\", LastName: \"Kersschot\", NickName: \"Mike\", BirtDate: time.Date(1956, 1, 17, 15, 4, 5, 0, time.Local)} str := ToJson(vc) fmt.Println(str) str = ToJson(wa) fmt.Println(str) str = ToJson(pa) fmt.Println(str) //写入到vcard.json文件 file, err := os.Create(\"vcard.json\") if err != nil { fmt.Println(err) return } defer file.Close() encoder := json.NewEncoder(file) err = encoder.Encode(vc) if err != nil { return } fmt.Println(\"vcard.json created\") //读取vcard.json文件 file, err = os.Open(\"vcard.json\") if err != nil { fmt.Println(err) return } defer file.Close() decoder := json.NewDecoder(file) var vcard VCard err = decoder.Decode(\u0026vcard) if err != nil { return } fmt.Println(vcard) } 出于安全考虑，在 web 应用中最好使用 json.MarshalforHTML() 函数，其对数据执行HTML转码，所以文本可以被安全地嵌在 HTML\u003cscript\u003e标签中。 json.NewEncoder() 的函数签名是 func NewEncoder(w io.Writer) *Encoder，返回的Encoder类型的指针可调用方法 Encode(v interface{})，将数据对象 v 的json编码写入 io.Writer w 中。 ","date":"2024-05-18","objectID":"/posts/35b4611/:0:0","tags":["json编码解码"],"title":"Go Json解码和编码","uri":"/posts/35b4611/"},{"categories":["Go"],"content":"下面的代码有一个输入文件 goprogram，然后以每一行为单位读取，从读取的当前行中截取第 3 到第 5 的字节写入另一个文件。然而当你运行这个程序，输出的文件却是个空文件。找出程序逻辑中的 bug，修正它并测试。 package main import ( \"bufio\" \"fmt\" \"os\" \"io\" ) func main() { inputFile, _ := os.Open(\"goprogram\") outputFile, _ := os.OpenFile(\"goprogramT\", os.O_WRONLY|os.O_CREATE, 0666) defer inputFile.Close() defer outputFile.Close() inputReader := bufio.NewReader(inputFile) outputWriter := bufio.NewWriter(outputFile) for { inputString, _, readerError := inputReader.ReadLine() if readerError == io.EOF { fmt.Println(\"EOF\") return } outputString := string(inputString[2:5]) + \"\\r\\n\" _, err := outputWriter.WriteString(outputString) if err != nil { fmt.Println(err) return } } fmt.Println(\"Conversion done\") } 上面的代码为什么会什么都没有写入呢？其实是因为outputWriter没有Flush，必须进行Flush以后，才能把缓冲区清空，把内容写入到对应文件中 package main import ( \"bufio\" \"fmt\" \"io\" \"os\" ) func main() { inputFile, _ := os.Open(\"goprogram\") outputFile, _ := os.OpenFile(\"goprogramT\", os.O_WRONLY|os.O_CREATE, 0666) defer inputFile.Close() defer outputFile.Close() inputReader := bufio.NewReader(inputFile) outputWriter := bufio.NewWriter(outputFile) defer outputWriter.Flush() for { inputString, _, readerError := inputReader.ReadLine() if readerError == io.EOF { fmt.Println(\"EOF\") return } outputString := string(inputString[2:5]) + \"\\r\\n\" _, err := outputWriter.WriteString(outputString) if err != nil { fmt.Println(err) return } } fmt.Println(\"Conversion done\") } ","date":"2024-05-18","objectID":"/posts/ad3706c/:0:0","tags":["Go缓冲区"],"title":"Go缓冲区例题","uri":"/posts/ad3706c/"},{"categories":null,"content":"meowrain's friends","date":"2024-05-18","objectID":"/friends/","tags":null,"title":"Index","uri":"/friends/"},{"categories":null,"content":"\r","date":"2024-05-18","objectID":"/friends/:0:0","tags":null,"title":"Index","uri":"/friends/"},{"categories":null,"content":"Base info\r- nickname: Lruihao avatar: https://lruihao.cn/images/avatar.jpg url: https://lruihao.cn description: Lruihao's Note ","date":"2024-05-18","objectID":"/friends/:1:0","tags":null,"title":"Index","uri":"/friends/"},{"categories":null,"content":"Friendly Reminder\rNotice\rIf you want to exchange link, please leave a comment in the above format. (personal non-commercial blogs / websites only)  Website failure, stop maintenance and improper content may be unlinked! Those websites that do not respect other people’s labor achievements, reprint without source, or malicious acts, please do not come to exchange. ","date":"2024-05-18","objectID":"/friends/:2:0","tags":null,"title":"Index","uri":"/friends/"},{"categories":["设计模式"],"content":"[TOC] 面向对象相关知识\r面向对象类关系(继承、实现、依赖、关联、聚合、组合)：https://www.cnblogs.com/zhongj/p/11169780.html UML: https://blog.csdn.net/quyingzhe0217/article/details/133683814 创建型模式\r创建型设计模式包括以下几种常见的模式： 工厂模式（Factory Pattern）：通过工厂方法或抽象工厂来创建对象，将对象的创建过程封装起来，使得客户端代码与具体类解耦。 抽象工厂模式（Abstract Factory Pattern）：提供一个接口，用于创建相关或依赖对象的家族，而不需要指定具体类。 单例模式（Singleton Pattern）：确保一个类只有一个实例，并提供一个全局访问点来访问该实例。 建造者模式（Builder Pattern）：将一个复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。 原型模式（Prototype Pattern）：通过复制现有对象来创建新对象，而不是通过实例化来创建。 结构型模式\r结构型设计模式主要包括以下几种常见的模式： 适配器模式（Adapter Pattern）：将一个类的接口转换成客户端所期望的另一个接口，使得原本不兼容的类可以一起工作。 桥接模式（Bridge Pattern）：将抽象部分与实现部分分离，使它们可以独立地变化，从而提高系统的灵活性。 组合模式（Composite Pattern）：将对象组合成树形结构，以表示“部分-整体”的层次结构，使得客户端可以统一地处理单个对象和组合对象。 装饰器模式（Decorator Pattern）：动态地给对象添加额外的职责，同时又不改变其接口。 外观模式（Facade Pattern）：提供一个统一的接口，用于访问子系统中的一组接口，从而简化客户端与子系统之间的交互。 享元模式（Flyweight Pattern）：通过共享细粒度的对象，以减少内存使用和提高性能。 代理模式（Proxy Pattern）：为其他对象提供一个代理，以控制对这个对象的访问。 行为模式\r行为型设计模式主要包括以下几种常见的模式： 观察者模式（Observer Pattern）：定义了一种一对多的依赖关系，使得多个观察者对象可以同时监听并收到被观察者对象的通知。 策略模式（Strategy Pattern）：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，从而使算法的变化独立于使用算法的客户端。 命令模式（Command Pattern）：将请求封装成对象，以使得可以用不同的请求对客户端进行参数化，同时支持请求的排队、记录和撤销。 迭代器模式（Iterator Pattern）：提供一种顺序访问聚合对象中各个元素的方法，而又不暴露该对象的内部表示。 状态模式（State Pattern）：允许对象在内部状态发生改变时改变其行为，使对象看起来像是修改了其类。 责任链模式（Chain of Responsibility Pattern）：将请求的发送者和接收者解耦，使多个对象都有机会处理请求，从而避免请求的发送者与接收者之间的耦合关系。 访问者模式（Visitor Pattern）：在不改变被访问类的前提下，定义了一种新的访问操作，使得可以在不修改被访问类的情况下对其进行操作。 中介者模式（Mediator Pattern）：定义了一个中介对象，封装了一组对象之间的交互方式，使其能够独立地改变交互方式。 备忘录模式（Memento Pattern）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可以在以后恢复到这个状态。 解释器模式（Interpreter Pattern）：给定一个语言，定义它的文法的一种表示，并定义一个解释器，用于解释语言中的句子。 ","date":"2024-05-15","objectID":"/posts/a44e805/:0:0","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["设计模式"],"content":"工厂方法模式 factory_method\r工厂方法模式是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。 问题： 假设你正在开发一款物流管理应用。 最初版本只能处理卡车运输， 因此大部分代码都在位于名为 卡车的类中。 一段时间后， 这款应用变得极受欢迎。 你每天都能收到十几次来自海运公司的请求， 希望应用能够支持海上物流功能。 这可是个好消息。 但是代码问题该如何处理呢？ 目前， 大部分代码都与 卡车类相关。 在程序中添加 轮船类需要修改全部代码。 更糟糕的是， 如果你以后需要在程序中支持另外一种运输方式， 很可能需要再次对这些代码进行大幅修改。 最后， 你将不得不编写繁复的代码， 根据不同的运输对象类， 在应用中进行不同的处理。 解决方案： 乍看之下， 这种更改可能毫无意义： 我们只是改变了程序中调用构造函数的位置而已。 但是， 仔细想一下， 现在你可以在子类中重写工厂方法， 从而改变其创建产品的类型。 但有一点需要注意:仅当这些产品具有共同的基类或者接口时， 子类才能返回不同类型的产品， 同时基类中的工厂方法还应将其返回类型声明为这一共有接口。 举例来说， 卡车Truck和 轮船Ship类都必须实现 运输Transport接口， 该接口声明了一个名为 deliver交付的方法。 每个类都将以不同的方式实现该方法： 卡车走陆路交付货物， 轮船走海路交付货物。 陆路运输RoadLogistics类中的工厂方法返回卡车对象， 而 海路运输SeaLogistics类则返回轮船对象。 调用工厂方法的代码 （通常被称为客户端代码） 无需了解不同子类返回实际对象之间的差别。 客户端将所有产品视为抽象的 运输 。 客户端知道所有运输对象都提供 交付方法， 但是并不关心其具体实现方式。 以上的实现已经写在factory_method文件夹里面了 Logistics相当于下面的Creator,RoadLogistic和SeaLogistic相当于ConcreteCreatorA和ConcreteCreatorB Transport相当于Product接口，下面的Ship和Truck是实现这个接口的实体类 ","date":"2024-05-15","objectID":"/posts/a44e805/:1:0","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["设计模式"],"content":"工厂方法应用场景：\r当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。 工厂方法将创建产品的代码与实际使用产品的代码分离， 从而能在不影响其他代码的情况下扩展产品创建部分代码。 例如， 如果需要向应用中添加一种新产品， 你只需要开发新的创建者子类， 然后重写其工厂方法即可。 就像上面我们写的运输货物的例子一样，假如现在多出个飞机运输，我们只需要创建一个AirPlane类，然后让它implements Transport接口，实现其中的transport函数就可以了 同时需要创建一个FlightLogistic，继承Logistics抽象类，然后重写就可以 如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法。 继承可能是扩展软件库或框架默认行为的最简单方法。 但是当你使用子类替代标准组件时， 框架如何辨识出该子类？ 解决方案是将各框架中构造组件的代码集中到单个工厂方法中， 并在继承该组件之外允许任何人对该方法进行重写。 让我们看看具体是如何实现的。 假设你使用开源 UI 框架编写自己的应用。 你希望在应用中使用圆形按钮， 但是原框架仅支持矩形按钮。 你可以使用 圆形按钮RoundButton子类来继承标准的 按钮Button类。 但是， 你需要告诉 UI框架UIFramework类使用新的子类按钮代替默认按钮。 为了实现这个功能， 你可以根据基础框架类开发子类 圆形按钮 UIUIWithRoundButtons ， 并且重写其 createButton创建按钮方法。 基类中的该方法返回 按钮对象， 而你开发的子类返回 圆形按钮对象。 现在， 你就可以使用 圆形按钮 UI类代替 UI框架类。 就是这么简单！ 如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。 在处理大型资源密集型对象 （比如数据库连接、 文件系统和网络资源） 时， 你会经常碰到这种资源需求。 让我们思考复用现有对象的方法： 首先， 你需要创建存储空间来存放所有已经创建的对象。\r当他人请求一个对象时， 程序将在对象池中搜索可用对象。\r… 然后将其返回给客户端代码。\r如果没有可用对象， 程序则创建一个新对象 （并将其添加到对象池中）。\r这些代码可不少！ 而且它们必须位于同一处， 这样才能确保重复代码不会污染程序。 可能最显而易见， 也是最方便的方式， 就是将这些代码放置在我们试图重用的对象类的构造函数中。 但是从定义上来讲， 构造函数始终返回的是新对象， 其无法返回现有实例。 因此， 你需要有一个既能够创建新对象， 又可以重用现有对象的普通方法。 这听上去和工厂方法非常相像。 ","date":"2024-05-15","objectID":"/posts/a44e805/:1:1","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["设计模式"],"content":"优缺点\r","date":"2024-05-15","objectID":"/posts/a44e805/:1:2","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["设计模式"],"content":"生成器模式\rhttps://refactoringguru.cn/design-patterns/builder 生成器模式是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。 问题 假设有这样一个复杂对象， 在对其进行构造时需要对诸多成员变量和嵌套对象进行繁复的初始化工作。 这些初始化代码通常深藏于一个包含众多参数且让人基本看不懂的构造函数中； 甚至还有更糟糕的情况， 那就是这些代码散落在客户端代码的多个位置。 如果为每种可能的对象都创建一个子类， 这可能会导致程序变得过于复杂。 例如， 我们来思考如何创建一个 房屋House对象。 建造一栋简单的房屋， 首先你需要建造四面墙和地板， 安装房门和一套窗户， 然后再建造一个屋顶。 但是如果你想要一栋更宽敞更明亮的房屋， 还要有院子和其他设施 （例如暖气、 排水和供电设备）， 那又该怎么办呢？ 最简单的方法是扩展 房屋基类， 然后创建一系列涵盖所有参数组合的子类。 但最终你将面对相当数量的子类。 任何新增的参数 （例如门廊类型） 都会让这个层次结构更加复杂。 另一种方法则无需生成子类。 你可以在 房屋基类中创建一个包括所有可能参数的超级构造函数， 并用它来控制房屋对象。 这种方法确实可以避免生成子类， 但它却会造成另外一个问题。 拥有大量输入参数的构造函数也有缺陷： 这些参数也不是每次都要全部用上的。 通常情况下， 绝大部分的参数都没有使用， 这使得对于构造函数的调用十分不简洁。 例如， 只有很少的房子有游泳池， 因此与游泳池相关的参数十之八九是毫无用处的。 解决方案： 生成器模式建议将对象构造代码从产品类中抽取出来， 并将其放在一个名为生成器的独立对象中。 该模式会将对象构造过程划分为一组步骤， 比如 buildWalls创建墙壁和 buildDoor创建房门创建房门等。 每次创建对象时， 你都需要通过生成器对象执行一系列步骤。 重点在于你无需调用所有步骤， 而只需调用创建特定对象配置所需的那些步骤即可。 当你需要创建不同形式的产品时， 其中的一些构造步骤可能需要不同的实现。 例如， 木屋的房门可能需要使用木头制造， 而城堡的房门则必须使用石头制造。 在这种情况下， 你可以创建多个不同的生成器， 用不同方式实现一组相同的创建步骤。 然后你就可以在创建过程中使用这些生成器 （例如按顺序调用多个构造步骤） 来生成不同类型的对象。 例如， 假设第一个建造者使用木头和玻璃制造房屋， 第二个建造者使用石头和钢铁， 而第三个建造者使用黄金和钻石。 在调用同一组步骤后， 第一个建造者会给你一栋普通房屋， 第二个会给你一座小城堡， 而第三个则会给你一座宫殿。 但是， 只有在调用构造步骤的客户端代码可以通过通用接口与建造者进行交互时， 这样的调用才能返回需要的房屋。 主管 你可以进一步将用于创建产品的一系列生成器步骤调用抽取成为单独的主管类。 主管类可定义创建步骤的执行顺序， 而生成器则提供这些步骤的实现。 严格来说， 你的程序中并不一定需要主管类。 客户端代码可直接以特定顺序调用创建步骤。 不过， 主管类中非常适合放入各种例行构造流程， 以便在程序中反复使用。 此外， 对于客户端代码来说， 主管类完全隐藏了产品构造细节。 客户端只需要将一个生成器与主管类关联， 然后使用主管类来构造产品， 就能从生成器处获得构造结果了。 ","date":"2024-05-15","objectID":"/posts/a44e805/:2:0","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["设计模式"],"content":"结构\r","date":"2024-05-15","objectID":"/posts/a44e805/:2:1","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["设计模式"],"content":"使用\r在文件夹builder_patter 中，我创建了House实体类，对应结构中的Client，HouseBuilder接口对应其中的Builder,产品为Roof,Wall,Door,Window，分别在ConcretHouseBuilder中进行建造，ConcretHouseBuilder实现了HouseBuilder接口。 HouseBuilderEngineer对应图中的主管，负责定义构造步骤的顺序。 下面我们来看一下生成器模式的应用场景 1.使用生成器模式可避免 “重叠构造函数 （telescoping constructor）” 的出现。 假设你的构造函数中有十个可选参数， 那么调用该函数会非常不方便； 因此， 你需要重载这个构造函数， 新建几个只有较少参数的简化版。 但这些构造函数仍需调用主构造函数， 传递一些默认数值来替代省略掉的参数。 生成器模式让你可以分步骤生成对象， 而且允许你仅使用必须的步骤。 应用该模式后， 你再也不需要将几十个参数塞进构造函数里了。 2.当你希望使用代码创建不同形式的产品 （例如石头或木头房屋） 时， 可使用生成器模式 如果你需要创建的各种形式的产品， 它们的制造过程相似且仅有细节上的差异， 此时可使用生成器模式。 基本生成器接口中定义了所有可能的制造步骤， 具体生成器将实现这些步骤来制造特定形式的产品。 同时， 主管类将负责管理制造步骤的顺序。 3.使用生成器构造组合树或其他复杂对象。 生成器模式让你能分步骤构造产品。 你可以延迟执行某些步骤而不会影响最终产品。 你甚至可以递归调用这些步骤， 这在创建对象树时非常方便。 生成器在执行制造步骤时， 不能对外发布未完成的产品。 这可以避免客户端代码获取到不完整结果对象的情况。 ","date":"2024-05-15","objectID":"/posts/a44e805/:2:2","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["设计模式"],"content":"优缺点\r","date":"2024-05-15","objectID":"/posts/a44e805/:2:3","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["设计模式"],"content":"抽象工厂模式\r","date":"2024-05-15","objectID":"/posts/a44e805/:3:0","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["设计模式"],"content":"单例模式\rhttps://refactoringguru.cn/design-patterns/singleton 单例模式还有七种写法，见 https://juejin.cn/post/6844904105891250189 我写的代码是懒汉式的 单例模式是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。 单例模式同时解决了两个问题， 所以违反了单一职责原则： 1.保证一个类只有一个实例。 为什么会有人想要控制一个类所拥有的实例数量？ 最常见的原因是控制某些共享资源 （例如数据库或文件） 的访问权限。 它的运作方式是这样的： 如果你创建了一个对象， 同时过一会儿后你决定再创建一个新对象， 此时你会获得之前已创建的对象， 而不是一个新对象。 注意， 普通构造函数无法实现上述行为， 因为构造函数的设计决定了它必须总是返回一个新对象。 2.为该实例提供一个全局访问节点。 还记得你 （好吧， 其实是我自己） 用过的那些存储重要对象的全局变量吗？ 它们在使用上十分方便， 但同时也非常不安全， 因为任何代码都有可能覆盖掉那些变量的内容， 从而引发程序崩溃。 和全局变量一样， 单例模式也允许在程序的任何地方访问特定对象。 但是它可以保护该实例不被其他代码覆盖。 还有一点： 你不会希望解决同一个问题的代码分散在程序各处的。 因此更好的方式是将其放在同一个类中， 特别是当其他代码已经依赖这个类时更应该如此。 ","date":"2024-05-15","objectID":"/posts/a44e805/:4:0","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["设计模式"],"content":"使用\r所有单例的实现都包含以下两个相同的步骤： 将默认构造函数设为私有， 防止其他对象使用单例类的 new运算符。 新建一个静态构建方法作为构造函数。 该函数会 “偷偷” 调用私有构造函数来创建对象， 并将其保存在一个静态成员变量中。 此后所有对于该函数的调用都将返回这一缓存对象。 如果你的代码能够访问单例类， 那它就能调用单例类的静态方法。 无论何时调用该方法， 它总是会返回相同的对象。 ","date":"2024-05-15","objectID":"/posts/a44e805/:4:1","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["设计模式"],"content":"结构\r代码在singleton_pattern文件夹下 ","date":"2024-05-15","objectID":"/posts/a44e805/:4:2","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["设计模式"],"content":"应用场景\r","date":"2024-05-15","objectID":"/posts/a44e805/:4:3","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["设计模式"],"content":"优缺点\r","date":"2024-05-15","objectID":"/posts/a44e805/:4:4","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["设计模式"],"content":"原型模式\rhttps://refactoringguru.cn/design-patterns/prototype 原型模式是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。 ","date":"2024-05-15","objectID":"/posts/a44e805/:5:0","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["设计模式"],"content":"问题\r如果你有一个对象， 并希望生成与其完全相同的一个复制品， 你该如何实现呢？ 首先， 你必须新建一个属于相同类的对象。 然后， 你必须遍历原始对象的所有成员变量， 并将成员变量值复制到新对象中。 不错！ 但有个小问题。 并非所有对象都能通过这种方式进行复制， 因为有些对象可能拥有私有成员变量， 它们在对象本身以外是不可见的。 直接复制还有另外一个问题。 因为你必须知道对象所属的类才能创建复制品， 所以代码必须依赖该类。 即使你可以接受额外的依赖性， 那还有另外一个问题： 有时你只知道对象所实现的接口， 而不知道其所属的具体类， 比如可向方法的某个参数传入实现了某个接口的任何对象。 ","date":"2024-05-15","objectID":"/posts/a44e805/:6:0","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["设计模式"],"content":"解决方案\r原型模式将克隆过程委派给被克隆的实际对象。模式为所有支持克隆的对象声明了一个通用接口， 该接口让你能够克隆对象， 同时又无需将代码和对象所属类耦合。 通常情况下， 这样的接口中仅包含一个 克隆方法。 所有的类对克隆方法的实现都非常相似。 该方法会创建一个当前类的对象， 然后将原始对象所有的成员变量值复制到新建的类中。 你甚至可以复制私有成员变量， 因为绝大部分编程语言都允许对象访问其同类对象的私有成员变量。 支持克隆的对象即为原型。 当你的对象有几十个成员变量和几百种类型时， 对其进行克隆甚至可以代替子类的构造。 其运作方式如下： 创建一系列不同类型的对象并不同的方式对其进行配置。 如果所需对象与预先配置的对象相同， 那么你只需克隆原型即可， 无需新建一个对象。 ","date":"2024-05-15","objectID":"/posts/a44e805/:6:1","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["Go"],"content":"使用详情见\rhttps://pkg.go.dev/flag https://www.liwenzhou.com/posts/Go/flag/ 例子\r写一个模拟git命令的 package main import ( \"flag\" \"fmt\" \"os\" ) func main() { // 定义子命令 initCmd := flag.NewFlagSet(\"init\", flag.ExitOnError) commitCmd := flag.NewFlagSet(\"commit\", flag.ExitOnError) // 为 commit 子命令定义参数 commitMessage := commitCmd.String(\"m\", \"\", \"Commit message\") // 检查是否传递了子命令 if len(os.Args) \u003c 2 { fmt.Println(\"expected 'init' or 'commit' subcommands\") printHelp() os.Exit(1) } // 解析子命令和参数 switch os.Args[1] { case \"init\": handleInit(initCmd, os.Args[2:]) case \"commit\": handleCommit(commitCmd, os.Args[2:], commitMessage) default: fmt.Println(\"expected 'init' or 'commit' subcommands\") printHelp() os.Exit(1) } } // 处理 init 子命令 func handleInit(initCmd *flag.FlagSet, args []string) { initCmd.Parse(args) if len(args) \u003e 0 \u0026\u0026 (args[0] == \"-h\" || args[0] == \"--help\") { initCmd.Usage() return } fmt.Println(\"Repository initialized\") } // 处理 commit 子命令 func handleCommit(commitCmd *flag.FlagSet, args []string, commitMessage *string) { commitCmd.Parse(args) if len(args) \u003e 0 \u0026\u0026 (args[0] == \"-h\" || args[0] == \"--help\") { commitCmd.Usage() return } if *commitMessage == \"\" { fmt.Println(\"commit message is required\") commitCmd.Usage() os.Exit(1) } fmt.Printf(\"Commit with message: %s\\n\", *commitMessage) } // 打印帮助信息 func printHelp() { fmt.Println(\"Usage:\") fmt.Println(\" git init Initialize a new repository\") fmt.Println(\" git commit -m Commit changes with a message\") } ","date":"2024-05-15","objectID":"/posts/2f5f3f2/:0:0","tags":["Go"],"title":"Go Flag库使用","uri":"/posts/2f5f3f2/"},{"categories":["计算机网络 - HTTP协议"],"content":"1xx 状态码\rAPI 不需要1xx状态码，下面介绍其他四类状态码的精确含义。 ","date":"2024-05-15","objectID":"/posts/098d7b4/:1:0","tags":["Http","状态码"],"title":"HTTP状态码","uri":"/posts/098d7b4/"},{"categories":["计算机网络 - HTTP协议"],"content":"2xx 状态码\r200状态码表示操作成功，但是不同的方法可以返回更精确的状态码。 GET: 200 OK POST: 201 Created PUT: 200 OK PATCH: 200 OK DELETE: 204 No Content 上面代码中，POST返回201状态码，表示生成了新的资源；DELETE返回204状态码，表示资源已经不存在。 ","date":"2024-05-15","objectID":"/posts/098d7b4/:2:0","tags":["Http","状态码"],"title":"HTTP状态码","uri":"/posts/098d7b4/"},{"categories":["计算机网络 - HTTP协议"],"content":"3xx 状态码\rAPI 用不到301状态码（永久重定向）和302状态码（暂时重定向，307也是这个含义），因为它们可以由应用级别返回，浏览器会直接跳转，API 级别可以不考虑这两种情况。 API 主要是用303 See Other，表示参考另一个 URL。它与302和307的含义一样，也是”暂时重定向”，区别在于302和307用于GET请求，而303用于POST、PUT和DELETE请求。收到303以后，浏览器不会自动跳转，而会让用户自己决定下一步怎么办。下面是一个例子。 HTTP/1.1 303 See Other Location: /api/orders/12345 ","date":"2024-05-15","objectID":"/posts/098d7b4/:3:0","tags":["Http","状态码"],"title":"HTTP状态码","uri":"/posts/098d7b4/"},{"categories":["计算机网络 - HTTP协议"],"content":"4xx 状态码\r4xx 状态码表示客户端错误，主要有下面几种： 400 Bad Request：服务器不理解客户端的请求，未做任何处理。 401 Unauthorized：用户未提供身份验证凭据，或者没有通过身份验证。 403 Forbidden：用户通过了身份验证，但是不具有访问资源所需的权限。 404 Not Found：所请求的资源不存在，或不可用。 405 Method Not Allowed：用户已经通过身份验证，但是所用的 HTTP 方法不在他的权限之内。 410 Gone：所请求的资源已从这个地址转移，不再可用。 415 Unsupported Media Type：客户端要求的返回格式不支持。比如，API 只能返回 JSON 格式，但是客户端要求返回 XML 格式。 422 Unprocessable Entity ：客户端上传的附件无法处理，导致请求失败。 429 Too Many Requests：客户端的请求次数超过限额。 ","date":"2024-05-15","objectID":"/posts/098d7b4/:4:0","tags":["Http","状态码"],"title":"HTTP状态码","uri":"/posts/098d7b4/"},{"categories":["计算机网络 - HTTP协议"],"content":"5xx 状态码\r5xx状态码表示服务端错误。一般来说，API 不会向用户透露服务器的详细信息，所以只要两个状态码就够了。 500 Internal Server Error：客户端请求有效，服务器处理时发生了意外。 503 Service Unavailable：服务器无法处理请求，一般用于网站维护状态。 ","date":"2024-05-15","objectID":"/posts/098d7b4/:5:0","tags":["Http","状态码"],"title":"HTTP状态码","uri":"/posts/098d7b4/"},{"categories":["Docker"],"content":"Docker安装mysql\r$ docker pull mysql:latest $ cd ~ $ mkdir mysql $ cd mysql $ docker run -p 3306:3306 --name mysql -v $PWD/conf/my.cnf:/etc/mysql/my.cnf -v $PWD/logs:/logs -v $PWD/data:/mysql_data -e MYSQL_ROOT_PASSWORD=123456 -d mysql 连接mysql\rhttps://docs.fedoraproject.org/en-US/quick-docs/installing-mysql-mariadb/ 可以参考一下官方文档 $ sudo dnf install community-mysql-server $ mysql -h 127.0.0.1 -P 3306 -u root -p123456 ","date":"2024-05-15","objectID":"/posts/e3c5896/:0:0","tags":["Docker","Mysql"],"title":"Docker安装mysql","uri":"/posts/e3c5896/"},{"categories":["Docker"],"content":" 原文链接: https://www.yuque.com/qingkongxiaguang/zwhkpi/kq6rlg Docker容器技术\rDocker是一门平台级别的技术，涉及的范围很广，所以，在开始之前，请确保你完成：Java SpringBoot 篇（推荐完成SpringCloud篇再来）视频教程及之前全部路线，否则学习会非常吃力，另外推荐额外掌握：《计算机网络》、《操作系统》相关知识。学一样东西不能完全靠记忆来完成，而是需要结合自己所学的基础知识加以理解，一般来说，单凭记忆能够掌握的东西往往是最廉价的。 **Docker官网：**https://www.docker.com **课前准备：**配置2C2G以上Linux服务器一台，云服务器、虚拟机均可。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:0:0","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"容器技术入门\r随着时代的发展，Docker也逐渐走上了历史舞台，曾经我们想要安装一套环境，需要花费一下午甚至一整天来配置和安装各个部分（比如运行我们自己的SpringBoot应用程序，可能需要安装数据库、安装Redis、安装MQ等，各种各样的环境光是安装就要花费很多时间，真的是搞得心态爆炸），而有了Docker之后，我们的程序和环境部署就变得非常简单了，我们只需要将这些环境一起打包成一个镜像。而到服务器上部署时，可以直接下载镜像实现一键部署，是不是很方便？ 包括我们在学习SpringCloud需要配置的各种组件，可能在自己电脑的环境中运行会遇到各种各样的问题（可能由于电脑上各种环境没配置，导致无法运行），而现在只需要下载镜像就能直接运行，所有的环境全部在镜像中配置完成，开箱即用。 真的有这么神奇吗？我们来试试看。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:1:0","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"环境安装和部署\r首先我们还是先将Docker环境搭建好（建议和我同一个环境，不然出了问题只能自己想办法了），这里我们使用： Ubuntu 22.04 操作系统 Docker分为免费的CE（Community Edition）社区版本和EE（Enterprise Edition）企业级付费版本，所以我们这里选择docker-ce进行安装。官方安装文档：https://docs.docker.com/engine/install/ubuntu/ 首先安装一些工具： sudo apt-get install ca-certificates curl gnupg lsb-release 不过在Ubuntu22.04已经默认安装好了。接着安装官方的GPG key： sudo mkdir -p /etc/apt/keyrings curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg 最后将Docker的库添加到apt资源列表中： echo \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list \u003e /dev/null 接着我们更新一次apt： sudo apt update 最后安装Docker CE版本： sudo apt install docker-ce 等待安装完成就可以了： 可以看到安装成功后版本是20.10.17，当然可能你们安装的时候就是更新的版本了。最后我们将当前用户添加到docker用户组中，不然每次使用docker命令都需要sudo执行，很麻烦： sudo usermod -aG docker \u003c用户名\u003e 配置好后，我们先退出SSH终端，然后重新连接就可以生效了。 这样我们Docker 的学习环境就配置好了，现在我们就尝试通过Docker来部署一个Nginx服务器试试看，使用很简单，只需要一个命令就可以了（当然现在看不懂没关系，我们后面会细嗦）： sudo docker run -d -p 80:80 nginx 首选它会从镜像仓库中下载对应的镜像，国内访问速度还行，不需要单独配置镜像源。接着下载完成后，就会在后台运行了，我们可以使用浏览器访问试试看： 可以看到，Nginx服务器已经成功部署了，但是实际上我们并没有在Ubuntu中安装Nginx，而是通过Docker运行的镜像来进行服务器搭建的，是不是感觉玩法挺新奇的。除了Nginx这种简单的应用之外，我们还可以通过Docker来部署复杂应用，之后我们都会一一进行讲解的。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:1:1","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"从虚拟机到容器\r前面我们成功安装了Docker学习环境，以及浅尝了一下Docker为我们带来的应用快速部署。在正式进入学习之前，我们就先从Docker的发展开始说起。 在Docker出现之前，虚拟化技术可以说是占据了主导地位。首先我们来谈谈为什么会出现虚拟化技术，我们知道在企业中服务器可以说是必不可少的一种硬件设施了，服务器也是电脑，但是不像我们的家用电脑，服务器的配置是非常高的，我们家用电脑的CPU可能最高配也就20核了，内存很少有超过128G的电脑，64G内存的家用电脑可以算奢侈了。而服务器不一样，服务器级别的CPU动辄12核，甚至服务器还能同时安装多块CPU，能直接堆到好几十核： 我们家用级CPU一般是AMD的锐龙系列和Intel的酷睿系列（比如i3 i5 i7 i9），而服务器CPU一般是Intel的志强（Xeno）系列，这种CPU的特点就是核心数非常多： 并且服务器CPU相比家用CPU的功耗也会更大，因此服务器CPU的发热量非常高，如果你有幸去过机房，你会听见散热风扇猛烈转动的声音（但是服务器CPU的频率没有家用级CPU高，一般大型游戏要求的是高频率而不是核心数，而且功耗也比较大，所以并不适合做家用电脑，所以以后在网上买台式机，看到什么“i9级”CPU千万别买，是这些黑心商家把国外服务器上淘汰下来的服务器CPU（洋垃圾）装成电脑卖给你，所以会很便宜，同时核心数又能媲美i9，所以还是一分钱一分货实在） 服务器无论是CPU资源还是内存资源都远超家用电脑，而我们编写的Java后端项目，最后都会运行在这些服务器上，不过有一个问题，服务器既然有这么丰富的硬件资源，就跑咱们这一个小Java后端，是不是有点核弹炸蚊子的感觉了？可能顶多就用了服务器5%的硬件资源，服务器这么牛就运行个这也太浪费了吧。 所以，为了解决这种资源利用率只有5%-15%的情况，咱们能不能想个办法，把这一台服务器分成多个小服务器使用，每个小服务器只分配一部分的资源，比如分一个小服务器出去，只给2个CPU核心和4G内存。但是由于设计上的问题，我们的电脑只能同时运行一个操作系统，那么怎么办呢？此时虚拟化技术就开始兴起了。 虚拟化使用软件来模拟硬件并创建虚拟计算机系统。这样一来，企业便可以在单台服务器上运行多个虚拟系统，也就是运行多个操作系统和应用，而这可以实现规模经济以及提高效益。比如我们电脑上经常使用的VMware就是一种民用级虚拟化软件： 我们可以使用VMware来创建虚拟机，这些虚拟机实际上都是基于我们当前系统上的VMware软件来运行的，当然VMware也有服务器专用的虚拟化软件，有了虚拟化之后，我们的服务器就像这样： 相当于通过虚拟机模拟了很多来电脑出来，这样我们就可以在划分出来的多台虚拟机上分别安装系统和部署我们的应用程序了，并且我们可以自由分配硬件资源，合理地使用。一般在企业中，不同的应用程序可能会被分别部署到各个服务器上，隔离开来，此时使用虚拟机就非常适合。 实际上我们在什么腾讯云、阿里云租的云服务器，都是经过虚拟化技术划分出来的虚拟机而已。 那么，既然虚拟机都这么方便了，容器又是怎么杀出一条血路的呢？我们先来看看什么是容器。 容器和虚拟机比较类似，都可以为应用提供封装和隔离，都是软件，但是容器中的应用运行是寄托于宿主操作系统的，实际上依然是在直接使用操作系统的资源，当然应用程序之间环境依然是隔离的，而虚拟机则是完全模拟一台真正的电脑出来，直接就是两台不同的电脑。 因此容器相比虚拟机就简单多了，并且启动速度也会快很多，开销小了不少。 不过容器火的根本原因还是它的集装箱思想，我们知道，如果我们要写一个比如论坛、电商这类的Java项目，那么数据库、消息队列、缓存这类中间件是必不可少的，因此我们如果想要将一个服务部署到服务器，那么实际上还要提前准备好各种各样的环境，先安装好MySQL、Redis、RabbitMQ等应用，配置好了环境，再将我们的Java应用程序启动，整个流程下来，光是配置环境就要浪费大量的时间，如果是大型的分布式项目，可能要部署很多台机器，那岂不是我们得一个一个来？项目上个线就要花几天时间，显然是很荒唐的。 而容器可以打包整个环境，比较MySQL、Redis等以及我们的Java应用程序，可以被一起打包为一个镜像，当我们需要部署服务时，只需要像我们之前那样，直接下载镜像运行即可，不需要再进行额外的配置了，整个镜像中环境是已经配置好的状态，开箱即用。 而我们要重点介绍的就是Docker了，可以看到它的图标就是一只鲸鱼，鲸鱼的上面是很多个集装箱，每个集装箱就是我们的整个环境+应用程序，Docker可以将任何应用及其依赖打包为一个轻量级，可移植，自包含的容器，容器可以运行在几乎所有的操作系统上。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:1:2","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"容器工作机制简述\r我们先来看看Docker的整体架构： 实际上分为三个部分： Docker 客户端：也就是我们之前使用的docker命令，都是在客户端上执行的，操作会发送到服务端上处理。 Docker 服务端：服务端就是启动容器的主体了，一般是作为服务在后台运行，支持远程连接。 Registry：是存放Docker镜像的仓库，跟Maven一样，也可以分公有和私有仓库，镜像可以从仓库下载到本地存放。 当我们需要在服务器上部署一个已经打包好的应用和环境，我们只需要下载打包好的镜像就可以了，我们前面执行了： sudo docker run -d -p 80:80 nginx 实际上这个命令输入之后： Docker客户端将操作发送给服务端，告诉服务端我们要运行nginx这个镜像。 Docker服务端先看看本地有没有这个镜像，发现没有。 接着只能从公共仓库Docker Hub去查找下载镜像了。 下载完成，镜像成功保存到本地。 Docker服务端加载Nginx镜像，启动容器开始正常运行（注意容器和其他容器之间，和外部之间，都是隔离的，互不影响） 所以，整个流程中，Docker就像是一搜运输船，镜像就像是集装箱，通过运输船将世界各地的货物送往我们的港口，货物到达港口后，Docker并不关心集装箱里面的是什么，只需要创建容器开箱即用就可以了。相比我们传统的手动安装配置环境，不知道方便了几个层次。 不过容器依然是寄托于宿主主机的运行的，所以一般在生产环境下，都是通过虚拟化先创建多台主机，然后再到各个虚拟机中部署Docker，这样的话，运维效率就大大提升了。 从下一章开始，我们就正式地来学习一下Docker的各种操作。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:1:3","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"容器与镜像\r要启动容器最关键的就是镜像，我们来看看镜像相关的介绍。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:2:0","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"初识容器镜像\r首先我们来了解一下镜像的相关操作，比如现在我们希望把某个镜像从仓库下载到本地，这里使用官方的hello-world镜像： docker pull hello-world 只需要输入pull命令，就可以直接下载到指定的镜像了： 可以看到对上面一行有一句Using default tag，实际上一个镜像的名称是由两部分组成的，一个是repository，还有一个是tag，一般情况下约定repository就是镜像名称，tag作为版本，默认为latest，表示最新版本。所以指定版本运行的话： docker pull 名称:版本 之后为了教学方便，我们就直接使用默认的tag，不去指定版本了。 镜像下载之后会存放在本地，要启动这个镜像的容器，实际上就像我们之前那样，输入run命令就可以了： docker run hello-world 当然如果仅仅是只想创建而不想马上运行的话，可以使用create命令： docker create hello-world 可以看到成功启动了： 启动之后，会使用当前镜像自动创建一个容器，我们可以输入ps命令来查看当前容器的容器列表： docker ps -a 注意后面要加一个-a表示查看所有容器（其他选项可以使用-h查看），如果不加的话，只会显示当前正在运行的容器，而HelloWorld是一次性的不是Nginx那样的常驻程序，所以容器启动打印了上面的内容之后，容器就停止运行了： 可以看到容器列表中有我们刚刚创建的hello-world以及我们之前创建的nginx（注意同一个镜像可以创建多个容器），每个容器都有一个随机生成的容器ID写在最前面，后面是容器的创建时间以及当前的运行状态，最后一列是容器的名称，在创建容器时，名称可以由我们指定也可以自动生成，这里就是自动生成的。 我们可以手动指定名称启动，在使用run命令时，添加--name参数即可： docker run --name=lbwnb hello-world 我们可以手动开启处于停止状态的容器： docker start \u003c容器名称/容器ID\u003e 注意启动的对象我们要填写容器的ID或是容器的名称才可以，容器ID比较长，可以不写全只写一半，但是你要保证你输入的不完全容器ID是唯一的。 如果想要停止容器直接输入stop命令就可以了： docker stop \u003c容器名称/容器ID\u003e 或是重启： docker restart \u003c容器名称/容器ID\u003e 如果我们不需要使用容器了，那么可以将容器删除，但是注意只有容器处于非运行状态时才可以删除： docker rm \u003c容器名称/容器ID\u003e 当然如果我们希望容器在停止后自动删除，我们可以在运行时添加--rm参数： docker run --rm 镜像名称 删除后，容器将不复存在，当没有任何关于nginx的容器之后，我们可以删除nginx的本地镜像： 我们可以使用images命令来检查一下当前本地有那些镜像： docker images 至此，我们已经了解了Docker的简单使用，在后面的学习中，我们还会继续认识更多的玩法。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:2:1","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"镜像结构介绍\r前面我们了解了Docker的相关基本操作，实际上容器的基石就是镜像，有了镜像才能创建对应的容器实例，那么我们就先从镜像的基本结构开始说起，我们来看看镜像到底是个什么样的存在。 我们在打包项目时，实际上往往需要一个基本的操作系统环境，这样我们才可以在这个操作系统上安装各种依赖软件，比如数据库、缓存等，像这种基本的系统镜像，我们称为base镜像，我们的项目之后都会基于base镜像进行打包，当然也可以不需要base镜像，仅仅是基于当前操作系统去执行简单的命令，比如我们之前使用的hello-world就是。 一般base镜像就是各个Linux操作系统的发行版，比如我们正在使用的Ubuntu，还有CentOS、Kali等等。这里我们就下载一下CentOS的base镜像： docker pull centos 可以看到，CentOS的base镜像就已经下载完成，不像我们使用完整系统一样，base镜像的CentOS省去了内核，所以大小只有272M，这里需要解释一下base镜像的机制： Linux操作体系由内核空间和用户空间组成，其中内核空间就是整个Linux系统的核心，Linux启动后首先会加bootfs文件系统，加载完成后会自动卸载掉，之后会加载用户空间的文件系统，这一层是我们自己可以进行操作的部分： bootfs包含了BootLoader和Linux内核，用户是不能对这层作任何修改的，在内核启动之后，bootfs会自动卸载。 rootfs则包含了系统上的常见的目录结构，包括/dev、 /proc、 /bin等等以及一些基本的文件和命令，也就是我们进入系统之后能够操作的整个文件系统，包括我们在Ubuntu下使用的apt和CentOS下使用的yum，都是用户空间上的。 base镜像底层会直接使用宿主主机的内核，也就是说你的Ubuntu内核版本是多少，那么base镜像中的CentOS内核版本就是多少，而rootfs则可以在不同的容器中运行多种不同的版本。所以，base镜像实际上只有CentOS的rootfs，因此只有300M大小左右，当然，CentOS里面包含多种基础的软件，还是比较臃肿的，而某些操作系统的base镜像甚至都不到10M。 使用uname命令可以查看当前内核版本： 因此，Docker能够同时模拟多种Linux操作系统环境，就不足为奇了，我们可以尝试启动一下刚刚下载的base镜像： docker run -it centos 注意这里需要添加-it参数进行启动，其中-i表示在容器上打开一个标准的输入接口，-t表示分配一个伪tty设备，可以支持终端登录，一般这两个是一起使用，否则base容器启动后就自动停止了。 可以看到使用ls命令能够查看所有根目录下的文件，不过很多命令都没有，连clear都没有，我们来看看内核版本： 可以看到内核版本是一样的（这也是缺点所在，如果软件对内核版本有要求的话，那么此时使用Docker就直接寄了），我们输入exit就可以退出容器终端了，可以看到退出后容器也停止了： 当然我们也可以再次启动，注意启动的时候要加上-i才能进入到容器进行交互，否则会在后台运行： 基于base镜像，我们就可以在这基础上安装各种各样的软件的了，几乎所有的镜像都是通过在base镜像的基础上安装和配置需要的软件构建出来的： 每安装一个软件，就在base镜像上一层层叠加上去，采用的是一种分层的结构，这样多个容器都可以将这些不同的层次自由拼装，比如现在好几个容器都需要使用CentOS的base镜像，而上面运行的软件不同，此时分层结构就很爽了，我们只需要在本地保存一份base镜像，就可以给多个不同的容器拼装使用，是不是感觉很灵活？ 我们看到除了这些软件之外，最上层还有一个可写容器层，这个是干嘛的呢，为什么要放在最上面？ 我们知道，所有的镜像会叠起来组成一个统一的文件系统，如果不同层中存在相同位置的文件，那么上层的会覆盖掉下层的文件，最终我们看到的是一个叠加之后的文件系统。当我们需要修改容器中的文件时，实际上并不会对镜像进行直接修改，而是在最顶上的容器层（最上面一般称为容器层，下面都是镜像层）进行修改，不会影响到下面的镜像，否则镜像就很难实现多个容器共享了。所以各个操作如下： 文件读取：要读取一个文件，Docker会最上层往下依次寻找，找到后则打开文件。 文件创建和修改：创建新文件会直接添加到容器层中，修改文件会从上往下依次寻找各个镜像中的文件，如果找到，则将其复制到容器层，再进行修改。 删除文件：删除文件也会从上往下依次寻找各个镜像中的文件，一旦找到，并不会直接删除镜像中的文件，而是在容器层标记这个删除操作。 也就是说，我们对整个容器内的文件进行的操作，几乎都是在最上面的容器层进行的，我们是无法干涉到下面所有的镜像层文件的，这样就很好地保护了镜像的完整性，才能实现多个容器共享使用。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:2:2","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"构建镜像\r前面我们已经了解了Docker镜像的结构，实际上所有常用的应用程序都有对应的镜像，我们只需要下载这些镜像然后就可以使用了，而不需要自己去手动安装，顶多需要进行一些特别的配置。当然要是遇到某些冷门的应用，可能没有提供镜像，这时就要我们手动去安装，接着我们就来看看如何构建我们自己的Docker镜像。构建镜像有两种方式，一种是使用commit命令来完成，还有一种是使用Dockerfile来完成，我们先来看第一种。 这里我们就做一个简单的例子，比如我们现在想要在Ubuntu的base镜像中安装Java环境，并将其打包为新的镜像（这个新的镜像就是一个包含Java环境的Ubuntu系统镜像） 咱们先启动Ubuntu镜像，然后使用yum命令（跟apt比较类似）来安装Java环境，首先是run命令： docker pull ubuntu 接着启动： 直接使用apt命令来安装Java环境，在这之前先更新一下，因为是最小安装所以本地没有任何软件包： 接着输入： apt install openjdk-8-jdk 等待安装完成： 这样，我们就完成了对Java环境的安装了，接着我们就可以退出这个镜像然后将其构建为新的镜像： 使用commit命令可以将容器保存为新的镜像： docker commit 容器名称/ID 新的镜像名称 可以看到安装了软件之后的镜像大小比我们原有的大小大得多，这样我们就可以通过这个镜像来直接启动一个带Java环境的Ubuntu操作系统容器了。不过这种方式虽然自定义度很高，但是Docker官方并不推荐，这样的话使用者并不知道镜像是如何构建出来的，是否里面带了后门都不知道，并且这样去构建效率太低了，如果要同时构建多种操作系统的镜像岂不是要一个一个去敲？我们作为普通用户实际上采用Dokcerfile的方式会更好一些。 我们来看看如何使用Dockerfile的形式创建一个带Java环境的Ubuntu系统镜像。首先直接新建一个名为Dockerfile的文件： touch Dockerfile 接着我们来进行编辑，Dockerfile内部需要我们编写多种指令来告诉Docker我们的镜像的相关信息： FROM \u003c基础镜像\u003e 首先我们需要使用FROM指令来选择当前镜像的基础镜像（必须以这个指令开始），这里我们直接使用ubuntu作为基础镜像即可，当然如果不需要任何基础镜像的话，直接使用scratch表示从零开始构建，这里就不演示了。 基础镜像设定完成之后，我们就需要在容器中运行命令来安装Java环境了，这里需要使用RUN指令： RUN apt update RUN apt install -y openjdk-8-jdk 每条指令执行之后，都会生成一个新的镜像层。 OK，现在我们的Dockerfile就编写完成了，只需要完成一次构建即可： docker build -t \u003c镜像名称\u003e \u003c构建目录\u003e 执行后，Docker会在构建目录中寻找Dockerfile文件，然后开始依次执行Dockerfile中的指令： 构建过程的每一步都非常清晰地列出来了，一共三条指令对应三步依次进行，我们稍微等待一段时间进行安装，安装过程中所以的日志信息会直接打印到控制台（注意Docker镜像构建有缓存机制，就算你现在中途退出了，然后重新进行构建，也会直接将之前已经构建好的每一层镜像，直接拿来用，除非修改了Dockerfile文件重新构建，只要某一层发生变化其上层的构建缓存都会失效，当然包括pull时也会有类似的机制） 最后成功安装，会出现在本地： 可以看到安装出来的大小跟我们之前的是一样的，因为做的事情是一模一样的。我们可以使用history命令来查看构建历史： 可以看到最上面两层是我们通过使用apt命令生成的内容，就直接作为当前镜像中的两层镜像，每层镜像都有一个自己的ID，不同的镜像大小也不一样。而我们手动通过commit命令来生成的镜像没有这个记录： 如果遇到镜像ID为missing的一般是从Docker Hub中下载的镜像会有这个问题，但是问题不大。用我们自己构建的镜像来创建容器就可以直接体验带Java环境的容器了： 有关Dockerfile的其他命令，我们还会在后续的学习中逐步认识。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:2:3","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"发布镜像到远程仓库\r前面我们学习了如何构建一个Docker镜像，我们可以将自己的镜像发布到Docker Hub中，就像Git远程仓库一样，我们可以将自己的镜像上传到这里：https://hub.docker.com/repositories，没有账号的先去进行注册。 点击右上角的创建仓库，然后填写信息： 创建完成后，我们就有了一个公共的镜像仓库，我们可以将本地的镜像上传了，上传之前我们需要将镜像名称修改得规范一点，这里使用tag命令来重新打标签： docker tag ubuntu-java-file:latest 用户名/仓库名称:版本 这里我们将版本改成1.0版本吧，不用默认的latest了。 修改完成后，会创建一个新的本地镜像，名称就是我们自己定义的了。接着我们需在本地登录一下： 登录成功后我们就可以上传了： docker push nagocoler/ubuntu-java:1.0 哈哈，500M的东西传上去，还是有点压力的，如果实在太慢各位可以重新做一个简单点的镜像。上传完成后，打开仓库，可以看到已经有一个1.0版本了： 注意公共仓库是可以被搜索和下载的，所以我们这里把本地的镜像全部删掉，去下载我们刚刚上传好的镜像。这里我们先搜索一下，搜索使用search命令即可： docker search nagocoler/ubuntu-java 我们可以使用pull命令将其下载下来： docker pull nagocoler/ubuntu-java:1.0 上传之后的镜像是被压缩过的，所以下载的内容就比较少一些。运行试试看： 当然各位也可以让自己的同学或是在其他机器上尝试下载自己的镜像，看看是不是都可以正常运行。 Docker Hub也可以自行搭建私服，但是这里就不多做介绍了，至此，有关容器和镜像的一些基本操作就讲解得差不多了。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:2:4","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"实战：使用IDEA构建SpringBoot程序镜像\r这里我们创建一个新的SpringBoot项目，现在我们希望能够使用Docker快速地将我们的SpringBoot项目部署到安装了Docker的服务器上，我们就可以将其打包为一个Docker镜像。 先创建好一个项目让它跑起来，可以正常运行就没问题了，接着我们需要将其打包为Docker镜像，这里创建一个新的Dockerfile： FROM ubuntu RUN apt update \u0026\u0026 apt install -y openjdk-8-jdk 首先还是基于ubuntu构建一个带Java环境的系统镜像，接着我们先将其连接到我们的Docker服务器进行构建，由于IDEA自带了Docker插件，所以我们直接点击左上角的运行按钮，选择第二项 “为Dockerfile构建镜像”： 这里需要配置Docker的服务器，也就是我们在Ubuntu服务器安装的Docker，这里我们填写服务器相关信息，我们首选需要去修改一下Docker的一些配置，开启远程客户端访问： sudo vim /etc/systemd/system/multi-user.target.wants/docker.service 打开后，添加高亮部分： 修改完成后，重启Docker服务，如果是云服务器，记得开启2375 TCP连接端口： sudo systemctl daemon-reload sudo systemctl restart docker.service 现在接着在IDEA中进行配置： 在引擎API URL处填写我们Docker服务器的IP地址： tcp://IP:2375 显示连接成功后，表示配置正确，点击保存即可，接着就开始在我们的Docker服务器上进行构建了： 最后成功构建： 可以看到，Docker服务器上已经有了我们刚刚构建好的镜像： 不过名称没有指定，这里我们重新配置一下： 重新进行构建，就是我们自定义的名称了： 我们来创建一个容器试试看： 好了，现在基本环境搭建好了，我们接着就需要将我们的SpringBoot项目打包然后再容器启动时运行了，打开Maven执行打包命令： 接着我们需要编辑Dockerfile，将我们构建好的jar包放进去： COPY target/DockerTest-0.0.1-SNAPSHOT.jar app.jar 这里需要使用COPY命令来将文件拷贝到镜像中，第一个参数是我们要拷贝的本地文件，第二个参数是存放在Docker镜像中的文件位置，由于还没有学习存储管理，这里我们直接输入app.jar直接保存在默认路径即可。 接着我们就需要指定在启动时运行我们的Java程序，这里使用CMD命令来完成： FROM ubuntu RUN apt update \u0026\u0026 apt install -y openjdk-8-jdk COPY target/DockerTest-0.0.1-SNAPSHOT.jar app.jar CMD java -jar app.jar # EXPOSE 8080 CMD命令可以设定容器启动后执行的命令，EXPOSE可以指定容器需要暴露的端口，但是现在我们还没有学习网络相关的知识，所以暂时不使用，这里指定为我们启动Java项目的命令。配置完成后，重新构建： 可以看到历史中已经出现新的步骤了： 接着启动我们的镜像，我们可以直接在IDEA中进行操作，不用再去敲命令了，有点累： 启动后可以在右侧看到容器启动的日志信息： 但是我们发现启动之后并不能直接访问，这是为什么呢？这是因为容器内部的网络和外部网络是隔离的，我们如果想要访问容器内的服务器，需要将对应端口绑定到宿主机上，让宿主主机也开启这个端口，这样才能连接到容器内： docker run -p 8080:8080 -d springboot-test:1.0 这里-p表示端口绑定，将Docker容器内的端口绑定到宿主机的端口上，这样就可以通过宿主的8080端口访问到容器的8080端口了（有关容器网络管理我们还会在后面进行详细介绍），-d参数表示后台运行，当然直接在IDEA中配置也是可以的： 配置好后，点击重新创建容器： 重新运行后，我们就可以成功访问到容器中运行的SpringBoot项目了： 当然，为了以后方便使用，我们可以直接将其推送到Docker Hub中，这里我们还是创建一个新的公开仓库： 这次我们就使用IDEA来演示直接进行镜像的上传，直接点击： 接着我们需要配置一下我们的Docker Hub相关信息： OK，远程镜像仓库配置完成，直接推送即可，等待推送完成。 可以看到远程仓库中已经出现了我们的镜像，然后IDEA中也可以同步看到： 这样，我们就完成了使用IDEA将SpringBoot项目打包为Docker镜像。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:2:5","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"容器网络管理\r**注意：**本小节学习需要掌握部分《计算机网络》课程中的知识。 前面我们学习了容器和镜像的一些基本操作，了解了如何通过镜像创建容器、然后自己构建容器，以及远程仓库推送等，这一部分我们接着来讨论容器的网络管理。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:3:0","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"容器网络类型\rDocker在安装后，会在我们的主机上创建三个网络，使用network ls命令来查看： docker network ls 可以看到默认情况下有bridge、host、none这三种网络类型（其实有点像虚拟机的网络配置，也是分桥接、共享网络之类的），我们先来依次介绍一下，在开始之前我们先构建一个镜像，默认的ubuntu镜像由于啥软件都没有，所以我们把一会网络要用到的先提前装好： docker run -it ubuntu apt update apt install net-tools iputils-ping curl 这样就安装好了，我们直接退出然后将其构建为新的镜像： docker commit lucid_sammet ubuntu-net OK，一会我们就可以使用了。 **none网络：**这个网络除了有一个本地环回网络之外，就没有其他的网络了，我们可以在创建容器时指定这个网络。 这里使用--network参数来指定网络： docker run -it --network=none ubuntu-net 进入之后，我们可以直接查看一下当前的网络： ifconfig 可以看到只有一个本地环回lo网络设备： 所以这个容器是无法连接到互联网的： “真”单机运行，可以说是绝对的安全，没人能访问进去，存点密码这些还是不错的。 **bridge网络：**容器默认使用的网络类型，这是桥接网络，也是应用最广泛的网络类型： 实际上我们在宿主主机上查看网络信息，会发现有一个名为docker0的网络设备： 这个网络设备是Docker安装时自动创建的虚拟设备，它有什么用呢？我们可以来看一下默认创建的容器内部的情况： docker run -it ubuntu-net 可以看到容器的网络接口地址为172.17.0.2，实际上这是Docker创建的虚拟网络，就像容器单独插了一根虚拟的网线，连接到Docker创建的虚拟网络上，而docker0网络实际上作为一个桥接的角色，一头是自己的虚拟子网，另一头是宿主主机的网络。 网络拓扑类似于下面这样： 通过添加这样的网桥，我们就可以对容器的网络进行管理和控制，我们可以使用network inspect命令来查看docker0网桥的配置信息： docker network inspect bridge 这里的配置的子网是172.17.0.0，子网掩码是255.255.0.0，网关是172.17.0.1，也就是docker0这个虚拟网络设备，所以我们上面创建的容器就是这个子网内分配的地址172.17.0.2了。 之后我们还会讲解如何管理和控制容器网络。 **host网络：**当容器连接到此网络后，会共享宿主主机的网络，网络配置也是完全一样的： docker run -it --network=host ubuntu-net 可以看到网络列表和宿主主机的列表是一样的，不知道各位有没有注意到，连hostname都是和外面一模一样的： 只要宿主主机能连接到互联网，容器内部也是可以直接使用的： 这样的话，直接使用宿主的网络，传输性能基本没有什么折损，而且我们可以直接开放端口等，不需要进行任何的桥接： apt install -y systemctl nginx systemctl start nginx 安装Nginx之后直接就可以访问了，不需要开放什么端口： 相比桥接网络就方便得多了。 我们可以根据实际情况，来合理地选择这三种网络使用。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:3:1","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"用户自定义网络\r除了前面我们介绍的三种网络之外，我们也可以自定义自己的网络，让容器连接到这个网络。 Docker默认提供三种网络驱动：bridge、overlay、macvlan，不同的驱动对应着不同的网络设备驱动，实现的功能也不一样，比如bridge类型的，其实就和我们前面介绍的桥接网络是一样的。 我们可以使用network create来试试看： docker network create --driver bridge test 这里我们创建了一个桥接网络，名称为test： 可以看到新增了一个网络设备，这个就是一会负责我们容器网络的网关了，和之前的docker0是一样的： docker network inspect test 这里我们创建一个新的容器，使用此网络： docker run -it --network=test ubuntu-net 成功得到分配的IP地址，是在这个网络内的，注意不同的网络之间是隔离的，我们可以再创建一个容器试试看： 可以看到不同的网络是相互隔离的，无法进行通信，当然我们也为此容器连接到另一个容器所属的网络下： docker network connect test 容器ID/名称 这样就连接了一个新的网络： 可以看到容器中新增了一个网络设备连接到我们自己定义的网络中，现在这两个容器在同一个网络下，就可以相互ping了： 这里就不介绍另外两种类型的网络了，他们是用于多主机通信的，目前我们只学习单机使用。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:3:2","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"容器间网络\r我们首先来看看容器和容器之间的网络通信，实际上我们之前已经演示过ping的情况了，现在我们创建两个ubuntu容器： docker run -it ubuntu-net 先获取其中一个容器的网络信息： 我们可以直接在另一个容器中ping这个容器： ![image-20220702175444713](/Users/nagocoler/Library/Application Support/typora-user-images/image-20220702175444713.png) 可以看到能够直接ping通，因为这两个容器都是使用的bridge网络，在同一个子网中，所以可以互相访问。 我们可以直接通过容器的IP地址在容器间进行通信，只要保证两个容器处于同一个网络下即可，虽然这样比较方便，但是大部分情况下，容器部署之后的IP地址是自动分配的（当然也可以使用--ip来手动指定，但是还是不方便），我们无法提前得知IP地址，那么有没有一直方法能够更灵活一些呢？ 我们可以借助Docker提供的DNS服务器，它就像是一个真的DNS服务器一样，能够对域名进行解析，使用很简单，我们只需要在容器启动时给个名字就行了，我们可以直接访问这个名称，最后会被解析为对应容器的IP地址，但是注意只会在我们用户自定义的网络下生效，默认的网络是不行的： docker run -it --name=test01 --network=test ubuntu-net docker run -it --name=test02 --network=test ubuntu-net 接着直接ping对方的名字就可以了： 可以看到名称会自动解析为对应的IP地址，这样的话就不用担心IP不确定的问题了。 当然我们也可以让两个容器同时共享同一个网络，注意这里的共享是直接共享同一个网络设备，两个容器共同使用一个IP地址，只需要在创建时指定： docker run -it --name=test01 --network=container:test02 ubuntu-net 这里将网络指定为一个容器的网络，这样两个容器使用的就是同一个网络了： 可以看到两个容器的IP地址和网卡的Mac地址是完全一样的，它们的网络现在是共享状态，此时在容器中访问，localhost，既是自己也是别人。 我们可以在容器1中，安装Nginx，然后再容器2中访问： apt install -y systemctl nginx systemctl start nginx 成功访问到另一个容器中的Nginx服务器。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:3:3","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"容器外部网络\r前面我们介绍了容器之间的网络通信，我们接着来看容器与外部网络的通信。 首先我们来看容器是如何访问到互联网的，在默认的三种的网络下，只有共享模式和桥接模式可以连接到外网，共享模式实际上就是直接使用宿主主机的网络设备连接到互联网，这里我们主要来看一下桥接模式。 通过前面的学习，我们了解到桥接模式实际上就是创建一个单独的虚拟网络，让容器在这个虚拟网络中，然后通过桥接器来与外界相连，那么数据包是如何从容器内部的网络到达宿主主机再发送到互联网的呢？实际上整个过程中最关键的就是依靠NAT（Network Address Translation）将地址进行转换，再利用宿主主机的IP地址发送数据包出去。 这里我们就来补充一下《计算机网络》课程中学习的NAT： 实际上NAT在我们生活中也是经常见到的，比如我们要访问互联网上的某个资源，要和服务器进行通信，那么就需要将数据包发送出去，同时服务器也要将数据包发送回来，我们可以知道服务器的IP地址，也可以直接去连接，因为服务器的IP地址是暴露在互联网上的，但是我们的局域网就不一样了，它仅仅局限在我们的家里，比如我们连接了家里的路由器，可以得到一个IP地址，但是你会发现，这个IP公网是无法直接访问到我们的，因为这个IP地址仅仅是一个局域网的IP地址，俗称内网IP，既然公网无法访问到我们，那服务器是如何将数据包发送给我们的呢？ 实际上这里就借助了NAT在帮助我们与互联网上的服务器进行通信，通过NAT，可以实现将局域网的IP地址，映射为对应的公网IP地址，而NAT设备一端连接外网，另一端连接内网的所有设备，当我们想要与外网进行通信时，就可以将数据包发送给NAT设备，由它来将数据包的源地址映射为它在外网上的地址，这样服务器就能够发现它了，能够直接与它建立通信。当服务器发送数据回来时，也是直接交给NAT设备，然后再根据地址映射，转发给对应的内网设备（当然由于公网IP地址有限，所以一般采用IP+端口结合使用的形式ANPT） 所以你打开百度直接搜IP，会发现这个IP地址并不是你本地的，而是NAT设备的公网地址： 实际上我们家里的路由器一般都带有NAT功能，默认开启NAT模式，包括我们的小区也是有一个NAT设备在进行转换的，这样你的电脑才能在互联网的世界中遨游。当然NAT也可以保护内网的设备不会直接暴露在公网，这样也会更加的安全，只有当我们主动发起连接时，别人才能知道我们。 当然，我们的Docker也是这样的，实际上内网的数据包想要发送到互联网上去，那么就需要经过这样的一套流程： 这样，Docker容器使用的内网就可以和外网进行通信了。 但是这样有一个问题，单纯依靠NAT的话，只有我们主动与外界联系时，外界才能知道我们，但是现在我们的容器中可能会部署一些服务，需要外界来主动连接我们，此时该怎么办呢？ 我们可以直接在容器时配置端口映射，还记得我们在第一节课部署Nginx服务器吗？ docker run -d -p 80:80 nginx 这里的-p参数实际上是进行端口映射配置，端口映射可以将容器需要对外提供服务的端口映射到宿主主机的端口上，这样，当外部访问到宿主主机的对应端口时，就会直接转发给容器内映射的端口了。规则为宿主端口:容器端口，这里配置的是将容器的80端口映射到宿主主机的80端口上。 一旦监听到宿主主机的80端口收到了数据包，那么会直接转发给对应的容器。所以配置了端口映射之后，我们才可以从外部正常访问到容器内的服务： 我们也可以直接输入docker ps查看端口映射情况： 至此，有关容器的网络部分，就到此为止，当然这仅仅是单机下的容器网络操作，在以后的课程中，我们还会进一步学习多主机下的网络配置。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:3:4","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"容器存储管理\r前面我们介绍了容器的网络管理，我们现在已经了解了如何配置容器的网络，以及相关的一些原理。还有一个比较重要的部分就是容器的存储，在这一小节我们将深入了解容器的存储管理。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:4:0","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"容器持久化存储\r我们知道，容器在创建之后，实际上我们在容器中创建和修改的文件，实际上是被容器的分层机制保存在最顶层的容器层进行操作的，为了保护下面每一层的镜像不被修改，所以才有了这样的CopyOnWrite特性。但是这样也会导致容器在销毁时数据的丢失，当我们销毁容器重新创建一个新的容器时，所有的数据全部丢失，直接回到梦开始的地方。 在某些情况下，我们可能希望对容器内的某些文件进行持久化存储，而不是一次性的，这里就要用到数据卷（Data Volume）了。 在开始之前我们先准备一下实验要用到的镜像： docker run -it ubuntu apt update \u0026\u0026 apt install -y vim 然后打包为我们一会要使用的镜像： docker commit 我们可以让容器将文件保存到宿主主机上，这样就算容器销毁，文件也会在宿主主机上保留，下次创建容器时，依然可以从宿主主机上读取到对应的文件。如何做到呢？只需要在容器启动时指定即可： mkdir test 我们现在用户目录下创建一个新的test目录，然后在里面随便创建一个文件，再写点内容： vim test/hello.txt 接着我们就可以将宿主主机上的目录或文件挂载到容器的某个目录上： docker run -it -v ~/test:/root/test ubuntu-volume 这里用到了一个新的参数-v，用于指定文件挂载，这里是将我们刚刚创建好的test目录挂在到容器的/root/test路径上。 这样我们就可以直接在容器中访问宿主主机上的文件了，当然如果我们对挂载目录中的文件进行编辑，那么相当于编辑的是宿主主机的数据： vim /root/test/test.txt 在宿主主机的对应目录下，可以直接访问到我们刚刚创建好的文件。 接着我们来将容器销毁，看看当容器不复存在时，挂载的数据时候还能保留： 可以看到，即使我们销毁了容器，在宿主主机上的文件依然存在，并不会受到影响，这样的话，当我们下次创建新的镜像时，依然可以使用这些保存在外面的文件。 比如我们现在想要部署一个Nginx服务器来代理我们的前端，就可以直接将前端页面保存到宿主主机上，然后通过挂载的形式让容器中的Nginx访问，这样就算之后Nginx镜像有升级，需要重新创建，也不会影响到我们的前端页面。这里我们来测试一下，我们先将前端模板上传到服务器： scp Downloads/moban5676.zip 192.168.10.10:~/ 然后在服务器上解压一下： unzip moban5676.zip 接着我们就可以启动容器了： docker run -it -v ~/moban5676:/usr/share/nginx/html/ -p 80:80 -d nginx 这里我们将解压出来的目录，挂载到容器中Nginx的默认站点目录/usr/share/nginx/html/（由于挂在后位于顶层，会替代镜像层原有的文件），这样Nginx就直接代理了我们存放在宿主主机上的前端页面，当然别忘了把端口映射到宿主主机上，这里我们使用的镜像是官方的nginx镜像。 现在我们进入容器将Nginx服务启动： systemctl start nginx 然后通过浏览器访问看看是否代理成功： 可以看到我们的前端页面直接被代理了，当然如果我们要编写自定义的配置，也是使用同样的方法操作即可。 注意如果我们在使用-v参数时不指定宿主主机上的目录进行挂载的话，那么就由Docker来自动创建一个目录，并且会将容器中对应路径下的内容拷贝到这个自动创建的目录中，最后挂在到容器中，这种就是由Docker管理的数据卷了（docker managed volume）我们来试试看： docker run -it -v /root/abc ubuntu-volume 注意这里我们仅仅指定了挂载路径，没有指定宿主主机的对应目录，继续创建： 创建后可以看到root目录下有一个新的abc目录，那么它具体是在宿主主机的哪个位置呢？这里我们依然可以使用inspect命令： docker inspect bold_banzai 可以看到Sorce指向的是/var/lib中的某个目录，我们可以进入这个目录来创建一个新的文件，进入之前记得提升一下权限，权限低了还进不去： 我们来创一个新的文本文档： 实际上和我们之前是一样的，也是可以在容器中看到的，当然删除容器之后，数据依然是保留的。当我们不需要使用数据卷时，可以进行删除： 当然有时候为了方便，可能并不需要直接挂载一个目录上去，仅仅是从宿主主机传递一些文件到容器中，这里我们可以使用cp命令来完成： 这个命令支持从宿主主机复制文件到容器，或是从容器复制文件到宿主主机，使用方式类似于Linux自带的cp命令。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:4:1","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"容器数据共享\r前面我们通过挂载的形式，将宿主主机上的文件直接挂载到容器中，这样容器就可以直接访问到宿主主机上的文件了，并且在容器删除时也不会清理宿主主机上的文件。 我们接着来看看如何实现容器与容器之间的数据共享，实际上按照我们之前的思路，我们可以在宿主主机创建一个公共的目录，让这些需要实现共享的容器，都挂载这个公共目录： docker run -it -v ~/test:/root/test ubuntu-volume 由于挂载的是宿主主机上的同一块区域，所以内容可以直接在两个容器中都能访问。当然我们也可以将另一个容器挂载的目录，直接在启动容器时指定使用此容器挂载的目录： docker run -it -v ~/test:/root/test --name=data_test ubuntu-volume docker run -it --volumes-from data_test ubuntu-volume 这里使用--volumes-from指定另一个容器（这种用于给其他容器提供数据卷的容器，我们一般称为数据卷容器） 可以看到，数据卷容器中挂载的内容，在当前容器中也是存在的，当然就算此时数据卷容器被删除，那么也不会影响到这边，因为这边相当于是继承了数据卷容器提供的数据卷，所以本质上还是让两个容器挂载了同样的目录实现数据共享。 虽然通过上面的方式，可以在容器之间实现数据传递，但是这样并不方便，可能某些时候我们仅仅是希望容器之间共享，而不希望有宿主主机这个角色直接参与到共享之中，此时我们就需要寻找一种更好的办法了。其实我们可以将数据完全放入到容器中，通过构建一个容器，来直接将容器中打包好的数据分享给其他容器，当然本质上依然是一个Docker管理的数据卷，虽然还是没有完全脱离主机，但是移植性就高得多了。 我们来编写一个Dockerfile： FROM ubuntu ADD moban5676.tar.gz /usr/share/nginx/html/ VOLUME /usr/share/nginx/html/ 这里我们使用了一个新的指令ADD，它跟COPY命令类似，也可以复制文件到容器中，但是它可以自动对压缩文件进行解压，这里只需要将压缩好的文件填入即可，后面的VOLUME指令就像我们使用-v参数一样，会创建一个挂载点在容器中： cd test tar -zcvf moban5676.tar.gz * mv moban5676.tar.gz .. cd .. 接着我们直接构建： docker build -t data . 现在我们运行一个容器看看： 可以看到所有的文件都自动解压出来了（除了中文文件名称乱码了之外，不过无关紧要）我们退出容器，可以看到数据卷列表中新增了我们这个容器需要使用的： 这个位置实际上就是数据存放在当前主机上的位置了，不过是由Docker进行管理而不是我们自定义的。现在我们就可以创建一个新的容器直接继承了： docker run -p 80:80 --volumes-from=data_test -d nginx 访问一下Nginx服务器，可以看到成功代理： 这样我们就实现了将数据放在容器中进行共享，我们不需要刻意去指定宿主主机的挂载点，而是Docker自行管理，这样就算迁移主机依然可以快速部署。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:4:2","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"容器资源管理\r前面我们已经完成Docker的几个主要模块的学习，最后我们来看看如何对容器的资源进行管理。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:5:0","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"容器控制操作\r在开始之前，我们还是要先补充一些我们前面没有提到的其他容器命令。 首先我们的SpringBoot项目在运行是，怎么查看输出的日志信息呢？ docker logs test 这里使用log命令来打印容器中的日志信息： 当然也可以添加-f参数来持续打印日志信息。 现在我们的容器已经启动了，但是我们想要进入到容器监控容器的情况怎么办呢？我们可以是attach命令来附加到容器启动命令的终端上： docker attach 容器ID/名称 注意现在就切换为了容器内的终端，如果想要退出的话，需要先按Ctrl+P然后再按Ctrl+Q来退出终端，不能直接使用Ctrl+C来终止，这样会直接终止掉Docker中运行的Java程序的。 退出后，容器依然是处于运行状态的。 我们也可以使用exec命令在容器中启动一个新的终端或是在容器中执行命令： docker exec -it test bash -it和run命令的操作是一样的，这里执行后，会创建一个新的终端（当然原本的程序还是在正常运行）我们会在一个新的终端中进行交互： 当然也可以仅仅在容器中执行一条命令： 执行后会在容器中打开一个新的终端执行命令，并输出结果。 前面我们还学习了容器的停止操作，通过输入stop命令来停止容器，但是此操作并不会立即停止，而是会等待容器处理善后，那么怎么样才能强制终止容器呢？我们可以直接使用kill命令，相当于给进程发送SIGKILL信号，强制结束。 docker kill test 相比stop命令，kill就没那么温柔了。 有时候可能只是希望容器暂时停止运行，而不是直接终止运行，我们希望在未来的某个时间点，恢复容器的运行，此时就可以使用pause命令来暂停容器： docker pause test 暂停容器后，程序暂时停止运行，无法响应浏览器发送的请求： 此时处于爱的魔力转圈圈状态，我们可以将其恢复运行，使用unpause命令： docker unpause test 恢复运行后，瞬间就响应成功了。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:5:1","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"物理资源管理\r对于一个容器，在某些情况下我们可能并不希望它占据所有的系统资源来运行，我们只希望分配一部分资源给容器，比如只分配给容器2G内存，最大只允许使用2G，不允许再占用更多的内存，此时我们就需要对容器的资源进行限制。 docker run -m 内存限制 --memory-swap=内存和交换分区总共的内存限制 镜像名称 其中-m参数是对容器的物理内存的使用限制，而--memory-swap是对内存和交换分区总和的限制，它们默认都是-1，也就是说没有任何的限制（如果在一开始仅指定-m参数，那么交换内存的限制与其保持一致，内存+交换等于-m的两倍大小）默认情况下跟宿主主机一样，都是2G内存，现在我们可以将容器的内存限制到100M试试看，其中物理内存50M，交换内存50M，尝试启动一下SpringBoot程序： docker run -it -m 50M --memory-swap=100M nagocoler/springboot-test:1.0 可以看到，上来就因为内存不足无法启动了： 当然除了对内存的限制之外，我们也可以对CPU资源进行限额，默认情况下所有的容器都可以平等地使用CPU资源，我们可以调整不同的容器的CPU权重（默认为1024），来按需分配资源，这里需要使用到-c选项，也可以输入全名--cpu-share： docker run -c 1024 ubuntu docker run -c 512 ubuntu 这里容器的CPU权重比例为16比8，也就是2比1（注意多个容器时才会生效），那么当CPU资源紧张时，会按照此权重来分配资源，当然如果CPU资源并不紧张的情况下，依然是有机会使用到全部的CPU资源的。 这里我们使用一个压力测试工具来进行验证： docker run -c 1024 --name=cpu1024 -it ubuntu docker run -c 512 --name=cpu512 -it ubuntu 接着我们分别进入容器安装stress压力测试工具： apt update \u0026\u0026 apt install -y stress 接着我们分别在两个容器中都启动压力测试工具，产生4个进程不断计算随机数的平方根： stress -c 4 接着我们进入top来看看CPU状态（看完之后记得赶紧去kill掉容器，不然CPU拉满很卡的）： 可以看到权重高的容器中，分配到了更多的CPU资源，而权重低的容器中，只分配到一半的CPU资源。 当然我们也可以直接限制容器使用的CPU数量： docker run -it --cpuset-cpus=1 ubuntu --cpuset-cpus选项可以直接限制在指定的CPU上运行，比如现在我们的宿主机是2核的CPU，那么就可以分0和1这两个CPU给Docker使用，限制后，只会使用CPU 1的资源了： 可以看到，4个进程只各自使用了25%的CPU，加在一起就是100%，也就是只能占满一个CPU的使用率。如果要分配多个CPU，则使用逗号隔开： docker run -it --cpuset-cpus=0,1 ubuntu 这样就会使用这两个CPU了： 当然也可以直接使用--cpus来限制使用的CPU资源数： docker run -it --cpus=1 ubuntu 限制为1后，只能使用一个CPU提供的资源，所以这里加载一起只有一个CPU的资源了。当然还有更精细的--cpu-period 和--cpu-quota，这里就不做介绍了。 最后我们来看一下对磁盘IO读写性能的限制，我们首先使用dd命令来测试磁盘读写速度： dd if=/dev/zero of=/tmp/1G bs=4k count=256000 oflag=direct 可以不用等待跑完，中途Ctrl+C结束就行： 可以看到当前的读写速度为86.4 MB/s，我们可以通过--device-read/write-bps和--device-read/write-iops参数对其进行限制。 这里要先说一下区别： bps：每秒读写的数据量。 iops：每秒IO的次数。 为了直观，这里我们直接使用BPS作为限制条件： docker run -it --device-write-bps=/dev/sda:10MB ubuntu 因为容器的文件系统是在/dev/sda上的，所以这我们就/dev/sda:10MB来限制对/dev/sda的写入速度只有10MB/s，我们来测试一下看看： 可以看到现在的速度就只有10MB左右了。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:5:2","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"容器监控\r最后我们来看看如何对容器的运行状态进行实时监控，我们现在希望能够对容器的资源占用情况进行监控，该怎么办呢？ 我们可以使用stats命令来进行监控： docker stats 可以实时对容器的各项状态进行监控，包括内存使用、CPU占用、网络I/O、磁盘I/O等信息，当然如果我们限制内存的使用的话： docker run -d -m 200M nagocoler/springboot-test:1.0 可以很清楚地看到限制情况： 除了使用stats命令来实时监控情况之外，还可以使用top命令来查看容器中的进程： docker top 容器ID/名称 当然也可以携带一些参数，具体的参数与Linux中ps命令参数一致，这里就不多做介绍了。 但是这样的监控是不是太原始了一点？有没有那种网页面板可以进行实时监控和管理的呢？有的。 我们需要单独部署一个Docker网页管理面板应用，一般比较常见的有：Portainer，我们这里可以直接通过Docker镜像的方式去部署这个应用程序，搜索一下，发现最新版维护的地址为：https://hub.docker.com/r/portainer/portainer-ce CE为免费的社区版本，当然也有BE商业版本，这里我们就直接安装社区版就行了，官方Linux安装教程：https://docs.portainer.io/start/install/server/docker/linux，包含一些安装前需要的准备。 首先我们需要创建一个数据卷供Portainer使用： docker volume create portainer_data 接着通过官方命令安装启动： docker run -d -p 8000:8000 -p 9443:9443 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:latest 注意这里需要开放两个端口，一个是8000端口，还有一个是9443端口。 OK，开启成功，我们可以直接登录后台面板：https://IP:9443/，这里需要HTTPS访问，浏览器可能会提示不安全，无视就行： 进入后就需要我们进行注册了，这里我们只需输入两次密码即可，默认用户名就是admin，填写完成后，我们就可以开始使用了： 点击Get Started即可进入到管理页面，我们可以看到目前有一个本地的Docker服务器正在运行： 我们可以点击进入，进行详细地管理，不过唯一缺点就是没中文，挺难受的，也可以使用非官方的汉化版本：https://hub.docker.com/r/6053537/portainer-ce。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:5:3","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"单机容器编排\r最后我们来讲解一下Docker-Compose，它能够对我们的容器进行编排。比如现在我们要在一台主机上部署很多种类型的服务，包括数据库、消息队列、SpringBoot应用程序若干，或是想要搭建一个MySQL集群，这时我们就需要创建多个容器来完成来，但是我们希望能够实现一键部署，这时该怎么办呢？我们就要用到容器编排了，让多个容器按照我们自己的编排进行部署。 **官方文档：**https://docs.docker.com/get-started/08_using_compose/，视频教程肯定不可能把所有的配置全部介绍完，所以如果各位小伙伴想要了解更多的配置，有更多需求的话，可以直接查阅官方文档。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:6:0","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"快速开始\r在Linux环境下我们需要先安装一下插件： sudo apt install docker-compose-plugin 接着输入docker compose version来验证一下是否安装成功。 这里我们就以部署SpringBoot项目为例，我们继续使用之前打包好的SpringBoot项目，现在我们希望部署这个SpringBoot项目的同时，部署一个MySQL服务器，一个Redis服务器，这时我们SpringBoot项目要运行的整个完整环境，先获取到对应的镜像： docker pull mysql/mysql-server docker pull redis 接着，我们需要在自己的本地安装一下DockerCompose，下载地址：https://github.com/docker/compose/releases，下载自己电脑对应的版本，然后在IDEA中配置： 下载完成后，将Docker Compose可执行文件路径修改为你存放刚刚下载的可执行文件的路径，Windows直接设置路径就行，MacOS下载之后需要进行下面的操作： mv 下载的文件名称 docker-compose sudo chmod 777 docker-compose sudo mv docker-compose /usr/local/bin 配置完成后就可以正常使用了，否则会无法运行，接着我们就可以开始在IDEA中编写docker-compose.yml文件了。 这里点击右上角的“与服务工具窗口同步”按钮，这样一会就可以在下面查看情况了。 我们现在就从头开始配置这个文件，现在我们要创建三个服务，一个是MySQL服务器，一个是Redis服务器，还有一个是SpringBoot服务器，需要三个容器来分别运行，首先我们先写上这三个服务： version: \"3.9\" #首先是版本号，别乱写，这个是和Docker版本有对应的 services: #services里面就是我们所有需要进行编排的服务了 spring: #服务名称，随便起 container_name: app_springboot #一会要创建的容器名称 mysql: container_name: app_mysql redis: container_name: app_redis 这样我们就配置好了一会要创建的三个服务和对应的容器名称，接着我们需要指定一下这些容器对应的镜像了，首先是我们的SpringBoot应用程序，可能我们后续还会对应用程序进行更新和修改，所以这里我们部署需要先由Dockerfile构建出镜像后，再进行部署： spring: container_name: app_springboot build: . #build表示使用构建的镜像，.表示使用当前目录下的Dockerfile进行构建 我们这里修改一下Dockerfile，将基础镜像修改为已经打包好JDK环境的镜像： FROM adoptopenjdk/openjdk8 COPY target/DockerTest-0.0.1-SNAPSHOT.jar app.jar CMD java -jar app.jar 接着是另外两个服务，另外两个服务需要使用对应的镜像来启动容器： mysql: container_name: app_mysql image: mysql/mysql-server:latest #image表示使用对应的镜像，这里会自动从仓库下载，然后启动容器 redis: container_name: app_redis image: redis:latest 还没有结束，我们还需要将SpringBoot项目的端口进行映射，最后一个简单的docker-compose配置文件就编写完成了： version: \"3.9\" #首先是版本号，别乱写，这个是和Docker版本有对应的 services: #services里面就是我们所有需要进行编排的服务了 spring: #服务名称，随便起 container_name: app_springboot #一会要创建的容器名称 build: . ports: - \"8080:8080\" mysql: container_name: app_mysql image: mysql/mysql-server:latest redis: container_name: app_redis image: redis:latest 现在我们就可以直接一键部署了，我们点击下方部署按钮： 看到 Running 4/4 就表示已经部署成功了，我们现在到服务器这边来看看情况： 可以看到，这里确实是按照我们的配置，创建了3个容器，并且都是处于运行中，可以正常访问： 如果想要结束的话，我们只需要点击停止就行了： 当然如果我们不再需要这套环境的话，可以直接点击下方的按钮，将整套编排给down掉，这样的话相对应的容器也会被清理的： 注意在使用docker-compose部署时，会自动创建一个新的自定义网络，并且所有的容器都是连接到这个自定义的网络里面： 这个网络默认也是使用bridge作为驱动： 这样，我们就完成了一个简单的配置，去部署我们的整套环境。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:6:1","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"部署完整项目\r前面我们学习了使用docker-compose进行简单部署，但是仅仅只是简单启动了服务，我们现在来将这些服务给连起来。首先是SpringBoot项目，我们先引入依赖： \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-jdbc\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003c/dependency\u003e 接着配置一下数据源，等等，我们怎么知道数据库的默认密码是多少呢？所以我们先配置一下MySQL服务： mysql: container_name: app_mysql image: mysql/mysql-server:latest environment: #这里我们通过环境变量配置MySQL的root账号和密码 MYSQL_ROOT_HOST: '%' #登陆的主机，这里直接配置为'%' MYSQL_ROOT_PASSWORD: '123456.root' #MySQL root账号的密码，别设定得太简单了 MYSQL_DATABASE: 'study' #在启动时自动创建的数据库 TZ: 'Asia/Shanghai' #时区 ports: - \"3306:3306\" #把端口暴露出来，当然也可以不暴露，因为默认所有容器使用的是同一个网络 有关MySQL的详细配置请查阅：https://registry.hub.docker.com/_/mysql 接着我们将数据源配置完成： spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://app_mysql:3306/study #地址直接输入容器名称，会自动进行解析，前面已经讲过了 username: root password: 123456.root 然后我们来写点测试的代码吧，这里我们使用JPA进行交互： \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-jpa\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003c/dependency\u003e @Data @AllArgsConstructor @NoArgsConstructor @Entity @Table(name = \"db_account\") public class Account { @Column(name = \"id\") @Id long id; @Column(name = \"name\") String name; @Column(name = \"password\") String password; } @Repository public interface AccountRepository extends JpaRepository\u003cAccount, Long\u003e { } @RestController public class MainController { @Resource AccountRepository repository; @RequestMapping(\"/\") public String hello(){ return \"Hello World!\"; } @GetMapping(\"/get\") public Account get(@RequestParam(\"id\") long id){ return repository.findById(id).orElse(null); } @PostMapping(\"/post\") public Account get(@RequestParam(\"id\") long id, @RequestParam(\"name\") String name, @RequestParam(\"password\") String password){ return repository.save(new Account(id, name, password)); } } 接着我们来修改一下配置文件： spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://app_mysql:3306/study username: root password: 123456.root jpa: database: mysql show-sql: true hibernate: ddl-auto: update #这里自动执行DDL创建表，全程自动化，尽可能做到开箱即用 现在代码编写完成后，我们可以将项目打包了，注意执行我们下面的打包命令，不要进行测试，因为连不上数据库： mvn package -DskipTests 重新生成jar包后，我们修改一下docker-compose配置，因为MySQL的启动速度比较慢，我们要一点时间等待其启动完成，如果连接不上数据库导致SpringBoot项目启动失败，我们就重启： spring: #服务名称，随便起 container_name: app_springboot #一会要创建的容器名称 build: . ports: - \"8080:8080\" depends_on: #这里设置一下依赖，需要等待mysql启动后才运行，但是没啥用，这个并不是等到启动完成后，而是进程建立就停止等待 - mysql restart: always #这里配置容器停止后自动重启 然后我们将之前自动构建的镜像删除，等待重新构建： 现在我们重新部署docker-compos吧： 当三个服务全部为蓝色时，就表示已经正常运行了，现在我们来测试一下吧： 接着我们来试试看向数据库传入数据： 可以看到响应成功，接着我们来请求一下： 这样，我们的项目和MySQL基本就是自动部署了。 接着我们来配置一下Redis： \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-redis\u003c/artifactId\u003e \u003c/dependency\u003e 接着配置连接信息： spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://app_mysql:3306/study username: root password: 123456.root jpa: database: mysql show-sql: true hibernate: ddl-auto: update redis: host: app_redis //再加两个Redis操作进来 @Resource StringRedisTemplate template; @GetMapping(\"/take\") public String take(@RequestParam(\"key\") String key){ return template.opsForValue().get(key); } @PostMapping(\"/put\") public String put(@RequestParam(\"key\") String key, @RequestParam(\"value\") String value){ template.opsForValue().set(key, value); return \"操作成功！\"; } 最后我们来配置一下docker-compose的配置文件： redis: container_name: app_redis image: redis:latest ports: - \"6379:6379\" OK，按照之前的方式，我们重新再部署一下，然后测试： 这样我们就完成整套环境+应用程序的配置了，我们在部署整个项目时，只需要使用docker-compose配置文件进行启动即可，这样就大大方便了我们的操作，实现开箱即用。甚至我们还可以专门使用一个平台来同时对多个主机进行一次性配置，大规模快速部署，而这些就留到以后的课程中再说吧。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:6:2","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"配置代理\r打开/usr/lib/systemd/system/docker.service，在[Service]域中添加以下参数： Environment=\"HTTP_PROXY=http://proxy-addr:port/\" # 代理服务器地址 Environment=\"HTTPS_PROXY=http://proxy-addr:port/\" # https Environment=\"NO_PROXY=localhost,127.0.0.1\" # 哪些地址不需要走代理 更新配置，启动服务\rsystemctl daemon-reload systemctl restart docker.service ","date":"2024-05-15","objectID":"/posts/7c3ddcd/:0:0","tags":["Docker"],"title":"Docker用代理拉取镜像","uri":"/posts/7c3ddcd/"},{"categories":["编译原理"],"content":" package main import ( \"bufio\" \"fmt\" \"os\" \"unicode\" ) var keywords = map[string]int{ \"begin\": 1, \"if\": 2, \"then\": 3, \"while\": 4, \"do\": 5, \"end\": 6, } func lexicalAnalysis(input string) { //词法分析程序 var p int = 0 scanner := func() (int, string) { var syn int var token string for p \u003c len(input) \u0026\u0026 input[p] == ' ' { p++ //跳过空格 } if unicode.IsLetter(rune(input[p])) { for p \u003c len(input) \u0026\u0026 (unicode.IsLetter(rune(input[p])) || unicode.IsDigit(rune(input[p]))) { //如果当前是字符，那么把它加入到token中 token += string(input[p]) p++ } _, ok := keywords[token] if ok { syn = keywords[token] } else { syn = 10 } } else { if unicode.IsDigit(rune(input[p])) { syn = 11 token = string(input[p]) p++ } else { switch input[p] { case '+': token = \"+\" syn = 13 p++ case '-': token = \"-\" syn = 14 p++ case '*': token = \"*\" syn = 15 p++ case '/': token = \"/\" syn = 16 p++ case ':': if p+1 \u003c len(input) \u0026\u0026 input[p+1] == '=' { syn = 18 token = \":=\" p += 2 } else { token = \":\" syn = 17 p++ } case '\u003c': if p+1 \u003c len(input) \u0026\u0026 input[p+1] == '\u003e' { syn = 21 token = \"\u003c\u003e\" p += 2 } else if p+1 \u003c len(input) \u0026\u0026 input[p+1] == '=' { syn = 22 token = \"\u003c=\" p += 2 } else { syn = 20 token = \"\u003c\" p++ } case '\u003e': if p+1 \u003c len(input) \u0026\u0026 input[p+1] == '=' { syn = 24 token = \"\u003e=\" p += 2 } else { syn = 23 token = \"\u003e\" p++ } case '=': syn = 25 token = \"=\" p++ case ';': syn = 26 token = \";\" p++ case '(': syn = 27 token = \"(\" p++ case ')': syn = 28 token = \")\" p++ case '#': syn = 0 token = \"#\" p++ default: syn = -1 token = string(input[p]) p++ } } } return syn, token } for p \u003c len(input) { syn, token := scanner() if syn == -1 { fmt.Println(\"错误：非法字符\", token) break } else { res := fmt.Sprintf(\"(%d,%s)\", syn, token) fmt.Print(res + \" \") } } } func main() { fmt.Printf(\"请输入代码段\\n\") reader := bufio.NewReader(os.Stdin) readBytes, _, _ := reader.ReadLine() var codeSegment string = string(readBytes) //input := \"begin x:=9;if x\u003e0 then x:=2*x+1/3;end#\" lexicalAnalysis(codeSegment) } ","date":"2024-05-15","objectID":"/posts/1e5f18a/:0:0","tags":["Go","编译原理"],"title":"Go实现词法分析器","uri":"/posts/1e5f18a/"},{"categories":["编译原理"],"content":" package main import ( \"bufio\" \"fmt\" \"os\" \"strings\" ) var ( str []byte pointer int error_str string = \"Error: 非法的符号串\" withNoSharp string = \"Error: 符号串必须以#结尾\" ) // 打印颜色设置 const Red = \"\\033[31m\" const Green = \"\\033[32m\" const Reset = \"\\033[0m\" const Yellow = \"\\033[33m\" func match(token byte) { if pointer \u003e= len(str) { errors(error_str) return } if str[pointer] == token { pointer++ } else { errors(error_str) } } func errors(info string) { fmt.Println(Red, info, Reset) os.Exit(0) } func E() { fmt.Println(\"E() -\u003e T() -\u003e G()\") T() G() } func T() { fmt.Println(\"T() -\u003e F() -\u003e S()\") F() S() } func G() { if str[pointer] == '+' { match('+') fmt.Println(\"G() -\u003e + -\u003e T() -\u003e G()\") T() G() } else if str[pointer] == '-' { match('-') fmt.Println(\"G() -\u003e - -\u003e T() -\u003e G()\") T() G() } else { fmt.Println(\"G() -\u003e epsilon\") } } func F() { if str[pointer] == 'i' { match('i') fmt.Println(\"F() -\u003e i\") } else if str[pointer] == '(' { match('(') fmt.Println(\"F() -\u003e ( -\u003e E()\") E() if pointer \u003c len(str) \u0026\u0026 str[pointer] == ')' { match(')') fmt.Println(\"F() -\u003e ( -\u003e E() -\u003e )\") } else { errors(\"Error: 缺少右括号\") } } else { errors(\"Error: 与i或者(不匹配\") } } func S() { if str[pointer] == '*' { match('*') fmt.Println(\"S() -\u003e * -\u003e F() -\u003e S()\") F() S() } else if str[pointer] == '/' { match('/') fmt.Println(\"S() -\u003e / -\u003e F() -\u003e S()\") F() S() } else { fmt.Println(\"S() -\u003e epsilon\") } } func checkSuccess() { if pointer == len(str)-1 \u0026\u0026 str[pointer] == '#' { fmt.Println(Green, string(str), \"Success: 符号串匹配成功\", Reset) } else { errors(error_str) } os.Exit(0) } func main() { fmt.Println(Yellow, \"编制人: \", Reset) scanner := bufio.NewScanner(os.Stdin) fmt.Println(Yellow, \"请输入符号串:\", Reset) if scanner.Scan() { input := scanner.Text() if !strings.HasSuffix(input, \"#\") { //判断是否以#结尾 errors(withNoSharp) return } str = []byte(input) fmt.Println(\"读入的字符串为:\", string(str)) E() checkSuccess() } if err := scanner.Err(); err != nil { fmt.Fprintln(os.Stderr, \"读取输入时发生错误:\", err) } } ","date":"2024-05-15","objectID":"/posts/274359a/:0:0","tags":["编译原理","Go"],"title":"Go实现递归向下分析","uri":"/posts/274359a/"},{"categories":["Go"],"content":"Go数组和切片练习\r数组\r","date":"2024-05-15","objectID":"/posts/4e31f59/:0:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习1：证明当数组赋值时，发生了数组内存拷贝。\rpackage main import \"fmt\" func main() { arr1 := new([5]int) arr2 := arr1 arr2[1] = 3 fmt.Println(arr1) //\u0026[0 3 0 0 0] fmt.Println(arr2) //\u0026[0 3 0 0 0] arr3 := [5]int{1, 2, 3, 4, 5} arr4 := \u0026arr3 //使用\u0026获取地址，修改arr4也会修改arr3 arr4[2] = 6 fmt.Println(arr3) //[1 2 6 4 5] fmt.Println(arr4) //[1 2 6 4 5] arr5 := [5]int{1, 2, 3, 4, 5} arr6 := arr5 //会进行拷贝 arr6[1] = 9 fmt.Println(arr5) //[1 2 3 4 5] fmt.Println(arr6) //[1 9 3 4 5] } ","date":"2024-05-15","objectID":"/posts/4e31f59/:1:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习2:写一个循环并用下标给数组赋值（从 0 到 15）并且将数组打印在屏幕上。\rpackage main import \"fmt\" func main() { var arr [16]int for i := 0; i \u003c 16; i++ { arr[i] = i } for _, v := range arr { fmt.Print(v, \" \") } /* 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 进程 已完成，退出代码为 0 */ } ","date":"2024-05-15","objectID":"/posts/4e31f59/:2:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习3：通过数组我们可以更快的计算出 Fibonacci 数。完成该方法并打印出前 50 个 Fibonacci 数字。\rpackage main import \"fmt\" func fibonacci(n int) []int { fib := make([]int, n+1) fib[0], fib[1] = 0, 1 for i := 2; i \u003c= n; i++ { fib[i] = fib[i-1] + fib[i-2] } return fib } func main() { n := 50 var fibSeq []int = fibonacci(n) for _, v := range fibSeq { fmt.Print(v, \" \") } } 切片\r","date":"2024-05-15","objectID":"/posts/4e31f59/:3:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习4： 给定切片 sl，将一个 []byte 数组追加到 sl 后面。写一个函数 Append(slice, data []byte) []byte，该函数在 sl 不能存储更多数据的时候自动扩容。\rpackage main import \"fmt\" // 给定切片 sl，将一个 []byte 数组追加到 sl 后面。写一个函数 Append(slice, data []byte) []byte，该函数在 sl 不能存储更多数据的时候自动扩容。 func Append(originByteSlice, data []byte) []byte { originLen := len(originByteSlice) originCap := cap(originByteSlice) appendLen := len(data) var newByteSlice []byte // 判断原切片容量是否足够 if originLen+appendLen \u003e originCap { // 不够时，计算新切片的容量 newCapacity := (originLen + appendLen) * 2 // 创建新切片并复制原切片内容 newByteSlice = make([]byte, originLen+appendLen, newCapacity) copy(newByteSlice, originByteSlice) } else { // 容量足够时，只需引用原切片 newByteSlice = originByteSlice[:originLen+appendLen] } // 将data切片的内容复制到新切片的后面，实现追加 copy(newByteSlice[originLen:], data) return newByteSlice } func Append2(originByteSlice, data []byte) []byte { originLen := len(originByteSlice) originCap := cap(originByteSlice) appendLen := len(data) // 判断原切片容量是否足够 if originLen+appendLen \u003e originCap { // 不够时，计算新切片的容量（这里简单地设置为两倍于原切片长度加上追加长度） newCapacity := (originLen + appendLen) * 2 // 创建新切片并复制原切片内容 newByteSlice := make([]byte, originLen+appendLen, newCapacity) copy(newByteSlice, originByteSlice) originByteSlice = newByteSlice } // 更新切片的长度 originByteSlice = originByteSlice[:originLen+appendLen] // 将data切片的内容复制到原切片的后面，实现追加 copy(originByteSlice[originLen:], data) return originByteSlice } func main() { slice := []byte{'a', 'c', 'e', 'g', 'i'} res := Append2(slice, []byte{'m', 'm'}) res1 := Append2(res, []byte{'f', 'n'}) for _, b := range res1 { fmt.Printf(\"%q \", b) } } ‘a’ ‘c’ ’e’ ‘g’ ‘i’ ’m’ ’m’ ‘f’ ’n’ ","date":"2024-05-15","objectID":"/posts/4e31f59/:4:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习5：把一个缓存 buf 分片成两个切片：第一个是前 n 个 bytes，后一个是剩余的，用一行代码实现。\rpackage main import ( \"bytes\" \"fmt\" ) func main() { var buffer bytes.Buffer var n int = 3 buffer.WriteString(\"helloworld\") bytesBeforeN, bytesAfterN := buffer.Bytes()[:n], buffer.Bytes()[n:] for _, v := range bytesBeforeN { fmt.Printf(\"%c\", v) } fmt.Println() for _, v := range bytesAfterN { fmt.Printf(\"%c\", v) } } hel loworld ","date":"2024-05-15","objectID":"/posts/4e31f59/:5:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习5：遍历多维切片，使用for-range\rpackage main import \"fmt\" func main() { slice := make([][]int, 4) slice[0] = []int{1, 2, 3} slice[1] = []int{4, 5, 6} slice[2] = []int{7, 8, 9} slice[3] = []int{10, 11, 12} for row := range slice { for col := range slice[row] { fmt.Print(slice[row][col]) } } } ","date":"2024-05-15","objectID":"/posts/4e31f59/:6:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习6：通过使用省略号操作符 ... 来实现累加方法。\rpackage main import \"fmt\" func add(array ...int) int { var res int = 0 for _, b := range array { res += b } return res } func main() { var res int = add(1, 2, 3, 4, 5, 6) fmt.Println(res) } ","date":"2024-05-15","objectID":"/posts/4e31f59/:7:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习7：给定一个切片 s []int 和一个 int 类型的因子 factor，扩展 s 使其长度为 len(s) * factor。\r// 给定一个切片 `s []int` 和一个 `int` 类型的因子 `factor`，扩展 `s` 使其长度为 `len(s) * factor`。 package main import \"fmt\" func enlarge(s *[]int, factor int) { ns := make([]int, len(*s)*factor) copy(ns, *s) *s = ns } func main() { var s []int = []int{1, 2, 3} fmt.Println(\"The length of s before enlarging is:\", len(s)) fmt.Println(s) enlarge(\u0026s, 5) fmt.Println(\"The length of s after enlarging is:\", len(s)) fmt.Println(s) } ","date":"2024-05-15","objectID":"/posts/4e31f59/:8:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习8:用顺序函数过滤容器：s 是前 10 个整型的切片。构造一个函数 Filter，第一个参数是 s，第二个参数是一个 fn func(int) bool，返回满足函数 fn 的元素切片。通过 fn 测试方法测试当整型值是偶数时的情况\rpackage main import \"fmt\" func Filter(s []int, fn func(int) bool) []int { var result []int for _, v := range s { if fn(v) { result = append(result, v) } } return result } func main() { s := []int{1, 2, 3, 4, 5, 6} fn := func(i int) bool { return i%2 == 0 } res := Filter(s, fn) fmt.Println(res) } ","date":"2024-05-15","objectID":"/posts/4e31f59/:9:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习9:写一个函数 InsertStringSlice() 将切片插入到另一个切片的指定位置。\r// 写一个函数 InsertStringSlice() 将切片插入到另一个切片的指定位置。 package main import \"fmt\" func InsertIntSlice(src *[]int, dst *[]int, index int) { newSlice := make([]int, len(*src)+len(*dst)) at := copy(newSlice, (*src)[:index]) at += copy(newSlice[at:], (*dst)[:]) copy(newSlice[at:], (*src)[index:]) //for i, v := range *src { // newSlice[i] = v //} //for i := len(*src) + len(*dst) - 1; i \u003e= index+len(*dst); i-- { // newSlice[i] = newSlice[i-len(*dst)] //} //copy(newSlice[index:], *dst) *src = newSlice } func InsertStringSlice(src *[]string, dst *[]string, index int) { newSlice := make([]string, len(*src)+len(*dst)) at := copy(newSlice, (*src)[:index]) at += copy(newSlice[at:], (*dst)[:]) copy(newSlice[at:], (*src)[index:]) *src = newSlice } func main() { src := []int{1, 2, 3, 4, 5, 6, 7, 8, 9} dst := []int{12, 13} InsertIntSlice(\u0026src, \u0026dst, 2) fmt.Println(src) s := []string{\"M\", \"N\", \"O\", \"P\", \"Q\", \"R\"} in := []string{\"A\", \"B\", \"C\"} InsertStringSlice(\u0026s, \u0026in, 3) // at the front fmt.Println(s) } [1 2 12 13 3 4 5 6 7 8 9] ","date":"2024-05-15","objectID":"/posts/4e31f59/:10:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习10:写一个函数 RemoveStringSlice() 将从 start 到 end 索引的元素从切片中移除。\r// 写一个函数 RemoveStringSlice() 将从 start 到 end 索引的元素从切片中移除。 package main import \"fmt\" func RemoveStringSlice(source *[]string, start, end int) { tempSlice := make([]string, len(*source)) at := copy(tempSlice, (*source)[0:start]) copy(tempSlice[at:], (*source)[end+1:]) tempSlice = tempSlice[:(len(*source) - end + start - 1)] *source = tempSlice } func main() { src := []string{\"meowrain\", \"hello\", \"world\", \"thanks\", \"meow\", \"miku\", \"aww\"} RemoveStringSlice(\u0026src, 0, 4) fmt.Println(src) } ","date":"2024-05-15","objectID":"/posts/4e31f59/:11:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习11：从字符串生成切片\rpackage main import \"fmt\" func main() { var s string = \"helloworld\" Stringslice := []byte(s) fmt.Println(Stringslice) } ","date":"2024-05-15","objectID":"/posts/4e31f59/:12:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习12：修改字符串中的某个字符\rpackage main import \"fmt\" func main() { var str string = \"helloworld\" slice := []byte(str) slice[2] = 'e' str = string(slice) fmt.Println(str) } 字符串\r","date":"2024-05-15","objectID":"/posts/4e31f59/:13:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习13：编写一个函数，要求其接受两个参数，原始字符串 str 和分割索引 i，然后返回两个分割后的字符串。\rpackage main // 练习13：编写一个函数，要求其接受两个参数，原始字符串 str 和分割索引 i，然后返回两个分割后的字符串。 func splitString(str string, i int) (string, string) { if i \u003c 0 || i \u003e= len(str) { return \"\", \"\" } return str[:i], str[i:] } func main() { str := \"helloworld\" i := 5 s1, s2 := splitString(str, i) println(s1, s2) } ","date":"2024-05-15","objectID":"/posts/4e31f59/:14:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习14：假设有字符串 str，那么 str[len(str)/2:] + str[:len(str)/2] 的结果是什么？\rpackage main func main() { str := \"helloworld\" strslice := str[len(str)/2:] + str[:len(str)/2] println(strslice) //worldhello } ","date":"2024-05-15","objectID":"/posts/4e31f59/:15:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习15:编写一个程序，要求能够反转字符串，即将 “Google” 转换成 “elgooG”（提示：使用 []byte 类型的切片）。\r如果您使用两个切片来实现反转，请再尝试使用一个切片（提示：使用交换法）。 如果您想要反转 Unicode 编码的字符串，请使用 []int32 类型的切片。 // 编写一个程序，要求能够反转字符串，即将 \"Google\" 转换成 \"elgooG\"（提示：使用 []byte 类型的切片）。 // // 如果您使用两个切片来实现反转，请再尝试使用一个切片（提示：使用交换法）。 // // 如果您想要反转 Unicode 编码的字符串，请使用 []int32 类型的切片。 package main import ( \"fmt\" \"strings\" ) func reverseString(s string) string { b := []byte(s) for i, j := 0, len(b)-1; i \u003c j; i, j = i+1, j-1 { b[i], b[j] = b[j], b[i] } return string(b) } func reverseStringVersion2(s string) string { str := strings.Builder{} for i := len(s) - 1; i \u003e= 0; i-- { str.WriteByte(s[i]) } return str.String() } func main() { s := \"Google\" //s = reverseString(s) s = reverseStringVersion2(s) fmt.Println(s) } ","date":"2024-05-15","objectID":"/posts/4e31f59/:16:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习16：编写一个程序，要求能够遍历一个字符数组，并将当前字符和前一个字符不相同的字符拷贝至另一个数组。\r// Q29_uniq.go package main import \"fmt\" var arr []byte = []byte{'a', 'b', 'a', 'a', 'a', 'c', 'd', 'e', 'f', 'g'} func main() { arru := make([]byte, len(arr)) // this will contain the unique items idx := 0 for i, j := 0, 1; i \u003c len(arr) \u0026\u0026 j \u003c len(arr); i, j = i+1, j+1 { // 在这里执行循环体的操作 if arr[i] != arr[j] { arru[idx] = arr[i] idx++ } } for i := 0; i \u003c idx; i++ { fmt.Printf(\"%c \", arru[i]) //a b a c d e f } } ","date":"2024-05-15","objectID":"/posts/4e31f59/:17:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习17:写一个程序，使用冒泡排序的方法排序一个包含整数的切片（算法的定义可参考 维基百科）。\rpackage main import \"fmt\" func bubbleSort(arr []int) []int { for i := 0; i \u003c len(arr)-1; i++ { for j := 0; j \u003c len(arr)-i-1; j++ { if arr[j] \u003e arr[j+1] { arr[j], arr[j+1] = arr[j+1], arr[j] } } } return arr } func bubbleSortPointerVersion(arr *[]int) { for i := 0; i \u003c len(*arr)-1; i++ { for j := 0; j \u003c len(*arr)-i-1; j++ { if (*arr)[j] \u003e (*arr)[j+1] { (*arr)[j], (*arr)[j+1] = (*arr)[j+1], (*arr)[j] } } } } func main() { arr := []int{5, 2, 8, 3, 9, 1} // 2 5 8 3 9 1 // 2 5 3 8 9 1 // 2 5 3 8 1 9 // ----- // 2 3 5 8 1 9 // 2 3 5 1 8 9 // ---- // 2 3 1 5 8 9 //--- // 2 1 3 5 8 9 //---- // 1 2 3 5 8 9 sortedArr := bubbleSort(arr) fmt.Println(sortedArr) bubbleSortPointerVersion(\u0026arr) fmt.Println(arr) } ","date":"2024-05-15","objectID":"/posts/4e31f59/:18:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"Go 接口\r","date":"2024-05-15","objectID":"/posts/b3efa23/:0:0","tags":["Go","Go接口"],"title":"Go接口","uri":"/posts/b3efa23/"},{"categories":["Go"],"content":"接口定义\rGo语言提倡面向接口编程。 ","date":"2024-05-15","objectID":"/posts/b3efa23/:1:0","tags":["Go","Go接口"],"title":"Go接口","uri":"/posts/b3efa23/"},{"categories":["Go"],"content":"指针接收者实现接口\rpackage main import \"fmt\" // 接口定义 type USB interface { Connect() Disconnect() } type Laptop struct { name string version string } type Desktop struct { name string version string } // 实现USB接口 func (laptop *Laptop) Connect() { fmt.Println(\"USB Connecting to\", laptop.name) } func (laptop *Laptop) Disconnect() { fmt.Println(\"USB Disconnecting from\", laptop.name) } func (desktop *Desktop) Connect() { fmt.Println(\"USB Connecting to\", desktop.name) } func (desktop *Desktop) Disconnect() { fmt.Println(\"USB Disconnecting from\", desktop.name) } func main() { var legion_laptop Laptop = Laptop{ name: \"Legion Y7000P\", version: \"2022\", } var legion_desktop2 *Desktop = \u0026Desktop{ name: \"Legion Y9000P\", version: \"2023\", } var legion_desktop Desktop = Desktop{ name: \"Legion Desktop Computer\", version: \"2023\", } var x USB = legion_laptop x.Disconnect() x.Connect() x = legion_desktop2 x.Connect() x.Disconnect() x = legion_desktop x.Connect() x.Disconnect() } 当我们写成这样的时候，可以看到 也就是说，当我们使用指针接收者的时候，是不能传递结构体变量给接口变量的 ","date":"2024-05-15","objectID":"/posts/b3efa23/:2:0","tags":["Go","Go接口"],"title":"Go接口","uri":"/posts/b3efa23/"},{"categories":["Go"],"content":"值接收者实现接口\rpackage main import \"fmt\" // 接口定义 type USB interface { Connect() Disconnect() } type Laptop struct { name string version string } type Desktop struct { name string version string } // 实现USB接口 func (laptop Laptop) Connect() { fmt.Println(\"USB Connecting to\", laptop.name) } func (laptop Laptop) Disconnect() { fmt.Println(\"USB Disconnecting from\", laptop.name) } func (desktop Desktop) Connect() { fmt.Println(\"USB Connecting to\", desktop.name) } func (desktop Desktop) Disconnect() { fmt.Println(\"USB Disconnecting from\", desktop.name) } func main() { var legion_laptop Laptop = Laptop{ name: \"Legion Y7000P\", version: \"2022\", } var legion_desktop2 *Desktop = \u0026Desktop{ name: \"Legion Y9000P\", version: \"2023\", } var legion_desktop Desktop = Desktop{ name: \"Legion Desktop Computer\", version: \"2023\", } var x USB = legion_laptop x.Disconnect() x.Connect() x = legion_desktop2 x.Connect() x.Disconnect() x = legion_desktop x.Connect() x.Disconnect() } 我们可以发现，使用值接收者实现接口之后，不管是Laptop的结构体还是其结构体指针，都可以赋值给接口变量 ","date":"2024-05-15","objectID":"/posts/b3efa23/:3:0","tags":["Go","Go接口"],"title":"Go接口","uri":"/posts/b3efa23/"},{"categories":["Go"],"content":"一个类型实现多个接口\r一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现 package main import \"fmt\" type Payer interface { Pay() } type Talker interface { Talk() } type AliPay struct { } type Wechat struct { } func (w Wechat) Pay() { fmt.Println(\"Wechat Pay\") } func (w Wechat) Talk() { fmt.Println(\"Wechat Talk\") } func (a AliPay) Pay() { fmt.Println(\"AliPay Pay\") } func (a AliPay) Talk() { fmt.Println(\"AliPay Talk\") } func main() { var payer Payer = AliPay{} payer.Pay() payer = Wechat{} payer.Pay() var talker Talker = Wechat{} talker.Talk() talker = AliPay{} talker.Talk() } ","date":"2024-05-15","objectID":"/posts/b3efa23/:4:0","tags":["Go","Go接口"],"title":"Go接口","uri":"/posts/b3efa23/"},{"categories":["Go"],"content":"接口嵌套\r接口与接口间可以通过嵌套创造出新的接口。 package main import \"fmt\" type Payer interface { Pay() } type Talker interface { Talk() } type AliPay struct { } type Wechat struct { } type Tooler interface { Payer Talker } func (w Wechat) Pay() { fmt.Println(\"Wechat Pay\") } func (w Wechat) Talk() { fmt.Println(\"Wechat Talk\") } func (a AliPay) Pay() { fmt.Println(\"AliPay Pay\") } func (a AliPay) Talk() { fmt.Println(\"AliPay Talk\") } func main() { var tool Tooler = AliPay{} tool.Talk() tool.Pay() tool = Wechat{} tool.Talk() tool.Pay() } ","date":"2024-05-15","objectID":"/posts/b3efa23/:5:0","tags":["Go","Go接口"],"title":"Go接口","uri":"/posts/b3efa23/"},{"categories":["Go"],"content":"空接口\r空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。 空接口类型的变量可以存储任意类型的变量。 package main import \"fmt\" func show(anything interface{}) { fmt.Println(anything) } type Animal struct { name string age int } func main() { show(\"fdsafdasf\") show(123) show(Animal{ \"neko\", 12, }) } 可以用any来替代 空接口还可以作为map的value值 package main import \"fmt\" func main() { var studentInfo = make(map[string]interface{}) //var studentInfo = make(map[string]any) studentInfo[\"name\"] = \"meowrain\" studentInfo[\"age\"] = 12 studentInfo[\"hobby\"] = \"play computer\" fmt.Println(studentInfo) } ","date":"2024-05-15","objectID":"/posts/b3efa23/:6:0","tags":["Go","Go接口"],"title":"Go接口","uri":"/posts/b3efa23/"},{"categories":["Go"],"content":"类型断言\r","date":"2024-05-15","objectID":"/posts/b3efa23/:7:0","tags":["Go","Go接口"],"title":"Go接口","uri":"/posts/b3efa23/"},{"categories":["Go"],"content":"接口值\r一个接口的值（简称接口值）是由一个具体类型和具体类型的值两部分组成的。这两部分分别称为接口的动态类型和动态值。 判断空接口中的这个值可以用类型断言 x.(T) package main import \"fmt\" func show(anything interface{}) { v, ok := anything.(string) if ok { fmt.Println(v) } else { fmt.Println(\"not string\") } } func main() { show(\"fdsfdsafa\") show(23) } ","date":"2024-05-15","objectID":"/posts/b3efa23/:7:1","tags":["Go","Go接口"],"title":"Go接口","uri":"/posts/b3efa23/"},{"categories":["Go"],"content":" 参考文档：https://www.liwenzhou.com/posts/Go/file/ ","date":"2024-05-15","objectID":"/posts/17ec745/:0:0","tags":["Go","Go文件读写"],"title":"Go文件读写","uri":"/posts/17ec745/"},{"categories":["Go"],"content":"读取文件\rpackage main import ( \"fmt\" \"io\" \"os\") func main() { file, err := os.Open(\"./data.txt\") if err != nil { fmt.Println(\"open file err:\", err) return } defer file.Close() var tmp = make([]byte, 1024) n, err := file.Read(tmp) if err == io.EOF { fmt.Println(\"文件读取完毕\") return } fmt.Printf(\"读取了%d字节数据\\n\", n) fmt.Println(string(tmp)) } 上面这个代码只是读取了文件中的1024个字节，并没有读取完文件内的所有内容，下面我们使用循环读取将文件全部读取 package main import ( \"fmt\" \"io\" \"os\") func main() { file, err := os.Open(\"./data.txt\") if err != nil { fmt.Println(\"open file err:\", err) return } defer file.Close() var content []byte var tmp = make([]byte, 10) var sumByte int for { n, err := file.Read(tmp) if err == io.EOF { fmt.Println(\"文件读取完毕\") break } if err != nil { fmt.Println(\"read file failed\", err) return } sumByte += n content = append(content, tmp[:n]...) } fmt.Println(string(content)) fmt.Println(\"读取了\", sumByte, \"字节\") } ","date":"2024-05-15","objectID":"/posts/17ec745/:1:0","tags":["Go","Go文件读写"],"title":"Go文件读写","uri":"/posts/17ec745/"},{"categories":["Go"],"content":"bufio读取文件\rbufio是在file的基础上封装了一层API，支持更多的功能。 package main import ( \"bufio\" \"fmt\" \"io\" \"os\") func main() { file, err := os.Open(\"data.txt\") if err != nil { fmt.Println(\"file open failed\", err) return } defer file.Close() reader := bufio.NewReader(file) for { line, err := reader.ReadString('\\n') if err == io.EOF { if len(line) != 0 { fmt.Println(line) } fmt.Println(\"文件读完了\") break } if err != nil { fmt.Println(\"read file err:\", err) return } fmt.Println(line) } } ","date":"2024-05-15","objectID":"/posts/17ec745/:1:1","tags":["Go","Go文件读写"],"title":"Go文件读写","uri":"/posts/17ec745/"},{"categories":["Go"],"content":"os.ReadFIle读取整个文件\rpackage main import ( \"fmt\" \"os\") func main() { content, err := os.ReadFile(\"./data.txt\") if err != nil { fmt.Println(\"read file failed:\", err) return } fmt.Println(string(content)) } ","date":"2024-05-15","objectID":"/posts/17ec745/:1:2","tags":["Go","Go文件读写"],"title":"Go文件读写","uri":"/posts/17ec745/"},{"categories":["Go"],"content":"文件写入\r","date":"2024-05-15","objectID":"/posts/17ec745/:2:0","tags":["Go","Go文件读写"],"title":"Go文件读写","uri":"/posts/17ec745/"},{"categories":["Go"],"content":"Write和WriteString\rpackage main import ( \"fmt\" \"os\") func main() { file, err := os.OpenFile(\"./data.txt\", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666) if err != nil { fmt.Println(\"file open failed err:\", err) return } defer file.Close() str := \"good\" file.Write([]byte(str)) //file.WriteString(str) } ","date":"2024-05-15","objectID":"/posts/17ec745/:2:1","tags":["Go","Go文件读写"],"title":"Go文件读写","uri":"/posts/17ec745/"},{"categories":["Go"],"content":"使用os.WriteFile函数\rpackage main import ( \"fmt\" \"os\") func main() { str := \"helloworld\" err := os.WriteFile(\"./data.txt\", []byte(str), 0666) if err != nil { fmt.Println(\"write file failed, err : \", err) return } } Practice\r复制一个文件中的内容到另一个文件 package main import ( \"fmt\" \"io\" \"os\") func main() { src, err := os.OpenFile(\"data.txt\", os.O_RDONLY, 0666) if err != nil { fmt.Println(\"open file failed,err\", err) return } defer src.Close() var content []byte buf := make([]byte, 1024) for { n, err := src.Read(buf) if err == io.EOF { break } content = append(content, buf[:n]...) } dst, err := os.OpenFile(\"copy.txt\", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666) if err != nil { fmt.Println(\"open file failed,err\", err) return } dst.Write(content) defer dst.Close() } 其实可以用系统的io.Copy函数 package main import ( \"fmt\" \"io\" \"os\") func CopyFile(source, destination string) { src, err := os.OpenFile(source, os.O_RDONLY, 0666) if err != nil { fmt.Println(\"open file failed,err\", err) return } defer src.Close() dst, err := os.OpenFile(destination, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666) if err != nil { fmt.Println(\"open file failed,err\", err) return } defer dst.Close() _, err = io.Copy(dst, src) if err != nil { fmt.Println(\"copy file failed,err: \", err) return } } func main() { var source string = \"data.txt\" var destination string = \"copy.txt\" CopyFile(source, destination) } ","date":"2024-05-15","objectID":"/posts/17ec745/:2:2","tags":["Go","Go文件读写"],"title":"Go文件读写","uri":"/posts/17ec745/"},{"categories":["Go"],"content":"用go实现cat基本功能\rpackage main import ( \"fmt\" \"os\") func main() { if len(os.Args) \u003c 2 { fmt.Println(\"Usage: cat \u003cfilename\u003e\") return } filename := os.Args[1] content, err := os.ReadFile(filename) if err != nil { fmt.Println(\"open file failed,err: \", err) return } fmt.Printf(\"%v\", string(content)) } ","date":"2024-05-15","objectID":"/posts/17ec745/:3:0","tags":["Go","Go文件读写"],"title":"Go文件读写","uri":"/posts/17ec745/"},{"categories":["Go"],"content":"用go实现拷贝文件到另一个文件\rpackage main import ( \"io\" \"os\" ) func CopyFile(dstName, srcName string) error { src, err := os.Open(srcName) if err != nil { return err } defer src.Close() dst, err := os.Create(dstName) if err != nil { return err } defer dst.Close() _, err = io.Copy(dst, src) if err != nil { return err } return nil } func main() { CopyFile(\"./test.txt\", \"./go.mod\") } ","date":"2024-05-15","objectID":"/posts/17ec745/:4:0","tags":["Go","Go文件读写"],"title":"Go文件读写","uri":"/posts/17ec745/"},{"categories":null,"content":" Hi there 👋,I’m MeowRain.From SXAU.\r","date":"2024-05-15","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"About\r大家好，我是MeowRain ❤️(●’◡’●)今年20岁了，读大二。 热爱开源！ 梦想着成为一个和棒的程序猿(๑•̀ㅂ•́)و✧，在为自己的目标努力着！！ ","date":"2024-05-15","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Learning\r目前正在学习Android应用开发，短期目标为做两个App ","date":"2024-05-15","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"IDE\u0026Editor\r","date":"2024-05-15","objectID":"/about/:3:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"💻System-using\r现在主要使用Fedora ","date":"2024-05-15","objectID":"/about/:4:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Links\r欢迎访问我的博客！ Meowrain’s Blog ","date":"2024-05-15","objectID":"/about/:5:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Stats\r","date":"2024-05-15","objectID":"/about/:6:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Languages\r","date":"2024-05-15","objectID":"/about/:7:0","tags":null,"title":"About","uri":"/about/"},{"categories":["Go"],"content":"Go语言Web框架Gin","date":"2024-05-15","objectID":"/posts/31a491d/","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"Go语言 Web框架Gin\r参考 https://docs.fengfengzhidao.com https://www.liwenzhou.com/posts/Go/gin/#c-0-7-2 返回各种值\r","date":"2024-05-15","objectID":"/posts/31a491d/:0:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"返回字符串\rpackage main import ( \"net/http\" \"github.com/gin-gonic/gin\" ) func main() { router := gin.Default() router.GET(\"/\", func(c *gin.Context) { c.String(http.StatusOK, \"helloworld\") }) router.Run(\":8080\") } ","date":"2024-05-15","objectID":"/posts/31a491d/:1:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"返回json\rpackage main import ( \"net/http\" \"github.com/gin-gonic/gin\" ) type Student struct { Name string `json:\"name\"` Age int `json:\"age\"` Number string `json: \"number\"` } func main() { router := gin.Default() router.GET(\"/\", func(c *gin.Context) { var student Student = Student{ Name: \"meowrain\", Age: 20, Number: \"10086\", } c.JSON(http.StatusOK, student) }) router.Run(\":8080\") } ","date":"2024-05-15","objectID":"/posts/31a491d/:2:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"返回map\rpackage main import ( \"net/http\" \"github.com/gin-gonic/gin\" ) func main() { router := gin.Default() router.GET(\"/\", func(c *gin.Context) { userMap := map[string]any{ \"username\": \"meowrain\", \"age\": 20, \"number\": 10086, } c.JSON(http.StatusOK, userMap) }) router.Run(\":8080\") } ","date":"2024-05-15","objectID":"/posts/31a491d/:3:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"返回原始json\rpackage main import ( \"net/http\" \"github.com/gin-gonic/gin\" ) func main() { router := gin.Default() router.GET(\"/\", func(c *gin.Context) { c.JSON(http.StatusOK, gin.H{ \"username\": \"meowrain\", \"age\": 20, \"number\": 10086, }) }) router.Run(\":8080\") } ","date":"2024-05-15","objectID":"/posts/31a491d/:4:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"返回html并传递参数\rpackage main import ( \"net/http\" \"github.com/gin-gonic/gin\" ) func _html(c *gin.Context) { type UserInfo struct { Username string `json:\"username\"` Age int `json:\"age\"` Password string `json:\"-\"` } user := UserInfo{ Username: \"meowrain\", Age: 20, Password: \"12345678\", } c.HTML(http.StatusOK, \"index.html\", gin.H{\"obj\": user}) } func main() { router := gin.Default() router.LoadHTMLGlob(\"template/*\") router.GET(\"/\", _html) router.Run(\":8080\") } \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eUser Information\u003c/h1\u003e \u003cp\u003eUsername: {{.obj.Username}}\u003c/p\u003e \u003cp\u003eAge: {{.obj.Age}}\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2024-05-15","objectID":"/posts/31a491d/:5:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"静态文件配置\rrouter.Static和router.StaticFS都是用于处理静态文件的 Gin 框架路由处理方法，但它们有一些区别。 router.Static: 使用 router.Static 时，Gin 会简单地将请求的 URL 路径与提供的本地文件系统路径进行映射。通常，这适用于将 URL 路径直接映射到一个静态文件或目录。 示例：router.Static(\"/static\", \"./static\") 将 /static 映射到当前工作目录下的 ./static 文件夹。 router.StaticFS: router.StaticFS 则允许你使用 http.FileSystem 对象，这可以提供更多的灵活性。你可以使用 http.Dir 创建 http.FileSystem，并将其传递给 router.StaticFS。 这允许你更灵活地处理静态文件，例如从不同的源（内存、数据库等）加载静态文件，而不仅限于本地文件系统。 示例：router.StaticFS(\"/static\", http.Dir(\"/path/to/static/files\")) 使用本地文件系统路径创建一个 http.FileSystem 对象，然后将 /static 映射到这个文件系统。 总体而言，router.Static更简单，适用于基本的静态文件服务，而router.StaticFS提供了更多的灵活性，允许你自定义静态文件的加载方式。选择使用哪一个取决于你的具体需求。 package main import ( \"net/http\" \"github.com/gin-gonic/gin\" ) func _html(c *gin.Context) { type UserInfo struct { Username string `json:\"username\"` Age int `json:\"age\"` Password string `json:\"-\"` } user := UserInfo{ Username: \"meowrain\", Age: 20, Password: \"12345678\", } c.HTML(http.StatusOK, \"index.html\", gin.H{\"obj\": user}) } func main() { router := gin.Default() router.LoadHTMLGlob(\"template/*\") router.Static(\"/static/\", \"./static\") router.GET(\"/\", _html) router.Run(\":8080\") } \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eUser Information\u003c/h1\u003e \u003cp\u003eUsername: {{.obj.Username}}\u003c/p\u003e \u003cp\u003eAge: {{.obj.Age}}\u003c/p\u003e \u003cimg src=\"/static/c68a16221f5bdf5486749d0993052981178827471.jpg\" /\u003e \u003c/body\u003e \u003c/html\u003e 重定向\rpackage main import ( \"net/http\" \"github.com/gin-gonic/gin\" ) func _html(c *gin.Context) { type UserInfo struct { Username string `json:\"username\"` Age int `json:\"age\"` Password string `json:\"-\"` } user := UserInfo{ Username: \"meowrain\", Age: 20, Password: \"12345678\", } c.HTML(http.StatusOK, \"index.html\", gin.H{\"obj\": user}) } func _redirect(c *gin.Context) { c.Redirect(301, \"https://www.baidu.com\") } func main() { router := gin.Default() router.LoadHTMLGlob(\"template/*\") router.Static(\"/static/\", \"./static\") router.GET(\"/\", _html) router.GET(\"/baidu\", _redirect) router.Run(\":8080\") } ","date":"2024-05-15","objectID":"/posts/31a491d/:5:1","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"301和302的区别\rHTTP状态码中的301和302分别表示重定向（Redirect）。它们之间的主要区别在于重定向的性质和原因： 301 Moved Permanently（永久重定向）: 当服务器返回状态码301时，它告诉客户端请求的资源已经被永久移动到新的位置。 客户端收到301响应后，应该更新书签、链接等，将这个新的位置作为将来所有对该资源的请求的目标。 搜索引擎在遇到301时，通常会更新索引，将原始URL替换为新的URL。 302 Found（临时重定向）: 当服务器返回状态码302时，它表示请求的资源暂时被移动到了另一个位置。 客户端收到302响应后，可以在不更新书签和链接的情况下继续使用原始URL。 搜索引擎在遇到302时，通常会保留原始URL在索引中，并不会立即更新为新的URL。 总体来说，使用301通常是在确定资源永久移动的情况下，而302通常用于暂时性的重定向，即资源可能在将来回到原始位置。选择使用哪种状态码取决于你希望客户端和搜索引擎如何处理被重定向的资源。 路由\r","date":"2024-05-15","objectID":"/posts/31a491d/:5:2","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"默认路由\r当访问路径不被匹配的时候返回默认路由内容 目录结构 //main.go package main import ( \"awesomeProject/pkg/controller\" \"github.com/gin-gonic/gin\" ) func main() { router := gin.Default() router.LoadHTMLGlob(\"templates/*\") router.GET(\"/\", func(c *gin.Context) { c.String(200, \"helloworld\") }) router.NoRoute(controller.Default_route) router.Run(\":80\") } //server.go package controller import ( \"github.com/gin-gonic/gin\" \"net/http\" ) func Default_route(c *gin.Context) { c.HTML(http.StatusNotFound, \"404.html\", nil) } \u003c!--404.html--\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e404 NOT FOUND\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003e404 Not Found\u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e 效果 ","date":"2024-05-15","objectID":"/posts/31a491d/:6:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"路由组\r参考：https://www.liwenzhou.com/posts/Go/gin/#c-0-7-2 我们可以将拥有共同URL前缀的路由划分为一个路由组。习惯性一对{}包裹同组的路由，这只是为了看着清晰，你用不用{}包裹功能上没什么区别。 //main.go package main import ( \"awesomeProject/pkg/controller\" \"github.com/gin-gonic/gin\" ) func main() { router := gin.Default() userGroup := router.Group(\"/user\") { userGroup.GET(\"/all\", controller.GetUserList) userGroup.GET(\"/detail\", controller.GetUserDetail) } router.LoadHTMLGlob(\"templates/*\") router.NoRoute(controller.Default_route) router.Run(\":80\") } //controller/userController.go package controller import ( . \"awesomeProject/pkg/entity\" \"github.com/gin-gonic/gin\" \"net/http\" \"strconv\" ) func GetUserList(c *gin.Context) { c.JSON(http.StatusOK, Response{ Code: http.StatusOK, Data: UserList, Msg: \"返回成功\", }) } func GetUserDetail(c *gin.Context) { id := c.Query(\"id\") for _, res := range UserList { if strconv.Itoa(res.ID) == id { c.JSON(http.StatusOK, Response{ Code: http.StatusOK, Data: res, Msg: \"get successfully\", }) } } } //user.go package entity type User struct { ID int `json:\"id\"` Name string `json:\"name\"` Age int `json:\"age\"` } type Response struct { Code int `json:\"code\"` Data any `json:\"data\"` Msg string `json:\"msg\"` } var UserList []User = []User{ { ID: 1, Name: \"meowrian\", Age: 20, }, { ID: 2, Name: \"Mike\", Age: 30, }, { ID: 3, Name: \"Amy\", Age: 23, }, { ID: 4, Name: \"John\", Age: 24, }, } //server.go package controller import ( \"github.com/gin-gonic/gin\" \"net/http\" ) func Default_route(c *gin.Context) { c.HTML(http.StatusNotFound, \"404.html\", nil) } 路由组也是支持嵌套的 参数\r","date":"2024-05-15","objectID":"/posts/31a491d/:7:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"查询参数\rpackage main import ( \"net/http\" \"github.com/gin-gonic/gin\" ) func _query(c *gin.Context) { user := c.Query(\"user\") c.HTML(http.StatusOK, \"index.html\", gin.H{ \"user\": user, }) } func main() { router := gin.Default() router.LoadHTMLGlob(\"template/*\") router.Static(\"/static\", \"./static\") router.GET(\"/\", _query) router.Run(\":8080\") } package main import ( \"fmt\" \"net/http\" \"github.com/gin-gonic/gin\") func _query(c *gin.Context) { user, ok := c.GetQuery(\"user\") ids := c.QueryArray(\"id\") //拿到多个相同的查询参数 maps := c.QueryMap(\"id\") fmt.Println(maps) if ok { c.HTML(http.StatusOK, \"index.html\", gin.H{ \"user\": user, \"id\": ids, }) } else { c.String(http.StatusOK, \"No query!\") } } func main() { router := gin.Default() router.LoadHTMLGlob(\"template/*\") router.Static(\"static\", \"./static\") router.GET(\"/\", _query) router.Run(\":8080\") } 请求为： http://127.0.0.1:8080/?user=good\u0026id=1\u0026id=2\u0026id=3\u0026id[good]=meowrain ","date":"2024-05-15","objectID":"/posts/31a491d/:8:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"动态参数\rpackage main import ( \"fmt\" \"github.com/gin-gonic/gin\" \"net/http\") func _param(c *gin.Context) { param := c.Param(\"user_id\") fmt.Println(param) c.HTML(http.StatusOK, \"index.html\", gin.H{ \"param\": param, }) } func main() { router := gin.Default() router.LoadHTMLGlob(\"template/*\") router.Static(\"static\", \"./static\") router.GET(\"/param/:user_id\", _param) router.Run(\":8080\") } ","date":"2024-05-15","objectID":"/posts/31a491d/:9:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"表单参数PostForm\rpackage main import ( \"github.com/gin-gonic/gin\" \"net/http\") func postForm(c *gin.Context) { name := c.PostForm(\"name\") password := c.PostForm(\"password\") c.JSON(http.StatusOK, gin.H{ \"name\": name, \"password\": password, }) } func index(c *gin.Context) { c.HTML(http.StatusOK, \"index.html\", gin.H{}) } func main() { router := gin.Default() router.LoadHTMLGlob(\"template/*\") router.Static(\"static\", \"./static\") router.GET(\"/\", index) router.POST(\"/post\", postForm) router.Run(\":8080\") } \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003ePost Form Test\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003ePost Form Test\u003c/h1\u003e \u003cform id=\"myForm\" action=\"/post\" method=\"post\"\u003e \u003clabel for=\"name\"\u003eName:\u003c/label\u003e \u003cinput type=\"text\" id=\"name\" name=\"name\" required\u003e \u003cbr\u003e \u003clabel for=\"password\"\u003ePassword: \u003c/label\u003e \u003cinput type=\"password\" id=\"password\" name=\"password\" required\u003e \u003cbr\u003e \u003cbutton type=\"button\" onclick=\"postData()\"\u003eSubmit\u003c/button\u003e \u003c/form\u003e \u003ch3 id=\"response\"\u003eResponse: \u003c/h3\u003e \u003cscript\u003e function postData() { var form = document.getElementById(\"myForm\"); var formData = new FormData(form); var resp = document.getElementById(\"response\"); fetch('http://127.0.0.1:8080/post', { method: 'POST', body: formData }) .then(response =\u003e response.json()) .then(data =\u003e { console.log('Success:', data); resp.innerText = \"Response: \" + JSON.stringify(data) }) .catch((error) =\u003e { console.error('Error:', error); resp.innerText = \"Response Error: \" + JSON.stringify(error) }); } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e postFormArray函数 package main import ( \"github.com/gin-gonic/gin\" \"net/http\") func postForm(c *gin.Context) { name := c.PostForm(\"name\") password := c.PostForm(\"password\") respArr := c.PostFormArray(\"name\") c.JSON(http.StatusOK, gin.H{ \"name\": name, \"password\": password, \"respArray\": respArr, }) } func index(c *gin.Context) { c.HTML(http.StatusOK, \"index.html\", gin.H{}) } func main() { router := gin.Default() router.LoadHTMLGlob(\"template/*\") router.Static(\"static\", \"./static\") router.GET(\"/\", index) router.POST(\"/post\", postForm) router.Run(\":8080\") } ","date":"2024-05-15","objectID":"/posts/31a491d/:10:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"原始参数\r/* 原始参数 */ package main import ( \"fmt\" \"github.com/gin-gonic/gin\") func _raw(c *gin.Context) { buf, err := c.GetRawData() if err != nil { fmt.Println(\"error:\", err) return } fmt.Println(string(buf)) } func main() { router := gin.Default() router.POST(\"/\", _raw) router.Run(\":8080\") } ","date":"2024-05-15","objectID":"/posts/31a491d/:11:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"解析json数据\r/* 原始参数 */ package main import ( \"encoding/json\" \"fmt\" \"github.com/gin-gonic/gin\") func bindJSON(c *gin.Context, obj any) error { body, err := c.GetRawData() contentType := c.GetHeader(\"Content-Type\") fmt.Println(\"ContentType:\", contentType) if err != nil { fmt.Println(\"error:\", err) return err } switch contentType { case \"application/json\": err := json.Unmarshal(body, obj) if err != nil { fmt.Println(err.Error()) return err } } return nil } func raw(c *gin.Context) { type User struct { Name string `json:\"name\"` Age int `json:\"age\"` Password string `json:\"-\"` } var user User err := bindJSON(c, \u0026user) if err != nil { fmt.Println(\"Error binding JSON:\", err) return } fmt.Println(user) } func main() { router := gin.Default() router.POST(\"/\", raw) router.Run(\":8080\") } 四大请求方式\r","date":"2024-05-15","objectID":"/posts/31a491d/:11:1","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"简单实现以下CRUD\rpackage main import ( \"github.com/gin-gonic/gin\" \"net/http\" \"strconv\") type Article struct { Id int `json:\"id\"` Title string `json:\"title\"` Content string `json:\"content\"` Author string `json:\"author\"` } type Response struct { Code int `json:\"code\"` Data any `json:\"data\"` Msg string `json:\"msg\"` } var articleList []Article = []Article{ { 1, \"Go语言从入门到精通\", \"Learn better\", \"Mike Jason\", }, { 2, \"Java从入门到精通\", \"Java is good\", \"Jack Smith\", }, { 3, \"Javascript从入门到精通\", \"Javascript is a nice programming language!\", \"Amy Gorden\", }, { 4, \"Python从入门到精通\", \"Python is a simple language!\", \"Jack Buffer\", }, } /*简单增删改查*/ func _getList(c *gin.Context) { c.JSON(http.StatusOK, Response{Code: 200, Data: articleList, Msg: \"获取成功\"}) } func _getDetail(c *gin.Context) { id := c.Param(\"id\") flag := false for _, res := range articleList { if strconv.Itoa(res.Id) == id { flag = true c.JSON(http.StatusOK, Response{ Code: 200, Data: res, Msg: \"获取成功！\", }) } } if flag == false { c.JSON(404, Response{ Code: 404, Data: \"Not Found the data\", Msg: \"获取失败，因为数据不存在\", }) } } func _create(c *gin.Context) { id, _ := strconv.ParseInt(c.PostForm(\"id\"), 10, 0) title := c.PostForm(\"title\") content := c.PostForm(\"content\") author := c.PostForm(\"author\") var article Article = Article{ Id: int(id), Title: title, Content: content, Author: author, } articleList = append(articleList, article) c.JSON(200, Response{Code: 200, Data: article, Msg: \"添加成功！\"}) } func _delete(c *gin.Context) { id := c.Param(\"id\") index := -1 for i, res := range articleList { if strconv.Itoa(res.Id) == id { index = i break } } if index != -1 { articleList = append(articleList[:index], articleList[index+1:]...) c.JSON(http.StatusOK, Response{Code: 200, Data: nil, Msg: \"删除成功\"}) } else { c.JSON(http.StatusNotFound, Response{Code: 404, Data: \"Not Found the data\", Msg: \"删除失败，数据不存在\"}) } } func _update(c *gin.Context) { id, _ := strconv.Atoi(c.Param(\"id\")) title := c.PostForm(\"title\") content := c.PostForm(\"content\") author := c.PostForm(\"author\") found := false for i, res := range articleList { if res.Id == id { found = true articleList[i] = Article{ id, title, content, author, } break } } if found { c.JSON(http.StatusOK, Response{ Code: 200, Data: nil, Msg: \"更新成功\", }) return } else { c.JSON(http.StatusNotFound, Response{ Code: 404, Data: \"Not found the data\", Msg: \"更新失败，因为数据不存在\", }) } } func main() { router := gin.Default() router.GET(\"/articles\", _getList) router.GET(\"/articles/:id\", _getDetail) router.POST(\"/articles\", _create) router.PUT(\"/articles/:id\", _update) router.DELETE(\"/articles/:id\", _delete) router.Run(\":8080\") } ","date":"2024-05-15","objectID":"/posts/31a491d/:12:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"文件上传\r","date":"2024-05-15","objectID":"/posts/31a491d/:13:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"上传单个文件\rpackage main import ( \"awesomeProject/pkg/controller\" \"github.com/gin-gonic/gin\" ) func main() { router := gin.Default() router.LoadHTMLGlob(\"templates/*\") router.GET(\"/\", func(c *gin.Context) { c.HTML(200, \"upload.html\", nil) }) router.POST(\"/upload\",controller.Upload_file) router.NoRoute(controller.Default_route) router.Run(\":80\") } package controller import ( \"fmt\" \"github.com/gin-gonic/gin\" \"log\" \"net/http\" ) func Default_route(c *gin.Context) { c.HTML(http.StatusNotFound, \"404.html\", nil) } //文件上传 func Upload_file(c *gin.Context) { file, err := c.FormFile(\"f1\") if err != nil { c.JSON(http.StatusInternalServerError, gin.H{ \"message\": err.Error(), }) return } log.Println(file.Filename) dst := fmt.Sprintf(\"./tmp/%s\", file.Filename) c.SaveUploadedFile(file, dst) c.JSON(http.StatusOK, gin.H{ \"message\": fmt.Sprintf(\"'%s' uploaded\", file.Filename), }) } \u003c!DOCTYPE html\u003e \u003chtml lang=\"zh-CN\"\u003e \u003chead\u003e \u003ctitle\u003e上传文件示例\u003c/title\u003e \u003cstyle\u003e body { font-family: Arial, sans-serif; background-color: #f2f2f2; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; } form { background-color: #fff; padding: 30px; border-radius: 5px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); text-align: center; } input[type=\"file\"] { margin-bottom: 20px; } input[type=\"submit\"] { background-color: #4CAF50; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; } input[type=\"submit\"]:hover { background-color: #45a049; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cform id=\"uploadForm\"\u003e \u003cinput type=\"file\" id=\"fileInput\" name=\"f1\"\u003e \u003cinput type=\"button\" value=\"上传\" onclick=\"uploadFile()\"\u003e \u003c/form\u003e \u003cscript\u003e function uploadFile() { let fileInput = document.getElementById('fileInput'); let file = fileInput.files[0]; if (file) { let formData = new FormData(); formData.append('f1', file); fetch('/upload', { method: 'POST', body: formData }) .then(response =\u003e response.json()) .then(result =\u003e { console.log(result); }) .catch(error =\u003e { console.error('Error:', error); }); } else { console.error('No file selected.'); } } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2024-05-15","objectID":"/posts/31a491d/:13:1","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"上传多个文件\rpackage main import ( \"awesomeProject/pkg/controller\" \"github.com/gin-gonic/gin\" ) func main() { router := gin.Default() router.LoadHTMLGlob(\"templates/*\") router.GET(\"/\", func(c *gin.Context) { c.HTML(200, \"upload.html\", nil) }) router.POST(\"/upload\", controller.UploadFiles) router.NoRoute(controller.Default_route) router.Run(\":80\") } package controller import ( \"fmt\" \"github.com/gin-gonic/gin\" \"log\" \"net/http\" ) func Default_route(c *gin.Context) { c.HTML(http.StatusNotFound, \"404.html\", nil) } func UploadFiles(c *gin.Context) { err := c.Request.ParseMultipartForm(100 \u003c\u003c 20) // 100 MB limit if err != nil { c.JSON(http.StatusInternalServerError, gin.H{ \"message\": err.Error(), }) return } form := c.Request.MultipartForm if form == nil || form.File == nil { c.JSON(http.StatusBadRequest, gin.H{ \"message\": \"No files provided in the request\", }) return } files := form.File[\"f1\"] for _, file := range files { dst := fmt.Sprintf(\"./tmp/%s\", file.Filename) if err := c.SaveUploadedFile(file, dst); err != nil { c.JSON(http.StatusInternalServerError, gin.H{ \"message\": fmt.Sprintf(\"Failed to save file %s: %s\", file.Filename, err.Error()), }) return } log.Println(file.Filename) } c.JSON(http.StatusOK, gin.H{ \"message\": \"Files uploaded successfully\", }) } \u003c!DOCTYPE html\u003e \u003chtml lang=\"zh-CN\"\u003e \u003chead\u003e \u003ctitle\u003e上传文件示例\u003c/title\u003e \u003cstyle\u003e body { font-family: Arial, sans-serif; background-color: #f2f2f2; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; } form { background-color: #fff; padding: 30px; border-radius: 5px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); text-align: center; } input[type=\"file\"] { margin-bottom: 20px; } input[type=\"submit\"] { background-color: #4CAF50; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; } input[type=\"submit\"]:hover { background-color: #45a049; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cform id=\"uploadForm\"\u003e \u003cinput type=\"file\" id=\"fileInput\" name=\"f1\" multiple\u003e \u003cinput type=\"button\" value=\"上传\" onclick=\"uploadFile()\"\u003e \u003c/form\u003e \u003cscript\u003e function uploadFile() { let fileInput = document.getElementById('fileInput'); let formData = new FormData(); for (const file of fileInput.files) { formData.append('f1', file); } fetch('/upload', { method: 'POST', body: formData }) .then(response =\u003e response.json()) .then(result =\u003e { console.log(result); }) .catch(error =\u003e { console.error('Error:', error); }); } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2024-05-15","objectID":"/posts/31a491d/:13:2","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"判断上传文件的类型\r在Gin框架中,可以使用binding模块提供的FormFile函数来获取上传的文件,然后检查文件的MIME类型。具体步骤如下: 在处理函数中使用c.FormFile获取上传的文件: file, err := c.FormFile(\"file\") if err != nil { c.String(http.StatusBadRequest, \"获取文件失败\") return } 打开文件并读取文件头部的几个字节,以识别文件的MIME类型: f, err := file.Open() if err != nil { c.String(http.StatusInternalServerError, \"打开文件失败\") return } defer f.Close() buffer := make([]byte, 512) _, err = f.Read(buffer) if err != nil { c.String(http.StatusInternalServerError, \"读取文件失败\") return } 使用http.DetectContentType函数检测文件的MIME类型: contentType := http.DetectContentType(buffer) 判断文件类型是否允许: allowedTypes := []string{\"image/jpeg\", \"image/png\", \"application/pdf\"} allowed := false for _, t := range allowedTypes { if t == contentType { allowed = true break } } if !allowed { c.String(http.StatusBadRequest, \"不支持的文件类型\") return } 完整的示例代码如下: func uploadFile(c *gin.Context) { file, err := c.FormFile(\"file\") if err != nil { c.String(http.StatusBadRequest, \"获取文件失败\") return } f, err := file.Open() if err != nil { c.String(http.StatusInternalServerError, \"打开文件失败\") return } defer f.Close() buffer := make([]byte, 512) _, err = f.Read(buffer) if err != nil { c.String(http.StatusInternalServerError, \"读取文件失败\") return } contentType := http.DetectContentType(buffer) allowedTypes := []string{\"image/jpeg\", \"image/png\", \"application/pdf\"} allowed := false for _, t := range allowedTypes { if t == contentType { allowed = true break } } if !allowed { c.String(http.StatusBadRequest, \"不支持的文件类型\") return } // 处理文件... } 在上面的示例中，我们定义了一个允许的MIME类型列表allowedTypes，包括image/jpeg、image/png和application/pdf。如果上传的文件类型不在允许列表中，就会返回错误响应。你可以根据需求修改允许的文件类型列表。 ","date":"2024-05-15","objectID":"/posts/31a491d/:13:3","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"使用gin编写文件服务器\rpackage controller import ( \"fmt\" \"github.com/gin-gonic/gin\" \"log\" \"net/http\" \"os\" ) func Default_route(c *gin.Context) { c.HTML(http.StatusNotFound, \"404.html\", nil) } func UploadFiles(c *gin.Context) { err := c.Request.ParseMultipartForm(100 \u003c\u003c 20) // 100 MB limit if err != nil { c.JSON(http.StatusInternalServerError, gin.H{ \"message\": err.Error(), }) return } form := c.Request.MultipartForm if form == nil || form.File == nil { c.JSON(http.StatusBadRequest, gin.H{ \"message\": \"No files provided in the request\", }) return } files := form.File[\"f1\"] for _, file := range files { dst := fmt.Sprintf(\"./tmp/%s\", file.Filename) if err := c.SaveUploadedFile(file, dst); err != nil { c.JSON(http.StatusInternalServerError, gin.H{ \"message\": fmt.Sprintf(\"Failed to save file %s: %s\", file.Filename, err.Error()), }) return } log.Println(file.Filename) } c.JSON(http.StatusOK, gin.H{ \"message\": \"Files uploaded successfully\", }) } func ListFiles(c *gin.Context) { // 读取 ./tmp 目录下的所有文件 files, err := os.ReadDir(\"./tmp\") if err != nil { c.String(http.StatusInternalServerError, err.Error()) return } // 渲染模板 c.HTML(http.StatusOK, \"download.html\", gin.H{ \"Files\": files, }) } package main import ( \"awesomeProject/pkg/controller\" \"github.com/gin-gonic/gin\" ) func main() { r := gin.Default() // 设置静态文件路径为 ./tmp r.Static(\"/tmp\", \"./tmp\") // 设置模板目录 r.LoadHTMLGlob(\"templates/*\") // 定义路由 r.GET(\"/\", func(c *gin.Context) { c.HTML(200, \"upload.html\", nil) }) r.POST(\"/upload\", controller.UploadFiles) //文件列表服务器 r.GET(\"/files\", controller.ListFiles) // 启动HTTP服务器 r.Run(\":8080\") } \u003c!--download.html --\u003e \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eFile List\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eFile List\u003c/h1\u003e \u003cul\u003e {{ range .Files }} \u003cli\u003e\u003ca href=\"/tmp/{{ .Name }}\"\u003e{{ .Name }}\u003c/a\u003e\u003c/li\u003e {{ end }} \u003c/ul\u003e \u003c/body\u003e \u003c/html\u003e \u003c!--美化版--\u003e \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eFile List\u003c/title\u003e \u003cstyle\u003e body { font-family: Arial, sans-serif; background-color: #f5f5f5; padding: 20px; } h1 { color: #333; text-align: center; } ul { list-style-type: none; margin: 0; padding: 0; display: flex; flex-wrap: wrap; justify-content: center; } li { background-color: #fff; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); margin: 10px; padding: 10px; border-radius: 5px; text-align: center; } a { text-decoration: none; color: #333; } a:hover { color: #666; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eFile List\u003c/h1\u003e \u003cul\u003e {{ range .Files }} \u003cli\u003e\u003ca href=\"/tmp/{{ .Name }}\"\u003e{{ .Name }}\u003c/a\u003e\u003c/li\u003e {{ end }} \u003c/ul\u003e \u003c/body\u003e \u003c/html\u003e 请求头相关\r","date":"2024-05-15","objectID":"/posts/31a491d/:13:4","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"获取所有请求头\rpackage main import ( \"fmt\" \"github.com/gin-gonic/gin\" \"net/http\") func main() { router := gin.Default() router.LoadHTMLGlob(\"template/*\") router.Static(\"static\", \"./static\") router.GET(\"/\", func(c *gin.Context) { c.HTML(http.StatusOK, \"index.html\", gin.H{ \"header\": c.Request.Header, }) fmt.Println(c.Request.Header) }) router.Run(\":8080\") } \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003ePost Form Test\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eHeader Test\u003c/h1\u003e \u003ch3\u003eHeader: {{.header}}\u003c/h3\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2024-05-15","objectID":"/posts/31a491d/:14:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"绑定参数bind\r绑定post发送的json数据转换为Student结构体的成员变量值，然后再把这个结构体转换为json对象 package main import ( \"fmt\" \"github.com/gin-gonic/gin\" \"net/http\") type Student struct { Name string `json:\"name\"` Age int `json:\"age\"` } func main() { router := gin.Default() router.POST(\"/\", func(c *gin.Context) { var stu Student err := c.BindJSON(\u0026stu) if err != nil { fmt.Println(\"error: \", err) c.JSON(http.StatusBadGateway, err) return } c.JSON(http.StatusOK, stu) }) router.Run(\":8080\") } 绑定查询参数 package main import ( \"fmt\" \"github.com/gin-gonic/gin\" \"net/http\") type Student struct { Name string `json:\"name\" form:\"name\"` Age int `json:\"age\" form:\"age\"` } func main() { router := gin.Default() router.GET(\"/\", func(c *gin.Context) { var stu Student err := c.BindQuery(\u0026stu) if err != nil { fmt.Println(\"error: \", err) c.JSON(http.StatusBadGateway, err) return } c.JSON(http.StatusOK, stu) }) router.Run(\":8080\") } bind URI package main import ( \"fmt\" \"github.com/gin-gonic/gin\" \"net/http\") type Student struct { Name string `json:\"name\" form:\"name\" uri:\"name\"` Age int `json:\"age\" form:\"age\" uri:\"age\"` } func main() { router := gin.Default() router.GET(\"/uri/:name/:age\", func(c *gin.Context) { var stu Student err := c.ShouldBindUri(\u0026stu) if err != nil { fmt.Println(\"error: \", err) c.JSON(http.StatusBadGateway, err) return } c.JSON(http.StatusOK, stu) }) router.Run(\":8080\") } ","date":"2024-05-15","objectID":"/posts/31a491d/:15:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"常用验证器\r// 不能为空，并且不能没有这个字段 required： 必填字段，如：binding:\"required\" // 针对字符串的长度 min 最小长度，如：binding:\"min=5\" max 最大长度，如：binding:\"max=10\" len 长度，如：binding:\"len=6\" // 针对数字的大小 eq 等于，如：binding:\"eq=3\" ne 不等于，如：binding:\"ne=12\" gt 大于，如：binding:\"gt=10\" gte 大于等于，如：binding:\"gte=10\" lt 小于，如：binding:\"lt=10\" lte 小于等于，如：binding:\"lte=10\" // 针对同级字段的 eqfield 等于其他字段的值，如：PassWord string `binding:\"eqfield=Password\"` nefield 不等于其他字段的值 - 忽略字段，如：binding:\"-\" package main import ( \"github.com/gin-gonic/gin\" \"net/http\") type User struct { Name string `json:\"name\" binding:\"required\"` Password string `json:\"password\" binding:\"eqfield=Re_Password\"` Re_Password string `json:\"re_password\"` } type Response struct { Code int `json:\"code\"` Data any `json:\"data\"` Msg string `json:\"msg\"` } func main() { router := gin.Default() router.POST(\"/login\", func(c *gin.Context) { var user User err := c.ShouldBindJSON(\u0026user) if err != nil { c.JSON(http.StatusBadGateway, Response{ Code: http.StatusBadGateway, Data: err.Error(), Msg: \"bad response\", }) return } c.JSON(http.StatusOK, Response{ Code: http.StatusOK, Data: user, Msg: \"post successfully\", }) }) router.Run(\":8080\") } 密码相同 密码不同 我们看到报错对用户不是很友好，我们可以自定义验证的错误信息 TODO ","date":"2024-05-15","objectID":"/posts/31a491d/:16:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"gin内置验证器\r// 枚举 只能是red 或green oneof=red green // 字符串 contains=fengfeng // 包含fengfeng的字符串 excludes // 不包含 startswith // 字符串前缀 endswith // 字符串后缀 // 数组 dive // dive后面的验证就是针对数组中的每一个元素 // 网络验证 ip ipv4 ipv6 uri url // uri 在于I(Identifier)是统一资源标示符，可以唯一标识一个资源。 // url 在于Locater，是统一资源定位符，提供找到该资源的确切路径 // 日期验证 1月2号下午3点4分5秒在2006年 datetime=2006-01-02 Gin中间件\rhttps://www.liwenzhou.com/posts/Go/gin/#c-0-8-3 Gin中的中间件必须是一个gin.HandlerFunc类型。 Gin框架允许开发者在处理请求的过程中，加入用户自己的钩子（Hook）函数。这个钩子函数就叫中间件，中间件适合处理一些公共的业务逻辑，比如登录认证、权限校验、数据分页、记录日志、耗时统计等。 记录接口耗时的中间件\r","date":"2024-05-15","objectID":"/posts/31a491d/:17:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"}]