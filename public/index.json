[{"categories":["Go","函数库","http"],"content":"Go net/http库 Get()方法 ","date":"2024-06-19","objectID":"/posts/51b9f8d/:0:0","tags":["Go"],"title":"Go net/http库","uri":"/posts/51b9f8d/"},{"categories":["Go","函数库","http"],"content":"函数原型 func Get(url string) (resp *Response, err error) ","date":"2024-06-19","objectID":"/posts/51b9f8d/:1:0","tags":["Go"],"title":"Go net/http库","uri":"/posts/51b9f8d/"},{"categories":["Linux系统编程"],"content":" https://cplusplus.com/reference/cstdio/fopen/ https://cplusplus.com/reference/cstdio/fgetc/?kw=fgetc https://cplusplus.com/reference/cstdio/fputc/?kw=fputc https://cplusplus.com/reference/cstdio/fgets/?kw=fgets https://cplusplus.com/reference/cstdio/fputs/?kw=fputs https://man7.org/linux/man-pages/man3/getline.3.html https://cplusplus.com/reference/cstdio/feof/?kw=feof https://cplusplus.com/reference/cstdio/fclose/?kw=fclose https://cplusplus.com/reference/cstdio/fread/?kw=fread https://cplusplus.com/reference/cstdio/fwrite/?kw=fwrite https://cplusplus.com/reference/cstdio/fseek/?kw=fseek https://cplusplus.com/reference/cstdio/rewind/kw=rewind https://cplusplus.com/reference/cstdio/ftell/?kw=ftell fopen： 函数原型：FILE *fopen(const char *filename, const char *mode); 功能：打开一个文件，并返回一个指向该文件的文件指针（FILE 类型）。这个文件指针用于后续的文件读写操作。 参数： filename：指向一个以空字符结尾的字符串，该字符串指定要打开的文件名，可以包含路径信息。 mode：指向一个以空字符结尾的字符串，指定文件的打开模式。常见的模式包括： \"r\"：以只读方式打开文件（文件必须存在）。 \"w\"：以写入方式打开文件，如果文件不存在则创建，如果文件已存在则清空文件内容。 \"a\"：以追加方式打开文件，如果文件不存在则创建，写入的数据追加到文件末尾。 \"r+\"：以读写方式打开文件（文件必须存在）。 \"w+\"：以读写方式打开文件，如果文件不存在则创建，如果文件已存在则清空文件内容。 \"a+\"：以读取和追加方式打开文件，如果文件不存在则创建，读取从文件开始，写入追加到文件末尾。 还可以在上述模式后添加 \"b\" 来以二进制模式打开文件，例如 \"rb\"、\"wb\" 等。 返回值：成功时返回一个有效的文件指针，如果文件无法打开，则返回 NULL。 在使用 fopen 打开文件后，通常需要检查返回的文件指针是否为 NULL 来确保文件成功打开。文件使用完毕后，应使用 fclose 函数关闭文件，释放资源。例如： FILE *fp; char *filename = \"example.txt\"; char *mode = \"r\"; fp = fopen(filename, mode); if (fp == NULL) { printf(\"无法打开文件\\n\"); return 1; } // 文件操作代码... fclose(fp); 这个例子展示了如何使用 fopen 打开一个文件，并在操作完成后关闭文件。 在C语言中，fgetc, fputc, fgets, 和 fputs 是用于文件操作的标准库函数，它们分别用于从文件中读取字符、向文件写入字符、从文件中读取字符串和向文件写入字符串。下面是这些函数的简要介绍： fgetc： 函数原型：int fgetc(FILE *stream); 功能：从指定的文件流（stream）中读取一个字符。 返回值：返回读取的字符，如果到达文件末尾或发生错误，则返回 EOF。 fputc： 函数原型：int fputc(int character, FILE *stream); 功能：将一个字符（character）写入到指定的文件流（stream）中。 返回值：成功时返回写入的字符，如果发生错误，则返回 EOF。 fgets： 函数原型：char *fgets(char *str, int n, FILE *stream); 功能：从指定的文件流（stream）中读取最多 n-1 个字符，并将其存储在字符数组 str 中。如果在读取完整行之前已经读取了 n-1 个字符，或者遇到换行符或文件结束符，读取操作将停止。 返回值：成功时返回指向 str 的指针，如果到达文件末尾或发生错误，则返回 NULL。 fputs： 函数原型：int fputs(const char *str, FILE *stream); 功能：将字符串 str 写入到指定的文件流（stream）中。不包括字符串末尾的空字符。 返回值：成功时返回非负值，如果发生错误，则返回 EOF。 这些函数都是标准输入输出库（stdio.h）的一部分，用于处理文件和字符数据。在使用这些函数之前，通常需要打开文件并获取相应的文件指针，使用完毕后还需要关闭文件以释放资源。 函数使用示例 ","date":"2024-06-19","objectID":"/posts/232b1fc/:0:0","tags":["Linux系统编程","文件IO","文件读写"],"title":"Linux系统编程 标准IO 打开并读写文件","uri":"/posts/232b1fc/"},{"categories":["Linux系统编程"],"content":"读取 #include \u003cstdio.h\u003e //成功返回流指针，失败返回空指针 int main(void) { FILE *file; char filename[] = \"./files/demo.txt\"; char mode[] = \"r\"; file = fopen(filename,mode); if(file == NULL) { printf(\"无法打开文件\\n\"); return 1; } int ch; while((ch = fgetc(file)) != EOF){ printf(\"%c\",ch); } //执行完毕后关闭流 fclose(file); return 0; } 使用 fgets 函数按行读取文件内容： //成功返回流指针，失败返回空指针 int main(void) { FILE *file; char filename[] = \"./files/demo.txt\"; char mode[] = \"r+\"; file = fopen(filename,mode); if(file == NULL) { printf(\"无法打开文件\\n\"); return 1; } //int ch; // while((ch = fgetc(file)) != EOF){ // printf(\"%c\",ch); // } char buffer[1024]; while(fgets(buffer,sizeof(buffer),file) != NULL) { printf(\"%s\",buffer); } //执行完毕后关闭流 fclose(file); return 0; } ","date":"2024-06-19","objectID":"/posts/232b1fc/:1:0","tags":["Linux系统编程","文件IO","文件读写"],"title":"Linux系统编程 标准IO 打开并读写文件","uri":"/posts/232b1fc/"},{"categories":["Linux系统编程"],"content":"写入 #include \u003cstdio.h\u003e int main(int argc,int*argv[]) { FILE *file; char filename[] = \"./files/demo2.txt\"; char mode[] = \"w\"; int ch; file = fopen(filename,mode); if(file == NULL) { printf(\"无法打开文件\"); return 1; } while((ch = getchar()) != EOF) { fputc(ch,file); } fclose(file); return 0; } #include \u003cstdio.h\u003e int main(int argc,int* argv[]) { FILE* file; char filename[] = \"./files/exxample.txt\"; char mode[] = \"w\"; char str[100]; file = fopen(filename,mode); if(file == NULL) { printf(\"无法打开文件.\\n\"); return 1; } printf(\"请输入要写入的文件的字符串:\\n\"); fgets(str,sizeof(str),stdin); fputs(str,file); fclose(file); return 0; } ","date":"2024-06-19","objectID":"/posts/232b1fc/:2:0","tags":["Linux系统编程","文件IO","文件读写"],"title":"Linux系统编程 标准IO 打开并读写文件","uri":"/posts/232b1fc/"},{"categories":["Linux系统编程"],"content":"从文件里面读取一行 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main(){ FILE* file = fopen(\"./xxx.txt\",\"r\"); if(file == NULL) { perror(\"fopen:\"); exit(EXIT_FAILURE); } char *buffer == NULL; size_t buffer_size = 0; ssize_t read_length = getline(\u0026buffer,\u0026buffer_size,file); if(read_length == -1){ perror(\"readline():\"); free(buffer); fclose(file); exit(EXIT_FAILURE); } printf(\"%s\\n\",buffer); free(buffer); fclose(file); return 0; } 一行一行读取所有内容: #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main() { FILE* file = fopen(\"./xxx.txt\",\"r\"); if(file == NULL) { perror(\"fopen:\"); exit(EXIT_FAILURE); } char* buffer = NULL; size_t buffer_size = 0; while(getline(\u0026buffer,\u0026buffer_size,file) != -1){ printf(\"%s\",buffer); } free(buffer); fclose(file); return 0; } ","date":"2024-06-19","objectID":"/posts/232b1fc/:3:0","tags":["Linux系统编程","文件IO","文件读写"],"title":"Linux系统编程 标准IO 打开并读写文件","uri":"/posts/232b1fc/"},{"categories":["Linux系统编程"],"content":"返回文件头部重新读取 rewind 函数用于将文件指针重新定位到文件的开头。以下是一个简单的例子，展示了如何使用 rewind 函数： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main() { FILE* file = fopen(\"example.txt\", \"r\"); if (file == NULL) { perror(\"fopen\"); exit(EXIT_FAILURE); } char buffer[100]; // 读取并打印文件的第一行 if (fgets(buffer, sizeof(buffer), file) != NULL) { printf(\"First line: %s\", buffer); } // 使用 rewind 将文件指针重新定位到文件开头 rewind(file); // 再次读取并打印文件的第一行 if (fgets(buffer, sizeof(buffer), file) != NULL) { printf(\"First line again: %s\", buffer); } fclose(file); return 0; } 在这个例子中，我们首先打开一个文件 example.txt 并读取并打印其第一行。然后，我们使用 rewind 函数将文件指针重新定位到文件的开头，再次读取并打印第一行。 请确保 example.txt 文件存在并且包含一些文本，以便程序能够正常运行。 ","date":"2024-06-19","objectID":"/posts/232b1fc/:4:0","tags":["Linux系统编程","文件IO","文件读写"],"title":"Linux系统编程 标准IO 打开并读写文件","uri":"/posts/232b1fc/"},{"categories":["Linux系统编程"],"content":"读写二进制文件 fread 和 fwrite 是C语言中用于读写数据的两个重要函数，它们可以用来处理二进制数据或文本数据，通常用于文件操作。下面是这两个函数的详细介绍： fread： 函数原型：size_t fread(void *ptr, size_t size, size_t count, FILE *stream); 功能：从指定的文件流（stream）中读取数据到内存中。 参数： ptr：指向一个内存块的指针，用于存储从文件中读取的数据。 size：指定每个数据项的字节数。 count：指定要读取的数据项的数量。 stream：指向要读取的文件的文件指针。 返回值：返回成功读取的数据项的数量。如果返回值小于 count，可能是因为到达文件末尾或发生了错误。 fwrite： 函数原型：size_t fwrite(const void *ptr, size_t size, size_t count, FILE *stream); 功能：将内存中的数据写入到指定的文件流（stream）中。 参数： ptr：指向要写入的数据的内存块的指针。 size：指定每个数据项的字节数。 count：指定要写入的数据项的数量。 stream：指向要写入的文件的文件指针。 返回值：返回成功写入的数据项的数量。如果返回值小于 count，可能是因为发生了错误。 写入部分 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e typedef struct { int id; char name[20]; }Student; int main() { FILE* fp; Student students[] = {{1,\"Alice\"},{2,\"Bob\"}}; int num_students = sizeof(students)/sizeof(Student); fp = fopen(\"students.dat\",\"wb\"); if(fp == NULL) { perror(\"fopen:\"); exit(EXIT_FAILURE); } fwrite(students,sizeof(Student),sizeof(students)/sizeof(Student),fp); fclose(fp); return 0; } 读取部分 #include \u003cstdlib.h\u003e #include \u003cstdio.h\u003e typedef struct { int id; char name[20]; } Student; int main() { FILE *fp = fopen(\"./students.dat\", \"rb\"); if (fp == NULL) { perror(\"fopen\"); exit(EXIT_FAILURE); } fseek(fp, 0, SEEK_END); const int num_students = ftell(fp)/sizeof(Student); printf(\"Thre are %d students in students.dat\\n\",num_students); rewind(fp); Student students[num_students]; fread(students, sizeof(Student), num_students, fp); for (int i = 0; i \u003c 2; i++) { printf(\"Student info:\"); printf(\"id:%d,name:%s\", students[i].id, students[i].name); printf(\"\\n\"); } fclose(fp); return 0; } 移动文件指针 fseek 是C语言中用于操作文件指针位置的函数，它允许你在文件中移动文件指针到指定的位置，从而可以实现随机访问文件中的数据。下面是 fseek 函数的详细介绍： fseek： 函数原型：int fseek(FILE *stream, long offset, int origin); 功能：设置文件指针（stream）的位置。 参数： stream：指向要操作的文件的文件指针。 offset：指定从 origin 开始要移动的字节数。如果 offset 是正数，则文件指针向文件尾方向移动；如果 offset 是负数，则文件指针向文件头方向移动。 origin：指定起始位置，可以是以下三个宏之一： SEEK_SET：文件开始位置。 SEEK_CUR：文件指针当前位置。 SEEK_END：文件结束位置。 返回值：成功时返回 0，如果发生错误则返回非零值。 使用 fseek 可以实现多种文件操作，例如跳过文件的一部分、重置文件指针到文件开始、或者移动到文件的特定位置进行读写操作。例如，要重置文件指针到文件开始，可以使用： fseek(fp, 0, SEEK_SET); 要移动到文件末尾，可以使用： fseek(fp, 0, SEEK_END); 要从当前位置向前移动10个字节，可以使用： fseek(fp, 10, SEEK_CUR); 在使用 fseek 后，通常可以使用 ftell 函数来获取当前文件指针的位置。例如： long position = ftell(fp); fseek 和 ftell 通常用于处理二进制文件，因为它们允许你精确地控制文件指针的位置。对于文本文件，fseek 的使用可能会受到限制，因为文本文件可能包含无法直接定位的字符（如换行符在不同系统中的表示不同）。 ftell 是C语言中用于获取文件指针当前位置的函数，它返回文件指针相对于文件开始位置的字节偏移量。下面是 ftell 函数的详细介绍： ftell： 函数原型：long ftell(FILE *stream); 功能：获取指定文件流（stream）的当前文件指针位置。 参数： stream：指向要获取位置信息的文件的文件指针。 返回值：成功时返回文件指针相对于文件开始位置的字节偏移量。如果发生错误，则返回 -1L，并设置 errno 来指示错误类型。 使用 ftell 可以方便地获取文件指针的当前位置，这在需要记录文件读写进度或者在文件中进行随机访问时非常有用。例如，你可以在读取文件之前使用 ftell 来获取文件指针的初始位置，然后在读取后再次使用 ftell 来确定已经读取了多少字节。 下面是一个简单的例子，展示了如何使用 ftell 来获取文件指针的位置： #include \u003cstdio.h\u003e int main() { FILE *fp = fopen(\"example.txt\", \"r\"); if (fp == NULL) { perror(\"无法打开文件\"); return 1; } // 获取文件指针的初始位置 long initial_position = ftell(fp); printf(\"文件指针的初始位置: %ld\\n\", initial_position); // 读取一些数据 char buffer[100]; fread(buffer, 1, 50, fp); // 获取文件指针的新位置 long new_position = ftell(fp); printf(\"读取50字节后文件指针的位置: %ld\\n\", new_position); // 关闭文件 fclose(fp); return 0; } 在这个例子中，我们首先打开一个文件，然后使用 ftell 获取文件指针的初始位置。接着，我们读取50字节的数据，并再次使用 ftell 来获取文件指针的新位置。最后，我们关闭文件。 注意，ftell 返回的偏移量是相对于文件开始位置的，因此它通常与 fseek 一起使用来实现文件的随机访问。 rewind 是C语言中用于将文件指针重置到文件开始位置的函数。这个函数非常简单，它不需要任何参数，直接将文件指针移动到文件的开头。下面是 rewind 函数的详细介绍： rewind： 函数原型：void rewind(FILE *stream); 功能：将文件指针（stream）重置到文件的开始位置。 参数： stream：指向要重置位置的文件的文件指针。 返回值：rewind 函数没有返回值。 使用 rewind 可以方便地将文件指针移动到文件的开始，这在需要重新读取文件内容或者在文件操作过程中需要回到文件开头时非常有用。例如，如果你已经读取了文件的一部分，但想要重新开始读取，可以使用 rewind 来重置文件指针。 下面是一个简单的例子，展示了如何使用 rewind 来重置文件指针： #include \u003cstdio.h\u003e int main() { FILE *fp = fopen(\"example.txt\", \"r\"); if (fp == NULL) { perror(\"无法打开文件\"); return 1; } // 读取一些数据 char buffer[100]; fread(buffer, 1, 50, fp); // 重置文件指针到文件开始 rewind(fp); // 再次读取数据 fread(buffer, 1, 50, fp); // 关闭文件 fclose(fp); return 0; } 在这个例子中，我们首先打开一个文件，然后读取50字节的数据。接着，我们使用 rewind 将文件指针重置到文件开始，并再次读取50字节的数据。最后，我们关闭文件。 rewind 函数等效于以下代码： fseek(fp, 0, SE","date":"2024-06-19","objectID":"/posts/232b1fc/:5:0","tags":["Linux系统编程","文件IO","文件读写"],"title":"Linux系统编程 标准IO 打开并读写文件","uri":"/posts/232b1fc/"},{"categories":["Linux系统编程"],"content":"临时文件 tmpfile() 是C语言中的一个标准库函数，用于创建一个临时文件，该文件在程序结束时或显式关闭后会自动删除。这个函数通常用于需要临时存储数据，但在程序结束时不需要保留这些数据的场景。下面是 tmpfile() 函数的详细介绍： tmpfile()： 函数原型：FILE *tmpfile(void); 功能：创建一个临时文件，并返回一个指向该文件的文件指针。 返回值：成功时返回一个有效的文件指针，如果创建临时文件失败，则返回 NULL。 tmpfile() 创建的临时文件是以二进制模式打开的，模式为 wb+，这意味着文件既可以读也可以写，并且是以二进制格式打开的。 下面是一个简单的例子，展示了如何使用 tmpfile() 来创建和使用一个临时文件： #include \u003cstdio.h\u003e int main() { FILE *temp_file = tmpfile(); if (temp_file == NULL) { perror(\"无法创建临时文件\"); return 1; } // 写入一些数据到临时文件 const char *data = \"这是一些临时数据\"; fwrite(data, sizeof(char), strlen(data), temp_file); // 重置文件指针到文件开始 rewind(temp_file); // 从临时文件读取数据 char buffer[100]; size_t bytes_read = fread(buffer, sizeof(char), sizeof(buffer), temp_file); buffer[bytes_read] = '\\0'; // 确保字符串以 null 结尾 printf(\"从临时文件读取的数据: %s\\n\", buffer); // 关闭临时文件（文件会在关闭后自动删除） fclose(temp_file); return 0; } 在这个例子中，我们首先使用 tmpfile() 创建一个临时文件，并检查是否成功。然后，我们将一些数据写入临时文件，重置文件指针，并从文件中读取数据。最后，我们关闭临时文件，文件会在关闭后自动删除。 注意，tmpfile() 创建的临时文件的路径和名称是由系统自动生成的，因此每次调用 tmpfile() 时，通常会创建一个不同的临时文件。这使得 tmpfile() 非常适合于需要临时存储数据但不关心文件持久性的场景。 ","date":"2024-06-19","objectID":"/posts/232b1fc/:6:0","tags":["Linux系统编程","文件IO","文件读写"],"title":"Linux系统编程 标准IO 打开并读写文件","uri":"/posts/232b1fc/"},{"categories":["Linux系统编程"],"content":" 行缓冲 在使用行缓冲的情况下，每当输入输出遇到换行或者缓冲区满了的情况下才会进行实际的IO操作，当涉及到终端输入输出的时候通常使用行缓冲。 当字符数超过1024个时，进行IO操作 使用换行符时候进行IO 全缓冲 在使用全缓冲的情况下，当数据填满整个缓冲区之后才进行实际的IO操作。对于驻留在磁盘上的文件的读写通常是使用全缓冲。通常如果不给文件流指定缓冲区的情况下，标准IO函数会首先调用malloc函数获取所需要的缓冲区。 ","date":"2024-06-19","objectID":"/posts/e1ebd34/:0:0","tags":["Linux系统编程","缓冲区","文件IO"],"title":"Linux系统编程-文件IO-缓冲区实例","uri":"/posts/e1ebd34/"},{"categories":["网络编程"],"content":"参考文档 https://jacktang816.github.io/post/tinyhttpdread/ 执行过程 HTTP ","date":"2024-06-18","objectID":"/posts/913f95d/:1:0","tags":["网络编程","http服务器","tinyhttpd"],"title":"Tinyhttpd源码解析","uri":"/posts/913f95d/"},{"categories":["网络编程"],"content":"HTTP请求头 当然，下面是一个带有 \\r\\n 行结尾的 HTTP 请求头示例： GET /index.html HTTP/1.1\\r\\n Host: www.example.com\\r\\n User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\\r\\n Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\\r\\n Accept-Language: en-US,en;q=0.5\\r\\n Accept-Encoding: gzip, deflate\\r\\n Connection: keep-alive\\r\\n Upgrade-Insecure-Requests: 1\\r\\n \\r\\n ","date":"2024-06-18","objectID":"/posts/913f95d/:2:0","tags":["网络编程","http服务器","tinyhttpd"],"title":"Tinyhttpd源码解析","uri":"/posts/913f95d/"},{"categories":["网络编程"],"content":"解释 每一行都是一个 HTTP 头字段，使用 \\r\\n（回车符和换行符）来表示行结束。 最后一行的 \\r\\n 表示头部结束，之后的内容（如果有）是请求的主体。 ","date":"2024-06-18","objectID":"/posts/913f95d/:2:1","tags":["网络编程","http服务器","tinyhttpd"],"title":"Tinyhttpd源码解析","uri":"/posts/913f95d/"},{"categories":["网络编程"],"content":"分解示例 请求行: GET /index.html HTTP/1.1\\r\\n GET 是 HTTP 方法。 /index.html 是请求的路径。 HTTP/1.1 是 HTTP 版本。 头字段: Host: www.example.com\\r\\n User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\\r\\n Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\\r\\n Accept-Language: en-US,en;q=0.5\\r\\n Accept-Encoding: gzip, deflate\\r\\n Connection: keep-alive\\r\\n Upgrade-Insecure-Requests: 1\\r\\n Host: 指定请求的主机名（必须字段）。 User-Agent: 指定发出请求的客户端软件信息。 Accept: 指定客户端可接受的响应内容类型。 Accept-Language: 指定客户端可接受的响应语言。 Accept-Encoding: 指定客户端可接受的响应内容编码（如压缩）。 Connection: 指定是否保持连接。 Upgrade-Insecure-Requests: 指定客户端是否要求安全的连接升级。 空行: \\r\\n 空行表示 HTTP 请求头的结束，接下来如果有数据就是请求的主体。 ","date":"2024-06-18","objectID":"/posts/913f95d/:2:2","tags":["网络编程","http服务器","tinyhttpd"],"title":"Tinyhttpd源码解析","uri":"/posts/913f95d/"},{"categories":["网络编程"],"content":"HTTP响应头 当然，下面是一个包含 \\r\\n 作为行结束符的 HTTP 响应头示例： HTTP/1.1 200 OK\\r\\n Date: Tue, 18 Jun 2024 12:28:53 GMT\\r\\n Server: jdbhttpd/0.1.0\\r\\n Last-Modified: Tue, 18 Jun 2024 12:28:53 GMT\\r\\n Content-Type: text/html\\r\\n Content-Length: 1234\\r\\n Connection: keep-alive\\r\\n \\r\\n ","date":"2024-06-18","objectID":"/posts/913f95d/:3:0","tags":["网络编程","http服务器","tinyhttpd"],"title":"Tinyhttpd源码解析","uri":"/posts/913f95d/"},{"categories":["网络编程"],"content":"解释 每一行都是一个 HTTP 头字段，使用 \\r\\n（回车符和换行符）来表示行结束。 最后一行的 \\r\\n 表示头部结束，之后的内容（如果有）是响应的主体。 ","date":"2024-06-18","objectID":"/posts/913f95d/:3:1","tags":["网络编程","http服务器","tinyhttpd"],"title":"Tinyhttpd源码解析","uri":"/posts/913f95d/"},{"categories":["网络编程"],"content":"分解示例 状态行: HTTP/1.1 200 OK\\r\\n HTTP/1.1：HTTP 版本。 200 OK：状态码和状态描述，表示请求成功。 头字段: Date: Tue, 18 Jun 2024 12:28:53 GMT\\r\\n Server: jdbhttpd/0.1.0\\r\\n Last-Modified: Tue, 18 Jun 2024 12:28:53 GMT\\r\\n Content-Type: text/html\\r\\n Content-Length: 1234\\r\\n Connection: keep-alive\\r\\n Date：响应的日期和时间。 Server：服务器软件的信息。 Last-Modified：响应内容的最后修改时间。 Content-Type：响应内容的类型（这里是 HTML）。 Content-Length：响应内容的长度（以字节为单位）。 Connection：控制连接的管理方式（这里是保持连接）。 空行: \\r\\n 空行表示 HTTP 响应头的结束，接下来是响应的主体（如果有）。 accept_request() 函数 好的，根据注释描述这个函数的执行过程如下： ","date":"2024-06-18","objectID":"/posts/913f95d/:3:2","tags":["网络编程","http服务器","tinyhttpd"],"title":"Tinyhttpd源码解析","uri":"/posts/913f95d/"},{"categories":["网络编程"],"content":"accept_request 函数 这个函数的主要任务是处理 HTTP 请求，根据请求的内容返回相应的网页或执行 CGI 程序。它分为几个主要步骤：读取请求头、解析请求方法和 URL、处理 GET/POST 请求、判断文件类型和权限、返回文件内容或执行 CGI 脚本。 void accept_request(void *arg) { // socket int client = (intptr_t)arg; //client套接字 char buf[1024]; //存储从套接字中读取到的内容 int numchars; //表示读取到的字节数 char method[255]; //存储请求方法 char url[255]; //存储url char path[512];//存储路径 size_t i, j; //两个索引指针 struct stat st;//存储网页文件的文件信息 int cgi = 0; //cgi是否启用，如果设置为1，默认启用 char *query_string = NULL; //请求参数 // 根据上面的Get请求，可以看到这边就是取第一行 // 这边都是在处理第一条http信息 numchars = get_line(client, buf, sizeof(buf));//先从套接字读取一行数据到buf中，然后返回读取到的字节数 i = 0; j = 0; // 第一行字符串提取Get //\"GET / HTTP/1.1\\n\" while (!ISspace(buf[j]) \u0026\u0026 (i \u003c sizeof(method) - 1)) { //读到GET后的space后，循环就终止了，正好把GET读取到method数组中了 method[i] = buf[j]; i++; j++; } // 结束 method[i] = '\\0'; // 如果两个都不是，直接返回是不支持的请求类型 //strcasecmd 和 strcmp一样，相等返回0 if (strcasecmp(method, \"GET\") \u0026\u0026 strcasecmp(method, \"POST\")) { unimplemented(client); return; } // 如果是POST，cgi置为1 if (strcasecmp(method, \"POST\") == 0) cgi = 1; i = 0; // i指针归零 // 跳过空格 while (ISspace(buf[j]) \u0026\u0026 (j \u003c sizeof(buf))) j++; // 得到 \"/\" 注意：如果你的http的网址为http://192.168.0.23:47310/index.html // 那么你得到的第一条http信息为GET /index.html HTTP/1.1，那么 // 解析得到的就是/index.html while (!ISspace(buf[j]) \u0026\u0026 (i \u003c sizeof(url) - 1) \u0026\u0026 (j \u003c sizeof(buf))) { url[i] = buf[j]; i++; j++; } url[i] = '\\0'; // 判断Get请求 if (strcasecmp(method, \"GET\") == 0) { query_string = url; while ((*query_string != '?') \u0026\u0026 (*query_string != '\\0')) query_string++; if (*query_string == '?') { cgi = 1; *query_string = '\\0'; query_string++; } } // 路径 sprintf(path, \"htdocs%s\", url); // 默认地址，解析到的路径如果为/，则自动加上index.html if (path[strlen(path) - 1] == '/') strcat(path, \"index.html\"); // 获得文件信息 if (stat(path, \u0026st) == -1) { // 把所有http信息读出然后丢弃 while ((numchars \u003e 0) \u0026\u0026 strcmp(\"\\n\", buf)) /* read \u0026 discard headers */ numchars = get_line(client, buf, sizeof(buf)); // 没有找到 not_found(client); } else { mode_t file_type = st.st_mode \u0026 S_IFMT; if (file_type == S_IFDIR) strcat(path, \"/index.html\"); // 如果你的文件默认是有执行权限的，自动解析成cgi程序，如果有执行权限但是不能执行，会接受到报错信号 if ((st.st_mode \u0026 S_IXUSR) || (st.st_mode \u0026 S_IXGRP) || (st.st_mode \u0026 S_IXOTH)) cgi = 1; if (!cgi) // 接读取文件返回给请求的http客户端 serve_file(client, path); else // 执行cgi文件 execute_cgi(client, path, method, query_string); } // 执行完毕关闭socket close(client); } ","date":"2024-06-18","objectID":"/posts/913f95d/:3:3","tags":["网络编程","http服务器","tinyhttpd"],"title":"Tinyhttpd源码解析","uri":"/posts/913f95d/"},{"categories":["网络编程"],"content":"执行过程描述 初始化和读取请求： 将传入的 arg 转换为客户端的套接字 client。 初始化缓冲区 buf 用于存储读取的数据，初始化其他变量。 调用 get_line 从客户端套接字读取一行数据到 buf，并将读取到的字节数存储在 numchars 中。 解析请求方法： 从 buf 中提取请求方法（如 GET 或 POST），并存储在 method 数组中。 如果请求方法既不是 GET 也不是 POST，则返回未实现的错误。 处理 POST 请求： 如果请求方法是 POST，则将 cgi 标志置为 1。 提取 URL： 跳过空格，继续从 buf 中提取 URL，并存储在 url 数组中。 处理 GET 请求的查询字符串： 如果请求方法是 GET，则进一步解析 URL 中的查询字符串（如果有）。 构建文件路径： 根据提取的 URL 构建文件路径，存储在 path 数组中。 如果 URL 以 / 结尾，自动添加 index.html。 获取文件信息： 调用 stat 函数获取文件信息并存储在 st 结构中。 如果文件不存在（即 stat 返回 -1），则读取并丢弃所有的 HTTP 请求头信息，并返回 404 错误。 处理文件信息： 检查文件类型是否为目录，如果是，则自动添加 index.html。 检查文件是否具有执行权限，如果有，则将 cgi 标志置为 1。 处理文件或执行 CGI： 如果未启用 CGI，则读取文件内容并返回给客户端。 如果启用了 CGI，则执行相应的 CGI 脚本。 关闭套接字： 处理完请求后，关闭客户端的套接字。 通过这些步骤，accept_request 函数能够处理基本的 HTTP 请求，包括静态文件的返回和 CGI 脚本的执行。 badrequest() 函数 notfound()函数 unimplemented()函数 void bad_request(int client) { char buf[1024]; sprintf(buf, \"HTTP/1.0 400 BAD REQUEST\\r\\n\"); send(client, buf, sizeof(buf), 0); sprintf(buf, \"Content-type: text/html\\r\\n\"); send(client, buf, sizeof(buf), 0); sprintf(buf, \"\\r\\n\"); send(client, buf, sizeof(buf), 0); sprintf(buf, \"\u003cP\u003eYour browser sent a bad request, \"); send(client, buf, sizeof(buf), 0); sprintf(buf, \"such as a POST without a Content-Length.\\r\\n\"); send(client, buf, sizeof(buf), 0); } 这个就简单了，直接往buf里面写入字符串，包括响应头，响应类型和内容，然后发给客户端 // 如果资源没有找到得返回给客户端下面的信息 void not_found(int client) { char buf[1024]; sprintf(buf, \"HTTP/1.0 404 NOT FOUND\\r\\n\"); send(client, buf, strlen(buf), 0); sprintf(buf, SERVER_STRING); send(client, buf, strlen(buf), 0); sprintf(buf, \"Content-Type: text/html\\r\\n\"); send(client, buf, strlen(buf), 0); sprintf(buf, \"\\r\\n\"); send(client, buf, strlen(buf), 0); sprintf(buf, \"\u003cHTML\u003e\u003cTITLE\u003eNot Found\u003c/TITLE\u003e\\r\\n\"); send(client, buf, strlen(buf), 0); sprintf(buf, \"\u003cBODY\u003e\u003cP\u003eThe server could not fulfill\\r\\n\"); send(client, buf, strlen(buf), 0); sprintf(buf, \"your request because the resource specified\\r\\n\"); send(client, buf, strlen(buf), 0); sprintf(buf, \"is unavailable or nonexistent.\\r\\n\"); send(client, buf, strlen(buf), 0); sprintf(buf, \"\u003c/BODY\u003e\u003c/HTML\u003e\\r\\n\"); send(client, buf, strlen(buf), 0); } 这个也是，把NOTFOUND的内容发过去 // 如果方法没有实现，就返回此信息 void unimplemented(int client) { char buf[1024]; sprintf(buf, \"HTTP/1.0 501 Method Not Implemented\\r\\n\"); send(client, buf, strlen(buf), 0); sprintf(buf, SERVER_STRING); send(client, buf, strlen(buf), 0); sprintf(buf, \"Content-Type: text/html\\r\\n\"); send(client, buf, strlen(buf), 0); sprintf(buf, \"\\r\\n\"); send(client, buf, strlen(buf), 0); sprintf(buf, \"\u003cHTML\u003e\u003cHEAD\u003e\u003cTITLE\u003eMethod Not Implemented\\r\\n\"); send(client, buf, strlen(buf), 0); sprintf(buf, \"\u003c/TITLE\u003e\u003c/HEAD\u003e\\r\\n\"); send(client, buf, strlen(buf), 0); sprintf(buf, \"\u003cBODY\u003e\u003cP\u003eHTTP request method not supported.\\r\\n\"); send(client, buf, strlen(buf), 0); sprintf(buf, \"\u003c/BODY\u003e\u003c/HTML\u003e\\r\\n\"); send(client, buf, strlen(buf), 0); } 如果方法没有实现，就返回此信息 cat()函数 void cat(int client, FILE *resource) { char buf[1024]; // 定义一个缓冲区，大小为 1024 字节 // 从文件中读取一行内容到缓冲区 buf 中 fgets(buf, sizeof(buf), resource); // 循环读取文件内容，直到文件结束 while (!feof(resource)) { // 将缓冲区 buf 中的内容发送给客户端 send(client, buf, strlen(buf), 0); // 再次从文件中读取一行内容到缓冲区 buf 中 fgets(buf, sizeof(buf), resource); } } 这个代码的作用是，从FILE*中读取内容到buf缓冲区中，每次读取1024字节，读进来就发送给客户端，然后循环往复，直到读完这个文件为止 servefile()函数 // 如果不是CGI文件，直接读取文件返回给请求的http客户端 void serve_file(int client, const char *filename) { FILE *resource = NULL; int numchars = 1; char buf[1024]; // 默认字符 buf[0] = 'A'; buf[1] = '\\0'; while ((numchars \u003e 0) \u0026\u0026 strcmp(\"\\n\", buf)) /* read \u0026 discard headers */ numchars = get_line(client, buf, sizeof(buf)); resource = fopen(filename, \"r\"); if (resource == NULL) not_found(client); else { headers(client, filename); cat(client, resource); } fclose(resource); } serve_file() 函数的主要作用是处理 HTTP 请求并返回一个文件的内容给客户端。如果请求的文件存在且不是 CGI 脚本，则会将文件内容发送给客户端。下面是对这个函数的详细解释： ","date":"2024-06-18","objectID":"/posts/913f95d/:3:4","tags":["网络编程","http服务器","tinyhttpd"],"title":"Tinyhttpd源码解析","uri":"/posts/913f95d/"},{"categories":["网络编程"],"content":"主要步骤和详细解释： 初始化变量： FILE *resource = NULL; int numchars = 1; char buf[1024]; resource：用于存储打开的文件指针。 numchars：用于记录读取的字符数，初始化为1。 buf：缓冲区，用于存储从客户端读取的数据。 默认字符设置： buf[0] = 'A'; buf[1] = '\\0'; 这段代码将 buf 的第一个字符设置为 'A'，并将第二个字符设置为终止符 '\\0'，以确保缓冲区不为空。 读取并丢弃请求头部： while ((numchars \u003e 0) \u0026\u0026 strcmp(\"\\n\", buf)) /* read \u0026 discard headers */ numchars = get_line(client, buf, sizeof(buf)); 通过循环调用 get_line() 函数，从客户端读取一行数据并存储在 buf 中。 该循环持续读取，直到读取到一个空行（即仅包含 '\\n' 的行），表示 HTTP 请求头部结束。 读取的每一行都被丢弃，因为 serve_file() 只关心请求的文件内容。 尝试打开文件： resource = fopen(filename, \"r\"); if (resource == NULL) not_found(client); 尝试以只读模式打开请求的文件。 如果文件不存在或无法打开，则调用 not_found() 函数向客户端返回 404 错误。 发送文件内容： else { headers(client, filename); cat(client, resource); } 如果文件成功打开，则首先调用 headers() 函数发送 HTTP 响应头部。 然后调用 cat() 函数，将文件内容逐行读取并发送给客户端。 关闭文件： fclose(resource); 在完成文件发送后，关闭文件指针以释放资源。 ","date":"2024-06-18","objectID":"/posts/913f95d/:3:5","tags":["网络编程","http服务器","tinyhttpd"],"title":"Tinyhttpd源码解析","uri":"/posts/913f95d/"},{"categories":["网络编程"],"content":"相关函数解释： get_line()： 从客户端读取一行数据，直到遇到换行符 '\\n'，并将其存储在缓冲区 buf 中。 not_found()： 向客户端发送 404 错误，表示请求的文件未找到。 headers()： 发送 HTTP 响应头部，告知客户端响应的文件类型和状态。 cat()： 将文件内容逐行读取，并通过 send() 函数发送给客户端。 这个函数的设计确保了在处理非 CGI 请求时，能够正确读取并返回文件内容给客户端，同时处理可能的错误情况，如文件未找到等。喵~ getline()函数 ","date":"2024-06-18","objectID":"/posts/913f95d/:3:6","tags":["网络编程","http服务器","tinyhttpd"],"title":"Tinyhttpd源码解析","uri":"/posts/913f95d/"},{"categories":["网络编程"],"content":"源码部分 int get_line(int sock, char *buf, int size) { int i = 0; // 缓冲区的索引 char c = '\\0'; // 从套接字读取的字符 int n; // recv() 函数读取的字符数 // 循环读取字符，直到缓冲区满或遇到换行符 while ((i \u003c size - 1) \u0026\u0026 (c != '\\n')) { // 从套接字读取一个字符 n = recv(sock, \u0026c, 1, 0); if (n \u003e 0) { // 如果字符是回车符（'\\r'），需要检查下一个字符 if (c == '\\r') { // 偷窥下一个字符，但不从输入队列中移除它 n = recv(sock, \u0026c, 1, MSG_PEEK); // 如果下一个字符是换行符（'\\n'），从套接字读取它 if ((n \u003e 0) \u0026\u0026 (c == '\\n')) recv(sock, \u0026c, 1, 0); else // 如果下一个字符不是换行符，将回车符视为换行符 c = '\\n'; } // 将字符存储在缓冲区中 buf[i] = c; i++; } else // 如果没有读取到字符，视为换行符以结束行 c = '\\n'; } // 空字符终止缓冲区，使其成为有效的 C 字符串 buf[i] = '\\0'; // 返回存储在缓冲区中的字符数，不包括空字符 return (i); } ","date":"2024-06-18","objectID":"/posts/913f95d/:4:0","tags":["网络编程","http服务器","tinyhttpd"],"title":"Tinyhttpd源码解析","uri":"/posts/913f95d/"},{"categories":["网络编程"],"content":"代码作用和流程 这段代码的主要作用是从套接字中循环读取字符，处理 HTTP 请求头部信息。它具体的流程如下： 循环读取字符： 从套接字中读取一个字符到变量 c 中。 如果成功读取到字符，继续处理。 处理回车符号 '\\r'： 如果读取到的字符是回车符号 '\\r'，接下来检查它的下一个字符。 使用 MSG_PEEK 标志从套接字中偷窥下一个字符（但不将其移出输入队列）。 如果下一个字符是换行符 '\\n'，则从套接字中真正读取该字符，使 c 变为 '\\n'。 如果下一个字符不是换行符，直接将 c 设置为 '\\n'。 存储字符： 将处理后的字符 c 存储到缓冲区 buf 中。 更新缓冲区索引 i，指向下一个存储位置。 处理读取失败或结束情况： 如果没有成功读取到字符（可能是连接关闭或出错），将 c 设置为换行符 '\\n'，结束行读取。 结束读取并终止缓冲区： 循环结束后，在缓冲区末尾添加一个空字符 '\\0'，以形成有效的 C 字符串。 返回存储在缓冲区中的字符数，不包括空字符。 ","date":"2024-06-18","objectID":"/posts/913f95d/:5:0","tags":["网络编程","http服务器","tinyhttpd"],"title":"Tinyhttpd源码解析","uri":"/posts/913f95d/"},{"categories":["网络编程"],"content":"清晰的表述 这段代码的作用是循环读取字符，具体流程如下： 先从套接字读取一个字符到 c 中。 如果成功读取到字符： 检查该字符是否为回车符 '\\r'： 如果是回车符 '\\r'，继续检查下一个字符： 使用 MSG_PEEK 标志偷窥下一个字符： 如果下一个字符是换行符 '\\n'，则从套接字中读取该字符到 c 中，此时 c 为 '\\n'。 如果下一个字符不是换行符，则将 c 设置为 '\\n'。 如果不是回车符 '\\r'，则将读取到的字符存储到缓冲区 buf 中。 如果没有成功读取到字符（可能是连接关闭或出错），将 c 设置为换行符 '\\n'，结束行读取。 每次读取到字符后，将其存储到缓冲区 buf 中，并更新缓冲区索引 i。 循环结束后，在缓冲区末尾添加一个空字符 '\\0'，表示字符串结束。 最终，函数返回存储在缓冲区 buf 中的字符数，不包括结尾的空字符 '\\0'。 ","date":"2024-06-18","objectID":"/posts/913f95d/:6:0","tags":["网络编程","http服务器","tinyhttpd"],"title":"Tinyhttpd源码解析","uri":"/posts/913f95d/"},{"categories":["网络编程"],"content":"intptr_t 是一种在 C 和 C++ 标准库中定义的整数类型。它是专门设计用来存储指针的整数类型，确保能够存储任何指针的整数值。这个类型定义在 \u003cstdint.h\u003e 头文件中。 ","date":"2024-06-18","objectID":"/posts/1df4bf9/:0:0","tags":["网络编程","C语言函数"],"title":"C intptr_t类型","uri":"/posts/1df4bf9/"},{"categories":["网络编程"],"content":"详细解释 定义： intptr_t 是一个有符号整数类型，能够存储任何指针转换成的整数值。 对应的无符号类型是 uintptr_t。 用途： 通常用于需要将指针值存储为整数或者从整数恢复指针值的场景。 在进行指针与整数之间的转换时，使用 intptr_t 可以确保程序的可移植性和类型的安全性。 头文件： 在 C 中：#include \u003cstdint.h\u003e 在 C++ 中：#include \u003ccstdint\u003e ","date":"2024-06-18","objectID":"/posts/1df4bf9/:0:1","tags":["网络编程","C语言函数"],"title":"C intptr_t类型","uri":"/posts/1df4bf9/"},{"categories":["网络编程"],"content":"示例 下面是一个简单的示例，展示如何使用 intptr_t 类型： #include \u003cstdio.h\u003e #include \u003cstdint.h\u003e int main() { int a = 42; int *p = \u0026a; // 将指针转换为整数 intptr_t int_value = (intptr_t)p; printf(\"Pointer as integer: %ld\\n\", (long)int_value); // 将整数转换回指针 int *new_p = (int *)int_value; printf(\"Value through new pointer: %d\\n\", *new_p); return 0; } ","date":"2024-06-18","objectID":"/posts/1df4bf9/:0:2","tags":["网络编程","C语言函数"],"title":"C intptr_t类型","uri":"/posts/1df4bf9/"},{"categories":["网络编程"],"content":"解释 int a = 42; 定义一个整数变量 a。 int *p = \u0026a; 定义一个指针 p，指向变量 a。 (intptr_t)p 将指针 p 转换为整数类型 intptr_t。 printf(\"Pointer as integer: %ld\\n\", (long)int_value); 输出指针转换后的整数值。 (int *)int_value 将整数值 int_value 转换回指针类型。 printf(\"Value through new pointer: %d\\n\", *new_p); 输出通过新指针 new_p 访问的值。 使用 intptr_t 和 uintptr_t 可以确保指针和整数之间的转换在不同平台上都是安全和可移植的。 用途 将指针转换为整数在某些特定情况下是有用的，主要包括以下几个方面： ","date":"2024-06-18","objectID":"/posts/1df4bf9/:0:3","tags":["网络编程","C语言函数"],"title":"C intptr_t类型","uri":"/posts/1df4bf9/"},{"categories":["网络编程"],"content":"1. 指针运算和比较 有时需要对指针进行一些算术运算或比较操作，将指针转换为整数后可以更容易地进行这些操作。例如： 指针差值：计算两个指针之间的差值可以通过将它们转换为整数来实现。 地址对齐：有时需要检查或调整指针的地址对齐情况，将指针转换为整数可以方便地进行对齐运算。 #include \u003cstdio.h\u003e #include \u003cstdint.h\u003e int main() { int arr[10]; int *p1 = \u0026arr[2]; int *p2 = \u0026arr[5]; // 计算两个指针之间的差值 intptr_t diff = (intptr_t)p2 - (intptr_t)p1; printf(\"Difference between p2 and p1: %ld bytes\\n\", diff); return 0; } ","date":"2024-06-18","objectID":"/posts/1df4bf9/:0:4","tags":["网络编程","C语言函数"],"title":"C intptr_t类型","uri":"/posts/1df4bf9/"},{"categories":["网络编程"],"content":"2. 指针和整数之间的转换 在一些低级编程场景下，可能需要将指针存储在整数类型的变量中，以便在后续的操作中使用。例如： 哈希表实现：在某些哈希表实现中，可能需要将指针转换为整数来计算哈希值。 自定义内存分配器：在实现自定义内存分配器时，可能需要对内存地址进行一些整数运算，将指针转换为整数后可以方便地进行这些操作。 #include \u003cstdio.h\u003e #include \u003cstdint.h\u003e void *allocate_memory(size_t size) { // 简单的自定义内存分配器示例 void *ptr = malloc(size); if (ptr == NULL) { return NULL; } // 将指针转换为整数以进行地址对齐 intptr_t addr = (intptr_t)ptr; if (addr % 16 != 0) { addr += 16 - (addr % 16); } return (void *)addr; } int main() { void *ptr = allocate_memory(100); printf(\"Allocated memory address: %p\\n\", ptr); free(ptr); return 0; } ","date":"2024-06-18","objectID":"/posts/1df4bf9/:0:5","tags":["网络编程","C语言函数"],"title":"C intptr_t类型","uri":"/posts/1df4bf9/"},{"categories":["网络编程"],"content":"3. 序列化和反序列化 在某些情况下，需要将数据结构（包括指针）序列化（转换为线性字节序列）以便存储或传输。将指针转换为整数可以简化序列化过程，并在反序列化时恢复原来的指针值。 #include \u003cstdio.h\u003e #include \u003cstdint.h\u003e #include \u003cstring.h\u003e void serialize_pointer(void *ptr, uint8_t *buffer) { intptr_t addr = (intptr_t)ptr; memcpy(buffer, \u0026addr, sizeof(intptr_t)); } void *deserialize_pointer(uint8_t *buffer) { intptr_t addr; memcpy(\u0026addr, buffer, sizeof(intptr_t)); return (void *)addr; } int main() { int a = 42; void *ptr = \u0026a; uint8_t buffer[sizeof(intptr_t)]; serialize_pointer(ptr, buffer); void *new_ptr = deserialize_pointer(buffer); printf(\"Original pointer: %p\\n\", ptr); printf(\"Deserialized pointer: %p\\n\", new_ptr); printf(\"Value through deserialized pointer: %d\\n\", *(int *)new_ptr); return 0; } ","date":"2024-06-18","objectID":"/posts/1df4bf9/:0:6","tags":["网络编程","C语言函数"],"title":"C intptr_t类型","uri":"/posts/1df4bf9/"},{"categories":["网络编程"],"content":"4. 调试和日志记录 在调试和日志记录时，将指针转换为整数可以更直观地观察和记录内存地址，帮助开发人员定位问题。 #include \u003cstdio.h\u003e #include \u003cstdint.h\u003e void log_pointer(void *ptr) { printf(\"Pointer address: %p (as integer: %ld)\\n\", ptr, (intptr_t)ptr); } int main() { int a = 42; log_pointer(\u0026a); return 0; } ","date":"2024-06-18","objectID":"/posts/1df4bf9/:0:7","tags":["网络编程","C语言函数"],"title":"C intptr_t类型","uri":"/posts/1df4bf9/"},{"categories":["网络编程"],"content":"注意事项 尽管将指针转换为整数在某些情况下是有用的，但应注意以下几点： 可移植性：指针和整数之间的转换可能在不同平台上具有不同的行为，需确保在目标平台上是安全的。 类型安全：这种转换在一定程度上破坏了类型安全，应谨慎使用并确保正确性。 指针大小：指针的大小可能不同于整数的大小（例如在不同的体系结构上），需使用合适的整数类型（如intptr_t和uintptr_t）以确保转换的正确性。 通过这些示例，可以看到在不同的编程场景中，将指针转换为整数是有实际用途的，但在使用时需要谨慎对待，以确保程序的正确性和可移植性。 ","date":"2024-06-18","objectID":"/posts/1df4bf9/:0:8","tags":["网络编程","C语言函数"],"title":"C intptr_t类型","uri":"/posts/1df4bf9/"},{"categories":["Linux系统编程"],"content":"C stat函数使用 头文件：#include\u003csys/stat.h\u003e #include\u003cuninstd.h\u003e 定义函数：int stat(const char * file_name, struct stat *buf); 函数说明：stat()用来将参数file_name 所指的文件状态, 复制到参数buf 所指的结构中。 struct stat *buf struct stat { dev_t st_dev; //device 文件的设备编号 ino_t st_ino; //inode 文件的i-node mode_t st_mode; //protection 文件的类型和存取的权限 nlink_t st_nlink; //number of hard links 连到该文件的硬连接数目, 刚建立的文件值为1. uid_t st_uid; //user ID of owner 文件所有者的用户识别码 gid_t st_gid; //group ID of owner 文件所有者的组识别码 dev_t st_rdev; //device type 若此文件为装置设备文件, 则为其设备编号 off_t st_size; //total size, in bytes 文件大小, 以字节计算 unsigned long st_blksize; //blocksize for filesystem I/O 文件系统的I/O 缓冲区大小. u nsigned long st_blocks; //number of blocks allocated 占用文件区块的个数, 每一区块大小为512 个字节. time_t st_atime; //time of lastaccess 文件最近一次被存取或被执行的时间, 一般只有在用mknod、 utime、read、write 与tructate 时改变. time_t st_mtime; //time of last modification 文件最后一次被修改的时间, 一般只有在用mknod、 utime 和write 时才会改变 time_t st_ctime; //time of last change i-node 最近一次被更改的时间, 此参数会在文件所有者、组、 权限被更改时更新 }; st_mode 则定义了下列数种情况： 1、S_IFMT 0170000 文件类型的位遮罩 2、S_IFSOCK 0140000 scoket 3、S_IFLNK 0120000 符号连接 4、S_IFREG 0100000 一般文件 5、S_IFBLK 0060000 区块装置 6、S_IFDIR 0040000 目录 7、S_IFCHR 0020000 字符装置 8、S_IFIFO 0010000 先进先出 9、S_ISUID 04000 文件的 (set user-id on execution)位 10、S_ISGID 02000 文件的 (set group-id on execution)位 11、S_ISVTX 01000 文件的sticky 位 12、S_IRUSR (S_IREAD) 00400 文件所有者具可读取权限 13、S_IWUSR (S_IWRITE)00200 文件所有者具可写入权限 14、S_IXUSR (S_IEXEC) 00100 文件所有者具可执行权限 15、S_IRGRP 00040 用户组具可读取权限 16、S_IWGRP 00020 用户组具可写入权限 17、S_IXGRP 00010 用户组具可执行权限 18、S_IROTH 00004 其他用户具可读取权限 19、S_IWOTH 00002 其他用户具可写入权限 20、S_IXOTH 00001 其他用户具可执行权限上述的文件类型在 POSIX 中定义了检查这些类型的宏定义 21、S_ISLNK (st_mode) 判断是否为符号连接 22、S_ISREG (st_mode) 是否为一般文件 23、S_ISDIR (st_mode) 是否为目录 24、S_ISCHR (st_mode) 是否为字符装置文件 25、S_ISBLK (s3e) 是否为先进先出 26、S_ISSOCK (st_mode) 是否为socket 若一目录具有sticky 位 (S_ISVTX), 则表示在此目录下的文件只能 被该文件所有者、此目录所有者或root 来删除或改名. #include \u003csys/stat.h\u003e #include \u003cunistd.h\u003e #include \u003cstdio.h\u003e #include \u003ctime.h\u003e #include \u003cstdlib.h\u003e void println(char *text) { printf(\"%s\\n\", text); } void print_file_type(mode_t mode) { if (S_ISREG(mode)) { printf(\"文件类型: 普通文件\\n\"); } else if (S_ISDIR(mode)) { printf(\"文件类型: 目录\\n\"); } else if (S_ISCHR(mode)) { printf(\"文件类型: 字符设备\\n\"); } else if (S_ISBLK(mode)) { printf(\"文件类型: 块设备\\n\"); } else if (S_ISFIFO(mode)) { printf(\"文件类型: 先进先出（FIFO）\\n\"); } else if (S_ISLNK(mode)) { printf(\"文件类型: 符号链接\\n\"); } else if (S_ISSOCK(mode)) { printf(\"文件类型: 套接字\\n\"); } else { printf(\"文件类型: 未知\\n\"); } } void print_file_permissions(mode_t mode) { printf(\"权限: \"); printf((mode \u0026 S_IRUSR) ? \"r\" : \"-\"); printf((mode \u0026 S_IWUSR) ? \"w\" : \"-\"); printf((mode \u0026 S_IXUSR) ? \"x\" : \"-\"); printf((mode \u0026 S_IRGRP) ? \"r\" : \"-\"); printf((mode \u0026 S_IWGRP) ? \"w\" : \"-\"); printf((mode \u0026 S_IXGRP) ? \"x\" : \"-\"); printf((mode \u0026 S_IROTH) ? \"r\" : \"-\"); printf((mode \u0026 S_IWOTH) ? \"w\" : \"-\"); printf((mode \u0026 S_IXOTH) ? \"x\" : \"-\"); printf(\"\\n\"); } int main(int argc, char *argv[]) { if (argc \u003c 2) { println(\"请输入要获取相关信息的文件路径：\"); exit(-1); } /** * int stat(const char *__restrict__ __file, struct stat *__restrict__ __buf) Get file attributes for FILE and put them in BUF. */ struct stat info; int err = stat(argv[1], \u0026info); if (err == -1) { perror(\"stat:\"); exit(-1); } printf(\"文件的设备编号:%ld\\n\", info.st_dev); printf(\"文件节点:%ld\\n\", info.st_ino); print_file_type(info.st_mode); print_file_permissions(info.st_mode); printf(\"连到该文件的硬连接数目：%ld\\n\", info.st_nlink); printf(\"用户ID:%d\\n\", info.st_uid); printf(\"组ID:%d\\n\", info.st_gid); printf(\"(设备类型)若此文件为设备文件，则为其设备编号:%ld\\n\", info.st_rdev); printf(\"文件字节数:%ld字节\\n\", info.st_size); printf(\"块大小:%ld\\n\", info.st_blksize); printf(\"块数:%ld\\n\", info.st_blocks); char *time_string = ctime(\u0026info.st_atim.tv_sec); printf(\"最后一次访问时间:%s\", time_string); time_string = ctime(\u0026info.st_mtim.tv_sec); printf(\"最后一次修改时间:%s\", time_string); time_string = ctime(\u0026info.st_ctime); printf(\"最后一次改变时间(属性改变):%s\", time_string); } ","date":"2024-06-17","objectID":"/posts/7484d0b/:0:0","tags":["Linux系统编程","C语言函数","stat函数"],"title":"C Stat函数使用","uri":"/posts/7484d0b/"},{"categories":["网络编程"],"content":"转换ip ","date":"2024-06-14","objectID":"/posts/12b8a48/:0:0","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"inet_pton() inet_pton 函数用于将字符串表示的 IP 地址转换为网络字节序的二进制格式。与 inet_ntop 相反，inet_pton 的用途是从人类可读的字符串格式转换到机器可读的二进制格式。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:1:0","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"函数原型 #include \u003carpa/inet.h\u003e int inet_pton(int af, const char *src, void *dst); ","date":"2024-06-14","objectID":"/posts/12b8a48/:1:1","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"参数 af：地址家族，可以是 AF_INET（表示 IPv4）或 AF_INET6（表示 IPv6）。 src：指向以字符串形式表示的地址（如 \"192.168.1.1\" 或 \"2001:db8::1\"）。 dst：指向存储转换后地址的缓冲区。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:1:2","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"返回值 成功时返回 1。 如果输入的字符串不是有效的网络地址，返回 0。 失败时返回 -1，并设置 errno 来指示错误。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:1:3","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"使用示例 以下是使用 inet_pton 的示例，展示如何将 IPv4 和 IPv6 地址从字符串格式转换为二进制格式： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003carpa/inet.h\u003e int main() { struct sockaddr_in ipv4_addr; struct sockaddr_in6 ipv6_addr; const char *ipv4_str = \"192.168.1.1\"; const char *ipv6_str = \"2001:db8::1\"; // 将字符串形式的 IPv4 地址转换为二进制格式 if (inet_pton(AF_INET, ipv4_str, \u0026ipv4_addr.sin_addr) \u003c= 0) { perror(\"inet_pton\"); exit(EXIT_FAILURE); } printf(\"IPv4 address: %s converted successfully.\\n\", ipv4_str); // 将字符串形式的 IPv6 地址转换为二进制格式 if (inet_pton(AF_INET6, ipv6_str, \u0026ipv6_addr.sin6_addr) \u003c= 0) { perror(\"inet_pton\"); exit(EXIT_FAILURE); } printf(\"IPv6 address: %s converted successfully.\\n\", ipv6_str); return 0; } ","date":"2024-06-14","objectID":"/posts/12b8a48/:1:4","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"详细说明 IPv4 地址转换： struct sockaddr_in ipv4_addr; const char *ipv4_str = \"192.168.1.1\"; if (inet_pton(AF_INET, ipv4_str, \u0026ipv4_addr.sin_addr) \u003c= 0) { perror(\"inet_pton\"); exit(EXIT_FAILURE); } printf(\"IPv4 address: %s converted successfully.\\n\", ipv4_str); 这里我们将一个字符串形式的 IPv4 地址 \"192.168.1.1\" 转换为二进制格式，并存储在 ipv4_addr.sin_addr 中。如果转换失败，inet_pton 返回 0 或 -1，并打印错误信息。 IPv6 地址转换： struct sockaddr_in6 ipv6_addr; const char *ipv6_str = \"2001:db8::1\"; if (inet_pton(AF_INET6, ipv6_str, \u0026ipv6_addr.sin6_addr) \u003c= 0) { perror(\"inet_pton\"); exit(EXIT_FAILURE); } printf(\"IPv6 address: %s converted successfully.\\n\", ipv6_str); 这里我们将一个字符串形式的 IPv6 地址 \"2001:db8::1\" 转换为二进制格式，并存储在 ipv6_addr.sin6_addr 中。如果转换失败，inet_pton 返回 0 或 -1，并打印错误信息。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:1:5","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"错误处理 0 返回值：如果输入的字符串不是有效的网络地址，inet_pton 返回 0。这时你可以检查输入的字符串格式是否正确。 -1 返回值：如果出现其他错误（如地址家族无效），inet_pton 返回 -1，并设置 errno。 通过这些示例和说明，你可以了解如何使用 inet_pton 函数将字符串形式的 IP 地址转换为二进制格式，以便在网络编程中使用。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:1:6","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"inet_ntop inet_ntop 函数用于将网络字节序的二进制格式的 IP 地址转换为人类可读的字符串格式。该函数支持 IPv4 和 IPv6 地址转换。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:2:0","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"函数原型 #include \u003carpa/inet.h\u003e const char *inet_ntop(int af, const void *src, char *dst, socklen_t size); ","date":"2024-06-14","objectID":"/posts/12b8a48/:2:1","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"参数 af：地址家族，可以是 AF_INET（表示 IPv4）或 AF_INET6（表示 IPv6）。 src：指向存储二进制格式地址的缓冲区。 dst：指向存储转换后字符串格式地址的缓冲区。 size：dst 缓冲区的大小。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:2:2","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"返回值 成功时返回指向 dst 的指针。 失败时返回 NULL，并设置 errno 来指示错误。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:2:3","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"使用示例 以下是一个使用 inet_ntop 将 IPv4 和 IPv6 地址转换为字符串格式的示例： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003carpa/inet.h\u003e int main() { struct sockaddr_in ipv4_addr; struct sockaddr_in6 ipv6_addr; char ipv4_str[INET_ADDRSTRLEN]; char ipv6_str[INET6_ADDRSTRLEN]; // 设置一个 IPv4 地址 ipv4_addr.sin_family = AF_INET; ipv4_addr.sin_addr.s_addr = inet_addr(\"192.168.1.1\"); // 将 IPv4 地址转换为字符串格式 if (inet_ntop(AF_INET, \u0026ipv4_addr.sin_addr, ipv4_str, INET_ADDRSTRLEN) == NULL) { perror(\"inet_ntop\"); exit(EXIT_FAILURE); } printf(\"IPv4 address: %s\\n\", ipv4_str); // 设置一个 IPv6 地址 inet_pton(AF_INET6, \"2001:db8::1\", \u0026ipv6_addr.sin6_addr); // 将 IPv6 地址转换为字符串格式 if (inet_ntop(AF_INET6, \u0026ipv6_addr.sin6_addr, ipv6_str, INET6_ADDRSTRLEN) == NULL) { perror(\"inet_ntop\"); exit(EXIT_FAILURE); } printf(\"IPv6 address: %s\\n\", ipv6_str); return 0; } ","date":"2024-06-14","objectID":"/posts/12b8a48/:2:4","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"详细说明 设置 IPv4 地址： struct sockaddr_in ipv4_addr; ipv4_addr.sin_family = AF_INET; ipv4_addr.sin_addr.s_addr = inet_addr(\"192.168.1.1\"); 将 IPv4 地址转换为字符串格式： char ipv4_str[INET_ADDRSTRLEN]; if (inet_ntop(AF_INET, \u0026ipv4_addr.sin_addr, ipv4_str, INET_ADDRSTRLEN) == NULL) { perror(\"inet_ntop\"); exit(EXIT_FAILURE); } printf(\"IPv4 address: %s\\n\", ipv4_str); 设置 IPv6 地址： struct sockaddr_in6 ipv6_addr; inet_pton(AF_INET6, \"2001:db8::1\", \u0026ipv6_addr.sin6_addr); 将 IPv6 地址转换为字符串格式： char ipv6_str[INET6_ADDRSTRLEN]; if (inet_ntop(AF_INET6, \u0026ipv6_addr.sin6_addr, ipv6_str, INET6_ADDRSTRLEN) == NULL) { perror(\"inet_ntop\"); exit(EXIT_FAILURE); } printf(\"IPv6 address: %s\\n\", ipv6_str); ","date":"2024-06-14","objectID":"/posts/12b8a48/:2:5","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"错误处理 EINVAL：提供的地址家族 af 不正确。 ENOSPC：提供的 dst 缓冲区大小不足以存储转换后的地址。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:2:6","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"INET_ADDRSTRLEN INET_ADDRSTRLEN 是一个宏，它定义了一个足够大的缓冲区大小，用于存储点分十进制表示的 IPv4 地址字符串。具体来说，它的值为 16，因为一个完整的 IPv4 地址（包括终止的 null 字符）最多需要 16 个字符。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:3:0","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"使用示例改进 我们可以改进前面的示例，使其更完整，包括处理错误和展示 inet_ntop 函数的实际使用场景： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003carpa/inet.h\u003e #define PORT 12345 #define BACKLOG 10 #define BUFFERSIZE 1024 int main() { int sockfd, new_sockfd; struct sockaddr_in server_addr, client_addr; struct sockaddr_in peer_addr; socklen_t addr_len, peer_addr_len; char buffer[BUFFERSIZE]; ssize_t bytes_received; char client_ip[INET_ADDRSTRLEN]; char peer_ip[INET_ADDRSTRLEN]; sockfd = socket(PF_INET, SOCK_STREAM, 0); if (sockfd == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } memset(\u0026server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = INADDR_ANY; server_addr.sin_port = htons(PORT); if (bind(sockfd, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)) == -1) { perror(\"bind\"); close(sockfd); exit(EXIT_FAILURE); } if (listen(sockfd, BACKLOG) == -1) { perror(\"listen\"); close(sockfd); exit(EXIT_FAILURE); } printf(\"Listening on port: %d\\n\", PORT); addr_len = sizeof(client_addr); new_sockfd = accept(sockfd, (struct sockaddr *)\u0026client_addr, \u0026addr_len); if (new_sockfd == -1) { perror(\"accept\"); close(sockfd); exit(EXIT_FAILURE); } // 将客户端地址转换为字符串格式 if (inet_ntop(AF_INET, \u0026client_addr.sin_addr, client_ip, INET_ADDRSTRLEN) == NULL) { perror(\"inet_ntop\"); close(new_sockfd); close(sockfd); exit(EXIT_FAILURE); } printf(\"Accepted connection from %s:%d\\n\", client_ip, ntohs(client_addr.sin_port)); peer_addr_len = sizeof(peer_addr); if (getpeername(new_sockfd, (struct sockaddr *)\u0026peer_addr, \u0026peer_addr_len) == -1) { perror(\"getpeername\"); close(new_sockfd); close(sockfd); exit(EXIT_FAILURE); } // 将远程地址转换为字符串格式 if (inet_ntop(AF_INET, \u0026peer_addr.sin_addr, peer_ip, INET_ADDRSTRLEN) == NULL) { perror(\"inet_ntop\"); close(new_sockfd); close(sockfd); exit(EXIT_FAILURE); } printf(\"Peer address (from getpeername): %s, port: %d\\n\", peer_ip, ntohs(peer_addr.sin_port)); close(new_sockfd); close(sockfd); return 0; } 在这个示例中，服务器创建一个监听端口，并接受客户端连接。使用 inet_ntop 函数将客户端和远程端的 IP 地址从二进制格式转换为可读的字符串格式并打印出来。这可以帮助调试和验证服务器是否正确接收和处理连接。 #include \u003cstdio.h\u003e #include \u003carpa/inet.h\u003e int main() { struct sockaddr_in addr; struct sockaddr_in6 addr6; const char* ipv4_addr = \"192.168.31.2\"; const char* ipv6_addr = \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\"; // convert ipv4 address from text to binary form if(inet_pton(AF_INET,ipv4_addr,\u0026(addr.sin_addr))!=1) { fprintf(stderr,\"Invalid IPv4 address\\n\"); return 1; } if(inet_pton(AF_INET6,ipv6_addr,\u0026(addr6.sin6_addr))!=1){ fprintf(stderr,\"Invalid IPV6 address\\n\"); return 1; } printf(\"IPv4 address in binary form: 0x%x\\n\",addr.sin_addr.s_addr); printf(\"Now the ipv6 address has been saved in addr6.sin6_addr\"); //Now the ipv6 address has been saved in addr6.sin6_addr puts(\"\"); //convert binary form of ipv4 address to text form char ipv4_addr_text[INET_ADDRSTRLEN]; char ipv6_addr_text[INET6_ADDRSTRLEN]; if(inet_ntop(AF_INET,\u0026(addr.sin_addr),ipv4_addr_text,INET_ADDRSTRLEN)==NULL){ fprintf(stderr,\"Error in converting IPv4 address to text form\\n\"); return 1; } if(inet_ntop(AF_INET6,\u0026(addr6.sin6_addr),ipv6_addr_text,INET6_ADDRSTRLEN)==NULL){ fprintf(stderr,\"Error in converting IPv6 address to text form\\n\"); } printf(\"IPv4 address in text form: %s\\n\",ipv4_addr_text); printf(\"IPv6 address in text form: %s\\n\",ipv6_addr_text); return 0; } 默认ip #include \u003cstdio.h\u003e #include \u003carpa/inet.h\u003e int main() { struct sockaddr_in ipv4_addr; ipv4_addr.sin_addr.s_addr = INADDR_ANY; struct sockaddr_in6 ipv6_addr; ipv6_addr.sin6_addr = in6addr_any; char dst_ipv4[INET_ADDRSTRLEN]; char dst_ipv6[INET6_ADDRSTRLEN]; if(inet_ntop(AF_INET,\u0026(ipv4_addr.sin_addr),dst_ipv4,INET_ADDRSTRLEN)==NULL) { fprintf(stderr,\"Error in converting IPv4 address to text form\\n\"); return 1; } if(inet_ntop(AF_INET6,\u0026(ipv6_addr.sin6_addr),dst_ipv6,INET6_ADDRSTRLEN) == NULL) { fprintf(stderr,\"Error in converting ipv6 address to text form\\n\"); return 1; } printf(\"%s\\n\",dst_ipv4); printf(\"%s\\n\",dst_ipv6); return 0; } errno变量 errno 是一个全局变量，用于指示最近一次系统调用或库函数调用是否出错以及出错的类型。在 C","date":"2024-06-14","objectID":"/posts/12b8a48/:3:1","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"errno 的定义 errno 通常定义在 \u003cerrno.h\u003e 头文件中。它是一个整数变量，每个线程都有自己独立的 errno 值（在线程安全的实现中）。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:3:2","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"常见的错误代码 errno 变量可以设置为许多不同的错误代码，每个错误代码都有一个对应的宏定义。例如： EACCES：权限被拒绝 EAGAIN：资源暂时不可用 EBADF：文件描述符无效 EEXIST：文件已存在 EINTR：系统调用被中断 EINVAL：无效的参数 ENOMEM：内存不足 ENOTDIR：不是一个目录 ","date":"2024-06-14","objectID":"/posts/12b8a48/:3:3","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"使用示例 以下是一个使用 errno 的示例，演示如何在调用系统函数时检查错误并获取错误信息： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cerrno.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003cfcntl.h\u003e int main() { int fd; // 尝试打开一个不存在的文件 fd = open(\"nonexistentfile.txt\", O_RDONLY); if (fd == -1) { // 打印错误代码 printf(\"Error number: %d\\n\", errno); // 打印错误信息 perror(\"open\"); // 也可以使用 strerror 函数获取错误信息 printf(\"Error opening file: %s\\n\", strerror(errno)); } else { printf(\"File opened successfully\\n\"); close(fd); } return 0; } 在这个示例中，我们尝试打开一个不存在的文件。这会导致 open 函数返回 -1，并设置 errno 为 ENOENT（表示文件或目录不存在）。然后我们使用 perror 和 strerror 函数打印错误信息。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:3:4","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"perror 和 strerror perror：perror 函数用于根据 errno 值打印一个描述错误的字符串，并在该字符串前添加一个用户指定的字符串。例如，perror(\"open\") 可能输出 open: No such file or directory。 strerror：strerror 函数根据 errno 值返回一个指向描述错误的字符串的指针。例如，strerror(ENOENT) 将返回 \"No such file or directory\"。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:3:5","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"注意事项 线程安全：在多线程程序中，每个线程都有独立的 errno 值，这通常通过将 errno 实现为线程本地存储（TLS）来实现。 设置和重置：errno 只在函数出错时设置，因此在调用可能会设置 errno 的函数前，最好先将 errno 设置为 0，以便在出错时能够准确判断错误来源。 检查返回值：许多系统调用和库函数在出错时不会设置 errno，而是直接返回错误码。因此，在这些情况下应检查函数的返回值，而不是 errno。 通过使用 errno，程序员可以更好地处理和调试系统调用和库函数中的错误，从而编写出更健壮的代码。 struct in_addr struct in_addr 是一个用于存储 IPv4 地址的结构体。它通常在网络编程中使用，尤其是在处理套接字编程中的 IPv4 地址时。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:3:6","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"定义 struct in_addr 通常定义如下： struct in_addr { uint32_t s_addr; // 32位的IPv4地址 }; struct sockaddr struct sockaddr 是一个通用的套接字地址结构体，用于在套接字编程中表示各种类型的套接字地址。它通常用于函数参数中，通过类型转换来适应具体的地址类型（如 struct sockaddr_in 或 struct sockaddr_in6）。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:3:7","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"定义 struct sockaddr 通常定义如下： struct sockaddr { sa_family_t sa_family; // 地址家族（Address family） char sa_data[14]; // 地址数据（Address data） }; ","date":"2024-06-14","objectID":"/posts/12b8a48/:3:8","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"用法 struct sockaddr 本身很少直接使用。相反，通常使用它的派生结构体，如 struct sockaddr_in（用于 IPv4 地址）和 struct sockaddr_in6（用于 IPv6 地址）。这些派生结构体提供了更多特定于地址类型的信息。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:3:9","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"常见的派生结构体 struct sockaddr_in 用于表示 IPv4 地址： struct sockaddr_in { sa_family_t sin_family; // 地址家族：AF_INET in_port_t sin_port; // 端口号 struct in_addr sin_addr; // IPv4 地址 char sin_zero[8]; // 填充以使结构体大小与 `struct sockaddr` 对齐 }; struct in_addr { uint32_t s_addr; // 32位 IPv4 地址 }; struct sockaddr_in6 用于表示 IPv6 地址： struct sockaddr_in6 { sa_family_t sin6_family; // 地址家族：AF_INET6 in_port_t sin6_port; // 端口号 uint32_t sin6_flowinfo; // 流信息 struct in6_addr sin6_addr; // IPv6 地址 uint32_t sin6_scope_id; // 作用域 ID }; struct in6_addr { unsigned char s6_addr[16]; // 128位 IPv6 地址 }; ","date":"2024-06-14","objectID":"/posts/12b8a48/:3:10","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"使用示例 下面是一个使用 struct sockaddr 和 struct sockaddr_in 的示例，演示如何设置和获取 IPv4 地址： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetinet/in.h\u003e #include \u003carpa/inet.h\u003e int main() { int sockfd; struct sockaddr_in server_addr; struct sockaddr_in client_addr; socklen_t addr_len = sizeof(client_addr); char buffer[1024]; // 创建一个 UDP 套接字 sockfd = socket(AF_INET, SOCK_DGRAM, 0); if (sockfd \u003c 0) { perror(\"socket\"); exit(EXIT_FAILURE); } // 设置服务器地址和端口 memset(\u0026server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = INADDR_ANY; server_addr.sin_port = htons(12345); // 绑定套接字到地址和端口 if (bind(sockfd, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)) \u003c 0) { perror(\"bind\"); close(sockfd); exit(EXIT_FAILURE); } // 接收来自客户端的数据 ssize_t recv_len = recvfrom(sockfd, buffer, sizeof(buffer) - 1, 0, (struct sockaddr *)\u0026client_addr, \u0026addr_len); if (recv_len \u003c 0) { perror(\"recvfrom\"); close(sockfd); exit(EXIT_FAILURE); } buffer[recv_len] = '\\0'; // 打印客户端的 IP 地址和端口 printf(\"收到来自 %s:%d 的数据\\n\", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port)); printf(\"收到的信息: %s\\n\", buffer); close(sockfd); return 0; } 在这个示例中，服务器创建了一个 UDP 套接字，绑定到一个特定的地址和端口，然后等待接收来自客户端的数据。客户端的地址信息存储在 struct sockaddr_in 结构体中，通过类型转换为 struct sockaddr 传递给 recvfrom 函数。 struct sockaddr_storage sockaddr_storage 是一个结构体，用于存储任意类型的 socket 地址。它在网络编程中提供了一种通用的方式来处理不同类型的 socket 地址（如 IPv4 和 IPv6 地址），而无需预先知道将使用哪种类型的地址。该结构体定义在 \u003csys/socket.h\u003e 头文件中。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:3:11","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"定义 sockaddr_storage 结构体定义如下： struct sockaddr_storage { sa_family_t ss_family; // 地址家族 char __ss_pad1[_SS_PAD1SIZE]; int64_t __ss_align; char __ss_pad2[_SS_PAD2SIZE]; }; ","date":"2024-06-14","objectID":"/posts/12b8a48/:3:12","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"用法 声明： 当你需要处理不同类型的 socket 地址时，可以声明一个 sockaddr_storage 变量。 struct sockaddr_storage addr; 接收地址： 当接收一个 socket 地址（例如从 recvfrom() 函数中），可以使用 sockaddr_storage 来通用地处理地址。 socklen_t addr_len = sizeof(struct sockaddr_storage); recvfrom(sockfd, buffer, sizeof(buffer), 0, (struct sockaddr *)\u0026addr, \u0026addr_len); 处理具体的地址类型： 接收到 socket 地址后，可以根据 ss_family 字段将 sockaddr_storage 转换为合适的地址类型。 if (addr.ss_family == AF_INET) { struct sockaddr_in *addr_in = (struct sockaddr_in *)\u0026addr; // 处理 IPv4 地址 } else if (addr.ss_family == AF_INET6) { struct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *)\u0026addr; // 处理 IPv6 地址 } ","date":"2024-06-14","objectID":"/posts/12b8a48/:3:13","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"示例 下面是一个使用 sockaddr_storage 的 UDP 服务器示例： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetinet/in.h\u003e #include \u003carpa/inet.h\u003e int main() { int sockfd; struct sockaddr_storage addr; socklen_t addr_len = sizeof(addr); char buffer[1024]; // 创建一个 UDP 套接字 sockfd = socket(AF_INET, SOCK_DGRAM, 0); if (sockfd \u003c 0) { perror(\"socket\"); exit(EXIT_FAILURE); } // 绑定套接字到一个地址和端口 struct sockaddr_in server_addr; memset(\u0026server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = INADDR_ANY; server_addr.sin_port = htons(12345); if (bind(sockfd, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)) \u003c 0) { perror(\"bind\"); close(sockfd); exit(EXIT_FAILURE); } // 从客户端接收数据 ssize_t recv_len = recvfrom(sockfd, buffer, sizeof(buffer) - 1, 0, (struct sockaddr *)\u0026addr, \u0026addr_len); if (recv_len \u003c 0) { perror(\"recvfrom\"); close(sockfd); exit(EXIT_FAILURE); } buffer[recv_len] = '\\0'; // 处理接收到的地址 if (addr.ss_family == AF_INET) { struct sockaddr_in *addr_in = (struct sockaddr_in *)\u0026addr; printf(\"从 IPv4 地址接收: %s\\n\", inet_ntoa(addr_in-\u003esin_addr)); } else if (addr.ss_family == AF_INET6) { char ip_str[INET6_ADDRSTRLEN]; struct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *)\u0026addr; inet_ntop(AF_INET6, \u0026addr_in6-\u003esin6_addr, ip_str, sizeof(ip_str)); printf(\"从 IPv6 地址接收: %s\\n\", ip_str); } // 打印接收到的消息 printf(\"接收到的消息: %s\\n\", buffer); close(sockfd); return 0; } 在这个示例中，服务器绑定到一个端口，并等待从客户端接收数据。使用 sockaddr_storage 结构体来存储客户端的地址，并根据地址的家族（IPv4 或 IPv6）进行适当的处理。 struct addrinfo struct addrinfo 是一个结构体，用于存储与主机名和服务相关的地址信息。它主要在使用 getaddrinfo 函数时使用，该函数将主机名和服务名转换为套接字地址结构体，并返回一个指向 addrinfo 结构体链表的指针。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:3:14","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"定义 struct addrinfo 通常定义如下： struct addrinfo { int ai_flags; // 输入标志 int ai_family; // 地址家族（AF_INET、AF_INET6 等） int ai_socktype; // 套接字类型（SOCK_STREAM、SOCK_DGRAM 等） int ai_protocol; // 协议（通常为 0 或 IPPROTO_TCP、IPPROTO_UDP） size_t ai_addrlen; // 套接字地址的长度 struct sockaddr *ai_addr; // 套接字地址（struct sockaddr） char *ai_canonname; // 官方主机名 struct addrinfo *ai_next; // 指向下一个 addrinfo 结构体的指针 }; ","date":"2024-06-14","objectID":"/posts/12b8a48/:3:15","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"用法 获取地址信息： 使用 getaddrinfo 函数获取主机名和服务的地址信息。该函数将主机名和服务名转换为一组地址结构体，并返回一个指向 addrinfo 结构体链表的指针。 struct addrinfo hints, *res; memset(\u0026hints, 0, sizeof(hints)); hints.ai_family = AF_UNSPEC; // IPv4 或 IPv6 hints.ai_socktype = SOCK_STREAM; // TCP int status = getaddrinfo(\"www.example.com\", \"http\", \u0026hints, \u0026res); if (status != 0) { fprintf(stderr, \"getaddrinfo error: %s\\n\", gai_strerror(status)); return 1; } 处理地址信息： 遍历 addrinfo 结构体链表，处理每个地址信息。 for (struct addrinfo *p = res; p != NULL; p = p-\u003eai_next) { // 打印地址信息 char ipstr[INET6_ADDRSTRLEN]; void *addr; char *ipver; // 处理 IPv4 和 IPv6 地址 if (p-\u003eai_family == AF_INET) { // IPv4 struct sockaddr_in *ipv4 = (struct sockaddr_in *)p-\u003eai_addr; addr = \u0026(ipv4-\u003esin_addr); ipver = \"IPv4\"; } else { // IPv6 struct sockaddr_in6 *ipv6 = (struct sockaddr_in6 *)p-\u003eai_addr; addr = \u0026(ipv6-\u003esin6_addr); ipver = \"IPv6\"; } // 将 IP 地址转换为字符串并打印 inet_ntop(p-\u003eai_family, addr, ipstr, sizeof(ipstr)); printf(\"%s: %s\\n\", ipver, ipstr); } 释放地址信息： 使用完 addrinfo 结构体链表后，调用 freeaddrinfo 函数释放内存。 freeaddrinfo(res); ","date":"2024-06-14","objectID":"/posts/12b8a48/:3:16","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"示例 下面是一个完整的示例，演示如何使用 getaddrinfo 获取地址信息并打印： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetdb.h\u003e #include \u003carpa/inet.h\u003e int main(int argc, char *argv[]) { if (argc != 2) { fprintf(stderr, \"usage: showip hostname\\n\"); return 1; } struct addrinfo hints, *res, *p; int status; char ipstr[INET6_ADDRSTRLEN]; memset(\u0026hints, 0, sizeof hints); hints.ai_family = AF_UNSPEC; // AF_INET 或 AF_INET6 hints.ai_socktype = SOCK_STREAM; if ((status = getaddrinfo(argv[1], NULL, \u0026hints, \u0026res)) != 0) { fprintf(stderr, \"getaddrinfo: %s\\n\", gai_strerror(status)); return 2; } printf(\"IP addresses for %s:\\n\\n\", argv[1]); for (p = res; p != NULL; p = p-\u003eai_next) { void *addr; char *ipver; // 获取地址（IPv4 或 IPv6） if (p-\u003eai_family == AF_INET) { // IPv4 struct sockaddr_in *ipv4 = (struct sockaddr_in *)p-\u003eai_addr; addr = \u0026(ipv4-\u003esin_addr); ipver = \"IPv4\"; } else { // IPv6 struct sockaddr_in6 *ipv6 = (struct sockaddr_in6 *)p-\u003eai_addr; addr = \u0026(ipv6-\u003esin6_addr); ipver = \"IPv6\"; } // 将 IP 地址转换为字符串并打印 inet_ntop(p-\u003eai_family, addr, ipstr, sizeof ipstr); printf(\" %s: %s\\n\", ipver, ipstr); } freeaddrinfo(res); return 0; } 在这个示例中，程序接受一个主机名作为命令行参数，使用 getaddrinfo 函数获取该主机的地址信息，并打印所有 IP 地址。\\ ","date":"2024-06-14","objectID":"/posts/12b8a48/:3:17","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"getaddrinfo() getaddrinfo() 是一个用于网络编程的函数，用于将主机名和服务名转换为可用于 socket、bind 和 connect 等函数的地址信息。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:4:0","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"函数原型 #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetdb.h\u003e int getaddrinfo(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res); ","date":"2024-06-14","objectID":"/posts/12b8a48/:4:1","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"参数 node：主机名（如 “www.example.com”）或 IP 地址（如 “192.168.1.1”）。 service：服务名（如 “http”）或端口号（如 “80”）。 hints：指向一个 addrinfo 结构体的指针，用于指定查询的限制条件。可以为 NULL。 res：指向一个 addrinfo 结构体指针的指针，函数成功时会指向结果链表的头。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:4:2","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"返回值 成功时返回 0。 失败时返回一个非零错误代码，可以使用 gai_strerror() 函数获取错误信息。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:4:3","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"struct addrinfo 结构体 struct addrinfo { int ai_flags; // 输入标志 int ai_family; // 地址家族（AF_INET、AF_INET6 等） int ai_socktype; // 套接字类型（SOCK_STREAM、SOCK_DGRAM 等） int ai_protocol; // 协议（通常为 0 或 IPPROTO_TCP、IPPROTO_UDP） size_t ai_addrlen; // 套接字地址的长度 struct sockaddr *ai_addr; // 套接字地址（struct sockaddr） char *ai_canonname; // 官方主机名 struct addrinfo *ai_next; // 指向下一个 addrinfo 结构体的指针 }; ","date":"2024-06-14","objectID":"/posts/12b8a48/:4:4","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"示例 以下是一个使用 getaddrinfo() 获取地址信息并打印的完整示例： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetdb.h\u003e #include \u003carpa/inet.h\u003e int main(int argc, char *argv[]) { if (argc != 2) { fprintf(stderr, \"usage: showip hostname\\n\"); return 1; } struct addrinfo hints, *res, *p; int status; char ipstr[INET6_ADDRSTRLEN]; memset(\u0026hints, 0, sizeof hints); hints.ai_family = AF_UNSPEC; // AF_INET 或 AF_INET6 hints.ai_socktype = SOCK_STREAM; if ((status = getaddrinfo(argv[1], NULL, \u0026hints, \u0026res)) != 0) { fprintf(stderr, \"getaddrinfo: %s\\n\", gai_strerror(status)); return 2; } printf(\"IP addresses for %s:\\n\\n\", argv[1]); for (p = res; p != NULL; p = p-\u003eai_next) { void *addr; char *ipver; // 获取地址（IPv4 或 IPv6） if (p-\u003eai_family == AF_INET) { // IPv4 struct sockaddr_in *ipv4 = (struct sockaddr_in *)p-\u003eai_addr; addr = \u0026(ipv4-\u003esin_addr); ipver = \"IPv4\"; } else { // IPv6 struct sockaddr_in6 *ipv6 = (struct sockaddr_in6 *)p-\u003eai_addr; addr = \u0026(ipv6-\u003esin6_addr); ipver = \"IPv6\"; } // 将 IP 地址转换为字符串并打印 inet_ntop(p-\u003eai_family, addr, ipstr, sizeof ipstr); printf(\" %s: %s\\n\", ipver, ipstr); } freeaddrinfo(res); return 0; } ","date":"2024-06-14","objectID":"/posts/12b8a48/:4:5","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"说明 初始化 hints 结构体： memset(\u0026hints, 0, sizeof hints); hints.ai_family = AF_UNSPEC; // AF_INET 或 AF_INET6 hints.ai_socktype = SOCK_STREAM; 这里我们设置 hints 结构体，以指示我们对 IPv4 和 IPv6 地址以及流式套接字（TCP）感兴趣。 调用 getaddrinfo： if ((status = getaddrinfo(argv[1], NULL, \u0026hints, \u0026res)) != 0) { fprintf(stderr, \"getaddrinfo: %s\\n\", gai_strerror(status)); return 2; } 我们调用 getaddrinfo 函数，并检查其返回值以确定是否成功。 遍历返回的地址链表并打印每个地址： for (p = res; p != NULL; p = p-\u003eai_next) { // ... } 我们遍历返回的地址链表，并使用 inet_ntop 函数将地址转换为字符串格式，以便打印出来。 释放地址信息链表： freeaddrinfo(res); 最后，我们调用 freeaddrinfo 函数来释放 getaddrinfo 分配的内存。 通过上述示例，你可以看到如何使用 getaddrinfo 获取主机名的 IP 地址，并处理这些地址以进行进一步的网络通信。 socket ","date":"2024-06-14","objectID":"/posts/12b8a48/:4:6","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"socket函数 socket() 函数用于创建一个新的套接字，并返回一个套接字描述符。套接字描述符是一个整数，用于标识套接字。该函数是网络编程的基础，几乎所有的网络操作都需要使用它。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:5:0","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"函数原型 #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e int socket(int domain, int type, int protocol); ","date":"2024-06-14","objectID":"/posts/12b8a48/:5:1","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"参数 domain：指定套接字的协议家族。常见的值包括： PF_INET：IPv4 协议 PF_INET6：IPv6 协议 PF_UNIX：本地通信（Unix 域套接字） type：指定套接字的类型。常见的值包括： SOCK_STREAM：提供面向连接的稳定数据传输（TCP） SOCK_DGRAM：提供数据报文服务（UDP） SOCK_RAW：提供原始网络协议访问 protocol：指定套接字使用的协议。通常可以指定为 0，以选择默认协议。常见的协议包括： IPPROTO_TCP：TCP 协议 IPPROTO_UDP：UDP 协议 在调用 socket() 函数时，将 protocol 参数设置为 0 表示选择默认的协议。这个默认协议是由所选择的 domain（协议家族）和 type（套接字类型）共同决定的。通常，对于常用的协议家族和套接字类型组合，默认协议是我们所期望的协议。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:5:2","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"详细解释 AF_INET（IPv4）和 SOCK_STREAM（流式套接字）： 默认协议是 IPPROTO_TCP，即传输控制协议 (TCP)。 AF_INET（IPv4）和 SOCK_DGRAM（数据报套接字）： 默认协议是 IPPROTO_UDP，即用户数据报协议 (UDP)。 通过将 protocol 参数设置为 0，我们可以让系统根据 domain 和 type 自动选择合适的协议，而不需要明确指定协议类型。这样既简化了代码，又减少了人为错误的可能性。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:5:3","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"返回值 成功时返回一个套接字描述符（非负整数）。 失败时返回 -1，并设置 errno 来指示错误。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:5:4","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"示例 以下是创建一个 TCP 套接字的示例： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetinet/in.h\u003e #include \u003carpa/inet.h\u003e int main() { int sockfd; // 创建一个 IPv4, 流式(TCP)套接字 sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } printf(\"Socket created successfully. Socket descriptor: %d\\n\", sockfd); // 在此可以继续使用套接字进行连接、绑定、发送和接收数据等操作 // 关闭套接字 close(sockfd); return 0; } ","date":"2024-06-14","objectID":"/posts/12b8a48/:5:5","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"更复杂的示例 下面是一个创建 UDP 套接字并绑定到指定端口的示例： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetinet/in.h\u003e #include \u003carpa/inet.h\u003e #include \u003cunistd.h\u003e int main() { int sockfd; struct sockaddr_in server_addr; // 创建一个 IPv4, 数据报(UDP)套接字 sockfd = socket(AF_INET, SOCK_DGRAM, 0); if (sockfd == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } // 设置服务器地址和端口 memset(\u0026server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = INADDR_ANY; server_addr.sin_port = htons(12345); // 绑定套接字到地址和端口 if (bind(sockfd, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)) == -1) { perror(\"bind\"); close(sockfd); exit(EXIT_FAILURE); } printf(\"Socket bound to port 12345\\n\"); // 在此可以继续使用套接字进行发送和接收数据等操作 // 关闭套接字 close(sockfd); return 0; } 在这个示例中，服务器创建了一个 UDP 套接字，并绑定到端口 12345。之后，服务器可以使用该套接字进行数据的发送和接收操作。完成后，套接字被关闭。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:5:6","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"bind函数 bind() 函数用于将套接字与特定的地址（通常是本地地址）和端口绑定在一起。它通常用于服务器程序，以便在指定的地址和端口上监听客户端的连接或数据。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:6:0","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"函数原型 #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); ","date":"2024-06-14","objectID":"/posts/12b8a48/:6:1","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"参数 sockfd：由 socket() 函数返回的套接字描述符。 addr：指向包含要绑定的地址信息的 sockaddr 结构体的指针。 addrlen：addr 结构体的大小（字节数）。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:6:2","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"返回值 成功时返回 0。 失败时返回 -1，并设置 errno 来指示错误。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:6:3","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"常见错误 EACCES：权限被拒绝，通常是因为试图绑定到一个受保护的端口（例如，小于 1024 的端口）。 EADDRINUSE：指定的地址已经在使用中。 EBADF：sockfd 不是有效的文件描述符。 EINVAL：sockfd 已经绑定到一个地址。 ENOTSOCK：sockfd 不是一个套接字文件描述符。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:6:4","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"示例 以下是一个使用 bind() 函数绑定一个 IPv4 地址和端口的示例： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetinet/in.h\u003e #include \u003carpa/inet.h\u003e #include \u003cunistd.h\u003e int main() { int sockfd; struct sockaddr_in server_addr; // 创建一个 IPv4, 流式(TCP)套接字 sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } // 设置服务器地址和端口 memset(\u0026server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = INADDR_ANY; // 绑定到本地所有地址 server_addr.sin_port = htons(12345); // 绑定到端口 12345 // 绑定套接字到地址和端口 if (bind(sockfd, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)) == -1) { perror(\"bind\"); close(sockfd); exit(EXIT_FAILURE); } printf(\"Socket bound to port 12345\\n\"); // 继续进行其他操作，例如 listen() 和 accept() // 关闭套接字 close(sockfd); return 0; } ","date":"2024-06-14","objectID":"/posts/12b8a48/:6:5","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"详细步骤 创建套接字： sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } 这段代码创建了一个 IPv4, 流式(TCP)套接字。如果创建失败，socket() 返回 -1，并设置 errno。 设置服务器地址和端口： memset(\u0026server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = INADDR_ANY; // 绑定到本地所有地址 server_addr.sin_port = htons(12345); // 绑定到端口 12345 这里我们设置 server_addr 结构体，用于指定绑定的地址和端口。INADDR_ANY 表示绑定到所有本地 IP 地址。 绑定套接字： if (bind(sockfd, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)) == -1) { perror(\"bind\"); close(sockfd); exit(EXIT_FAILURE); } 调用 bind() 函数将套接字与指定的地址和端口绑定。如果绑定失败，bind() 返回 -1，并设置 errno。 后续操作： 在成功绑定套接字后，通常会进行其他操作，如调用 listen() 函数监听连接，然后使用 accept() 函数接受客户端连接。 关闭套接字： close(sockfd); 当不再需要套接字时，调用 close() 函数关闭套接字。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:6:6","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"UDP 示例 以下是一个使用 bind() 函数绑定一个 UDP 套接字的示例： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetinet/in.h\u003e #include \u003carpa/inet.h\u003e #include \u003cunistd.h\u003e int main() { int sockfd; struct sockaddr_in server_addr, client_addr; char buffer[1024]; socklen_t addr_len = sizeof(client_addr); // 创建一个 IPv4, 数据报(UDP)套接字 sockfd = socket(AF_INET, SOCK_DGRAM, 0); if (sockfd == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } // 设置服务器地址和端口 memset(\u0026server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = INADDR_ANY; server_addr.sin_port = htons(12345); // 绑定套接字到地址和端口 if (bind(sockfd, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)) == -1) { perror(\"bind\"); close(sockfd); exit(EXIT_FAILURE); } printf(\"Socket bound to port 12345\\n\"); // 接收来自客户端的数据 ssize_t recv_len = recvfrom(sockfd, buffer, sizeof(buffer) - 1, 0, (struct sockaddr *)\u0026client_addr, \u0026addr_len); if (recv_len == -1) { perror(\"recvfrom\"); close(sockfd); exit(EXIT_FAILURE); } buffer[recv_len] = '\\0'; printf(\"Received message: %s\\n\", buffer); // 关闭套接字 close(sockfd); return 0; } 在这个 UDP 示例中，我们创建了一个 UDP 套接字，并绑定到端口 12345，然后使用 recvfrom() 函数接收来自客户端的数据。完成后关闭套接字。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:6:7","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"listen函数 listen() 函数用于将套接字设置为被动模式，即用于接受来自客户端的连接请求。它通常在服务器程序中使用，listen() 函数配置的套接字可以接受连接请求，并通过 accept() 函数来处理这些请求。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:7:0","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"函数原型 #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e int listen(int sockfd, int backlog); ","date":"2024-06-14","objectID":"/posts/12b8a48/:7:1","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"参数 sockfd：由 socket() 函数返回的套接字描述符。 backlog：指定挂起连接队列的最大长度。当队列已满时，服务器将拒绝新的连接请求。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:7:2","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"返回值 成功时返回 0。 失败时返回 -1，并设置 errno 来指示错误。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:7:3","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"常见错误 EADDRINUSE：指定的地址已经在使用中。 EBADF：sockfd 不是有效的文件描述符。 ENOTSOCK：sockfd 不是一个套接字文件描述符。 EOPNOTSUPP：套接字类型不支持 listen 操作（例如，数据报套接字不能使用 listen）。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:7:4","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"使用示例 以下是一个简单的 TCP 服务器示例，展示如何使用 listen() 函数： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetinet/in.h\u003e #include \u003carpa/inet.h\u003e #include \u003cunistd.h\u003e int main() { int sockfd, new_sockfd; struct sockaddr_in server_addr, client_addr; socklen_t addr_len; char buffer[1024]; int backlog = 10; // 创建一个 IPv4, 流式(TCP)套接字 sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } // 设置服务器地址和端口 memset(\u0026server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = INADDR_ANY; // 绑定到本地所有地址 server_addr.sin_port = htons(12345); // 绑定到端口 12345 // 绑定套接字到地址和端口 if (bind(sockfd, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)) == -1) { perror(\"bind\"); close(sockfd); exit(EXIT_FAILURE); } // 监听连接请求 if (listen(sockfd, backlog) == -1) { perror(\"listen\"); close(sockfd); exit(EXIT_FAILURE); } printf(\"Listening on port 12345...\\n\"); while (1) { // 接受客户端连接 addr_len = sizeof(client_addr); new_sockfd = accept(sockfd, (struct sockaddr *)\u0026client_addr, \u0026addr_len); if (new_sockfd == -1) { perror(\"accept\"); continue; } printf(\"Accepted connection from %s\\n\", inet_ntoa(client_addr.sin_addr)); // 处理客户端连接 ssize_t bytes_received = recv(new_sockfd, buffer, sizeof(buffer) - 1, 0); if (bytes_received == -1) { perror(\"recv\"); } else { buffer[bytes_received] = '\\0'; printf(\"Received: %s\\n\", buffer); } // 关闭客户端连接 close(new_sockfd); } // 关闭服务器套接字 close(sockfd); return 0; } ","date":"2024-06-14","objectID":"/posts/12b8a48/:7:5","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"详细说明 创建套接字： sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } 创建一个 IPv4，流式 (TCP) 套接字。如果创建失败，socket() 返回 -1，并设置 errno。 设置服务器地址和端口： memset(\u0026server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = INADDR_ANY; // 绑定到本地所有地址 server_addr.sin_port = htons(12345); // 绑定到端口 12345 设置 server_addr 结构体，用于指定绑定的地址和端口。 绑定套接字： if (bind(sockfd, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)) == -1) { perror(\"bind\"); close(sockfd); exit(EXIT_FAILURE); } 调用 bind() 函数将套接字与指定的地址和端口绑定。如果绑定失败，bind() 返回 -1，并设置 errno。 监听连接请求： if (listen(sockfd, backlog) == -1) { perror(\"listen\"); close(sockfd); exit(EXIT_FAILURE); } 调用 listen() 函数将套接字设置为被动模式，准备接受连接请求。backlog 参数指定挂起连接队列的最大长度。 接受客户端连接： while (1) { addr_len = sizeof(client_addr); new_sockfd = accept(sockfd, (struct sockaddr *)\u0026client_addr, \u0026addr_len); if (new_sockfd == -1) { perror(\"accept\"); continue; } printf(\"Accepted connection from %s\\n\", inet_ntoa(client_addr.sin_addr)); // 处理客户端连接... close(new_sockfd); } 在一个无限循环中，调用 accept() 函数接受客户端连接。如果接受成功，accept() 返回一个新的套接字描述符，用于与客户端通信。 处理客户端连接： ssize_t bytes_received = recv(new_sockfd, buffer, sizeof(buffer) - 1, 0); if (bytes_received == -1) { perror(\"recv\"); } else { buffer[bytes_received] = '\\0'; printf(\"Received: %s\\n\", buffer); } 使用 recv() 函数从客户端接收数据，并打印接收到的数据。 关闭套接字： close(new_sockfd); close(sockfd); 当不再需要连接时，调用 close() 函数关闭套接字。 通过上述步骤，一个简单的 TCP 服务器可以接受客户端的连接请求，并处理这些请求。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:7:6","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"connect函数 connect() 函数用于将套接字连接到指定的地址。在客户端程序中，connect() 函数用于与服务器建立连接。在建立连接后，可以使用 send() 和 recv() 函数进行数据传输。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:8:0","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"函数原型 #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); ","date":"2024-06-14","objectID":"/posts/12b8a48/:8:1","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"参数 sockfd：由 socket() 函数返回的套接字描述符。 addr：指向包含要连接的目标地址信息的 sockaddr 结构体的指针。 addrlen：addr 结构体的大小（字节数）。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:8:2","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"返回值 成功时返回 0。 失败时返回 -1，并设置 errno 来指示错误。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:8:3","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"常见错误 EACCES：尝试连接到广播地址，但权限被拒绝。 EADDRINUSE：本地地址已在使用中。 EAFNOSUPPORT：地址家族不被支持。 EALREADY：操作正在进行中。 EBADF：sockfd 不是有效的文件描述符。 ECONNREFUSED：目标地址拒绝连接。 EINPROGRESS：操作正在进行中。 ETIMEDOUT：连接超时。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:8:4","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"示例 以下是一个使用 connect() 函数连接到服务器的示例： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetinet/in.h\u003e #include \u003carpa/inet.h\u003e #include \u003cunistd.h\u003e int main() { int sockfd; struct sockaddr_in server_addr; // 创建一个 IPv4, 流式(TCP)套接字 sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } // 设置服务器地址和端口 memset(\u0026server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_port = htons(12345); // 服务器端口 if (inet_pton(AF_INET, \"127.0.0.1\", \u0026server_addr.sin_addr) \u003c= 0) { perror(\"inet_pton\"); close(sockfd); exit(EXIT_FAILURE); } // 连接到服务器 if (connect(sockfd, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)) == -1) { perror(\"connect\"); close(sockfd); exit(EXIT_FAILURE); } printf(\"Connected to the server\\n\"); // 在此可以进行数据传输，例如使用 send() 和 recv() // 关闭套接字 close(sockfd); return 0; } ","date":"2024-06-14","objectID":"/posts/12b8a48/:8:5","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"详细说明 创建套接字： sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } 这段代码创建了一个 IPv4, 流式(TCP)套接字。如果创建失败，socket() 返回 -1，并设置 errno。 设置服务器地址和端口： memset(\u0026server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_port = htons(12345); // 服务器端口 if (inet_pton(AF_INET, \"127.0.0.1\", \u0026server_addr.sin_addr) \u003c= 0) { perror(\"inet_pton\"); close(sockfd); exit(EXIT_FAILURE); } 这里我们设置 server_addr 结构体，用于指定连接的服务器地址和端口。inet_pton 函数将 IPv4 地址从点分十进制转换为网络字节序。 连接到服务器： if (connect(sockfd, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)) == -1) { perror(\"connect\"); close(sockfd); exit(EXIT_FAILURE); } 调用 connect() 函数将套接字连接到指定的服务器地址。如果连接失败，connect() 返回 -1，并设置 errno。 数据传输： 在成功连接到服务器后，可以使用 send() 和 recv() 函数进行数据传输。 关闭套接字： close(sockfd); 当不再需要连接时，调用 close() 函数关闭套接字。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:8:6","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"UDP 示例 在使用 UDP 时，connect() 函数有些不同。尽管 UDP 是无连接协议，connect() 函数仍然可以用来设置默认的目标地址，使得之后的 send() 和 recv() 操作默认使用这个地址。 以下是一个使用 connect() 函数在 UDP 套接字上设置默认目标地址的示例： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetinet/in.h\u003e #include \u003carpa/inet.h\u003e #include \u003cunistd.h\u003e int main() { int sockfd; struct sockaddr_in server_addr; char *message = \"Hello, Server!\"; char buffer[1024]; ssize_t bytes_sent, bytes_received; // 创建一个 IPv4, 数据报(UDP)套接字 sockfd = socket(AF_INET, SOCK_DGRAM, 0); if (sockfd == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } // 设置服务器地址和端口 memset(\u0026server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_port = htons(12345); // 服务器端口 if (inet_pton(AF_INET, \"127.0.0.1\", \u0026server_addr.sin_addr) \u003c= 0) { perror(\"inet_pton\"); close(sockfd); exit(EXIT_FAILURE); } // 连接到服务器 if (connect(sockfd, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)) == -1) { perror(\"connect\"); close(sockfd); exit(EXIT_FAILURE); } printf(\"Connected to the server\\n\"); // 发送数据到服务器 bytes_sent = send(sockfd, message, strlen(message), 0); if (bytes_sent == -1) { perror(\"send\"); close(sockfd); exit(EXIT_FAILURE); } // 接收来自服务器的数据 bytes_received = recv(sockfd, buffer, sizeof(buffer) - 1, 0); if (bytes_received == -1) { perror(\"recv\"); close(sockfd); exit(EXIT_FAILURE); } buffer[bytes_received] = '\\0'; printf(\"Received message: %s\\n\", buffer); // 关闭套接字 close(sockfd); return 0; } 在这个 UDP 示例中，我们创建了一个 UDP 套接字，并使用 connect() 函数设置默认的目标地址。然后我们使用 send() 和 recv() 函数进行数据传输。尽管 UDP 是无连接的，但 connect() 提供了一种便捷的方式来指定默认目标地址。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:8:7","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"accept函数 accept() 函数用于接受来自客户端的连接请求。它在服务器程序中使用，允许服务器从已经处于监听状态的套接字队列中提取第一个连接请求，并返回一个新的套接字描述符，用于与客户端进行通信。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:9:0","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"函数原型 #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); ","date":"2024-06-14","objectID":"/posts/12b8a48/:9:1","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"参数 sockfd：由 socket() 和 bind() 函数创建和绑定，并通过 listen() 函数设置为监听状态的套接字描述符。 addr：指向一个 sockaddr 结构体的指针，用于存储已连接客户端的地址信息。如果不需要客户端的地址信息，可以传递 NULL。 addrlen：指向一个 socklen_t 变量的指针，该变量最初应设置为 addr 所指向的结构体的大小。函数返回时，这个变量包含了实际存储在 addr 结构体中的地址的大小。如果不需要客户端的地址信息，可以传递 NULL。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:9:2","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"返回值 成功时返回一个新的套接字描述符。 失败时返回 -1，并设置 errno 来指示错误。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:9:3","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"常见错误 EBADF：sockfd 不是有效的文件描述符。 EINTR：等待连接请求时被信号中断。 EINVAL：sockfd 没有绑定到地址或者没有监听状态。 ENOTSOCK：sockfd 不是一个套接字。 EOPNOTSUPP：sockfd 不是面向连接的套接字类型。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:9:4","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"使用示例 以下是一个简单的 TCP 服务器示例，展示如何使用 accept() 函数： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetinet/in.h\u003e #include \u003carpa/inet.h\u003e #include \u003cunistd.h\u003e int main() { int sockfd, new_sockfd; struct sockaddr_in server_addr, client_addr; socklen_t addr_len; char buffer[1024]; int backlog = 10; // 创建一个 IPv4, 流式(TCP)套接字 sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } // 设置服务器地址和端口 memset(\u0026server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = INADDR_ANY; // 绑定到本地所有地址 server_addr.sin_port = htons(12345); // 绑定到端口 12345 // 绑定套接字到地址和端口 if (bind(sockfd, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)) == -1) { perror(\"bind\"); close(sockfd); exit(EXIT_FAILURE); } // 监听连接请求 if (listen(sockfd, backlog) == -1) { perror(\"listen\"); close(sockfd); exit(EXIT_FAILURE); } printf(\"Listening on port 12345...\\n\"); while (1) { // 接受客户端连接 addr_len = sizeof(client_addr); new_sockfd = accept(sockfd, (struct sockaddr *)\u0026client_addr, \u0026addr_len); if (new_sockfd == -1) { perror(\"accept\"); continue; } printf(\"Accepted connection from %s\\n\", inet_ntoa(client_addr.sin_addr)); // 处理客户端连接 ssize_t bytes_received = recv(new_sockfd, buffer, sizeof(buffer) - 1, 0); if (bytes_received == -1) { perror(\"recv\"); } else { buffer[bytes_received] = '\\0'; printf(\"Received: %s\\n\", buffer); } // 关闭客户端连接 close(new_sockfd); } // 关闭服务器套接字 close(sockfd); return 0; } ","date":"2024-06-14","objectID":"/posts/12b8a48/:9:5","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"详细说明 创建套接字： sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } 创建一个 IPv4，流式 (TCP) 套接字。如果创建失败，socket() 返回 -1，并设置 errno。 设置服务器地址和端口： memset(\u0026server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = INADDR_ANY; // 绑定到本地所有地址 server_addr.sin_port = htons(12345); // 绑定到端口 12345 设置 server_addr 结构体，用于指定绑定的地址和端口。 绑定套接字： if (bind(sockfd, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)) == -1) { perror(\"bind\"); close(sockfd); exit(EXIT_FAILURE); } 调用 bind() 函数将套接字与指定的地址和端口绑定。如果绑定失败，bind() 返回 -1，并设置 errno。 监听连接请求： if (listen(sockfd, backlog) == -1) { perror(\"listen\"); close(sockfd); exit(EXIT_FAILURE); } 调用 listen() 函数将套接字设置为被动模式，准备接受连接请求。backlog 参数指定挂起连接队列的最大长度。 接受客户端连接： while (1) { addr_len = sizeof(client_addr); new_sockfd = accept(sockfd, (struct sockaddr *)\u0026client_addr, \u0026addr_len); if (new_sockfd == -1) { perror(\"accept\"); continue; } printf(\"Accepted connection from %s\\n\", inet_ntoa(client_addr.sin_addr)); // 处理客户端连接... close(new_sockfd); } 在一个无限循环中，调用 accept() 函数接受客户端连接。如果接受成功，accept() 返回一个新的套接字描述符，用于与客户端通信。 处理客户端连接： ssize_t bytes_received = recv(new_sockfd, buffer, sizeof(buffer) - 1, 0); if (bytes_received == -1) { perror(\"recv\"); } else { buffer[bytes_received] = '\\0'; printf(\"Received: %s\\n\", buffer); } 使用 recv() 函数从客户端接收数据，并打印接收到的数据。 关闭套接字： close(new_sockfd); close(sockfd); 当不再需要连接时，调用 close() 函数关闭套接字。 通过上述步骤，一个简单的 TCP 服务器可以接受客户端的连接请求，并处理这些请求。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:9:6","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"send() and recv() send() 和 recv() 函数用于在已连接的套接字之间进行数据传输。send() 用于发送数据，recv() 用于接收数据。这两个函数通常用于基于 TCP 的连接，但也可以用于连接到远程地址的 UDP 套接字。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:10:0","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"send() 函数 函数原型 #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e ssize_t send(int sockfd, const void *buf, size_t len, int flags); 参数 sockfd：套接字描述符，由 socket() 或 accept() 返回。 buf：指向要发送的数据的缓冲区。 len：要发送的数据长度。 flags：发送标志，通常设置为 0。 返回值 成功时返回发送的字节数。 失败时返回 -1，并设置 errno 来指示错误。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:10:1","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"recv() 函数 函数原型 #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e ssize_t recv(int sockfd, void *buf, size_t len, int flags); 参数 sockfd：套接字描述符，由 socket() 或 accept() 返回。 buf：指向用于接收数据的缓冲区。 len：缓冲区的长度。 flags：接收标志，通常设置为 0。 返回值 成功时返回接收到的字节数。如果连接被关闭，返回 0。 失败时返回 -1，并设置 errno 来指示错误。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:10:2","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"示例 以下是一个简单的 TCP 客户端和服务器示例，演示如何使用 send() 和 recv() 函数。 TCP 服务器 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetinet/in.h\u003e #include \u003carpa/inet.h\u003e #include \u003cunistd.h\u003e #define PORT 12345 #define BACKLOG 10 int main() { int sockfd, new_sockfd; struct sockaddr_in server_addr, client_addr; socklen_t addr_len; char buffer[1024]; ssize_t bytes_received; // 创建一个 IPv4, 流式(TCP)套接字 sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } // 设置服务器地址和端口 memset(\u0026server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = INADDR_ANY; // 绑定到本地所有地址 server_addr.sin_port = htons(PORT); // 绑定到端口 12345 // 绑定套接字到地址和端口 if (bind(sockfd, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)) == -1) { perror(\"bind\"); close(sockfd); exit(EXIT_FAILURE); } // 监听连接请求 if (listen(sockfd, BACKLOG) == -1) { perror(\"listen\"); close(sockfd); exit(EXIT_FAILURE); } printf(\"Listening on port %d...\\n\", PORT); while (1) { // 接受客户端连接 addr_len = sizeof(client_addr); new_sockfd = accept(sockfd, (struct sockaddr *)\u0026client_addr, \u0026addr_len); if (new_sockfd == -1) { perror(\"accept\"); continue; } printf(\"Accepted connection from %s\\n\", inet_ntoa(client_addr.sin_addr)); // 接收数据 bytes_received = recv(new_sockfd, buffer, sizeof(buffer) - 1, 0); if (bytes_received == -1) { perror(\"recv\"); close(new_sockfd); continue; } buffer[bytes_received] = '\\0'; printf(\"Received: %s\\n\", buffer); // 发送响应 const char *response = \"Message received\"; if (send(new_sockfd, response, strlen(response), 0) == -1) { perror(\"send\"); } // 关闭客户端连接 close(new_sockfd); } // 关闭服务器套接字 close(sockfd); return 0; } TCP 客户端 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetinet/in.h\u003e #include \u003carpa/inet.h\u003e #include \u003cunistd.h\u003e #define PORT 12345 #define SERVER_IP \"127.0.0.1\" int main() { int sockfd; struct sockaddr_in server_addr; char buffer[1024]; ssize_t bytes_sent, bytes_received; // 创建一个 IPv4, 流式(TCP)套接字 sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } // 设置服务器地址和端口 memset(\u0026server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_port = htons(PORT); // 服务器端口 if (inet_pton(AF_INET, SERVER_IP, \u0026server_addr.sin_addr) \u003c= 0) { perror(\"inet_pton\"); close(sockfd); exit(EXIT_FAILURE); } // 连接到服务器 if (connect(sockfd, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)) == -1) { perror(\"connect\"); close(sockfd); exit(EXIT_FAILURE); } // 发送数据 const char *message = \"Hello, Server!\"; bytes_sent = send(sockfd, message, strlen(message), 0); if (bytes_sent == -1) { perror(\"send\"); close(sockfd); exit(EXIT_FAILURE); } // 接收响应 bytes_received = recv(sockfd, buffer, sizeof(buffer) - 1, 0); if (bytes_received == -1) { perror(\"recv\"); close(sockfd); exit(EXIT_FAILURE); } buffer[bytes_received] = '\\0'; printf(\"Received from server: %s\\n\", buffer); // 关闭套接字 close(sockfd); return 0; } ","date":"2024-06-14","objectID":"/posts/12b8a48/:10:3","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"详细说明 创建套接字： sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } 这段代码创建一个流式 (TCP) 套接字。如果创建失败，socket() 返回 -1，并设置 errno。 设置地址和端口： memset(\u0026server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = INADDR_ANY; // 绑定到本地所有地址（服务器） server_addr.sin_port = htons(PORT); 设置 server_addr 结构体，用于指定绑定的地址和端口。 绑定和监听（服务器）： if (bind(sockfd, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)) == -1) { perror(\"bind\"); close(sockfd); exit(EXIT_FAILURE); } if (listen(sockfd, BACKLOG) == -1) { perror(\"listen\"); close(sockfd); exit(EXIT_FAILURE); } 调用 bind() 和 listen() 函数，将套接字绑定到指定的地址和端口，并使其进入监听状态。 接受连接（服务器）： new_sockfd = accept(sockfd, (struct sockaddr *)\u0026client_addr, \u0026addr_len); if (new_sockfd == -1) { perror(\"accept\"); continue; } 调用 accept() 函数接受客户端的连接请求。如果接受成功，accept() 返回一个新的套接字描述符，用于与客户端通信。 连接到服务器（客户端）： if (connect(sockfd, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)) == -1) { perror(\"connect\"); close(sockfd); exit(EXIT_FAILURE); } 调用 connect() 函数将客户端套接字连接到服务器。 发送数据： bytes_sent = send(sockfd, message, strlen(message), 0); if (bytes_sent == -1) { perror(\"send\"); close(sockfd); exit(EXIT_FAILURE); } 调用 send() 函数发送数据。如果发送失败，send() 返回 -1，并设置 errno。 接收数据： bytes_received = recv(new_sockfd, buffer, sizeof(buffer) - 1, 0); if (bytes_received == -1) { perror(\"recv\"); close(new_sockfd); continue; } buffer[bytes_received] = '\\0'; printf(\"Received: %s\\n\", buffer); 调用 recv() 函数接收数据。如果接 收失败，recv() 返回 -1，并设置 errno。 通过这些步骤，TCP 服务器和客户端可以通过 send() 和 recv() 函数进行数据传输。 send() 和 recv() 函数中的 flags 参数除了可以设置为 0 之外，还可以设置为一些其他的标志，以控制数据传输的行为。以下是一些常见的标志及其说明： ","date":"2024-06-14","objectID":"/posts/12b8a48/:10:4","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"send() 函数中的 flags MSG_DONTROUTE：告诉套接字绕过常规路由表查找，直接在本地网络上发送数据。 MSG_DONTWAIT：使操作变为非阻塞模式，如果操作不能立即完成，则返回 EAGAIN 或 EWOULDBLOCK 错误。 MSG_EOR：指示数据发送结束，适用于分段发送的数据流。 MSG_NOSIGNAL：防止在发送操作失败时发送 SIGPIPE 信号。 MSG_OOB：发送带外数据（TCP）。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:10:5","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"recv() 函数中的 flags MSG_DONTWAIT：使操作变为非阻塞模式，如果操作不能立即完成，则返回 EAGAIN 或 EWOULDBLOCK 错误。 MSG_PEEK：从套接字缓冲区中读取数据，但不将其移除，即之后再次调用 recv() 时仍能读取到相同的数据。 MSG_WAITALL：等待接收到所请求的所有数据后才返回，通常用于确保接收到完整的数据包。 MSG_OOB：接收带外数据（TCP）。 MSG_TRUNC：如果数据包长度超过缓冲区长度，数据会被截断，但返回的长度是原始数据包的长度。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:10:6","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"示例 使用 MSG_DONTWAIT 标志 以下是一个使用 MSG_DONTWAIT 标志的示例，使得 recv() 操作变为非阻塞模式： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetinet/in.h\u003e #include \u003carpa/inet.h\u003e #include \u003cunistd.h\u003e #include \u003cerrno.h\u003e #define PORT 12345 #define BUFFER_SIZE 1024 int main() { int sockfd; struct sockaddr_in server_addr; char buffer[BUFFER_SIZE]; ssize_t bytes_received; // 创建一个 IPv4, 流式(TCP)套接字 sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } // 设置服务器地址和端口 memset(\u0026server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_port = htons(PORT); if (inet_pton(AF_INET, \"127.0.0.1\", \u0026server_addr.sin_addr) \u003c= 0) { perror(\"inet_pton\"); close(sockfd); exit(EXIT_FAILURE); } // 连接到服务器 if (connect(sockfd, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)) == -1) { perror(\"connect\"); close(sockfd); exit(EXIT_FAILURE); } // 接收数据，非阻塞模式 bytes_received = recv(sockfd, buffer, BUFFER_SIZE - 1, MSG_DONTWAIT); if (bytes_received == -1) { if (errno == EAGAIN || errno == EWOULDBLOCK) { printf(\"No data available right now, try again later.\\n\"); } else { perror(\"recv\"); } } else if (bytes_received == 0) { printf(\"Connection closed by peer.\\n\"); } else { buffer[bytes_received] = '\\0'; printf(\"Received: %s\\n\", buffer); } // 关闭套接字 close(sockfd); return 0; } 使用 MSG_PEEK 标志 以下是一个使用 MSG_PEEK 标志的示例，从套接字缓冲区中读取数据，但不将其移除： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetinet/in.h\u003e #include \u003carpa/inet.h\u003e #include \u003cunistd.h\u003e #define PORT 12345 #define BUFFER_SIZE 1024 int main() { int sockfd, new_sockfd; struct sockaddr_in server_addr, client_addr; socklen_t addr_len; char buffer[BUFFER_SIZE]; ssize_t bytes_received; // 创建一个 IPv4, 流式(TCP)套接字 sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } // 设置服务器地址和端口 memset(\u0026server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = INADDR_ANY; // 绑定到本地所有地址 server_addr.sin_port = htons(PORT); // 绑定到端口 12345 // 绑定套接字到地址和端口 if (bind(sockfd, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)) == -1) { perror(\"bind\"); close(sockfd); exit(EXIT_FAILURE); } // 监听连接请求 if (listen(sockfd, 10) == -1) { perror(\"listen\"); close(sockfd); exit(EXIT_FAILURE); } printf(\"Listening on port %d...\\n\", PORT); // 接受客户端连接 addr_len = sizeof(client_addr); new_sockfd = accept(sockfd, (struct sockaddr *)\u0026client_addr, \u0026addr_len); if (new_sockfd == -1) { perror(\"accept\"); close(sockfd); exit(EXIT_FAILURE); } printf(\"Accepted connection from %s\\n\", inet_ntoa(client_addr.sin_addr)); // 使用 MSG_PEEK 读取数据但不移除 bytes_received = recv(new_sockfd, buffer, BUFFER_SIZE - 1, MSG_PEEK); if (bytes_received == -1) { perror(\"recv\"); close(new_sockfd); close(sockfd); exit(EXIT_FAILURE); } else { buffer[bytes_received] = '\\0'; printf(\"Peeked data: %s\\n\", buffer); } // 实际读取数据并移除 bytes_received = recv(new_sockfd, buffer, BUFFER_SIZE - 1, 0); if (bytes_received == -1) { perror(\"recv\"); } else { buffer[bytes_received] = '\\0'; printf(\"Received data: %s\\n\", buffer); } // 关闭套接字 close(new_sockfd); close(sockfd); return 0; } 通过这些示例，你可以看到 send() 和 recv() 函数中 flags 参数的不同设置如何影响数据传输的行为。根据具体应用的需求，可以选择适当的标志来控制数据传输。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:10:7","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"sendto() and recvfrom() sendto() 和 recvfrom() 函数用于在没有连接的情况下（如 UDP）进行数据传输。这些函数允许指定目标地址和端口，适用于面向数据报的套接字（如 UDP 套接字）。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:11:0","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"sendto() 函数 函数原型 #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen); 参数 sockfd：套接字描述符，由 socket() 返回。 buf：指向要发送的数据的缓冲区。 len：要发送的数据长度。 flags：发送标志，通常设置为 0。 dest_addr：指向 sockaddr 结构体的指针，包含目标地址和端口。 addrlen：dest_addr 结构体的大小（字节数）。 返回值 成功时返回发送的字节数。 失败时返回 -1，并设置 errno 来指示错误。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:11:1","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"recvfrom() 函数 函数原型 #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); 参数 sockfd：套接字描述符，由 socket() 返回。 buf：指向用于接收数据的缓冲区。 len：缓冲区的长度。 flags：接收标志，通常设置为 0。 src_addr：指向 sockaddr 结构体的指针，用于存储发送方的地址和端口。可以设置为 NULL。 addrlen：指向一个 socklen_t 变量的指针，最初应设置为 src_addr 所指向的结构体的大小。函数返回时，该变量包含实际存储在 src_addr 结构体中的地址的大小。可以设置为 NULL。 返回值 成功时返回接收到的字节数。如果连接被关闭，返回 0。 失败时返回 -1，并设置 errno 来指示错误。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:11:2","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"示例 以下是一个简单的 UDP 客户端和服务器示例，演示如何使用 sendto() 和 recvfrom() 函数进行数据传输。 UDP 服务器 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetinet/in.h\u003e #include \u003carpa/inet.h\u003e #include \u003cunistd.h\u003e #define PORT 12345 #define BUFFER_SIZE 1024 int main() { int sockfd; struct sockaddr_in server_addr, client_addr; socklen_t addr_len; char buffer[BUFFER_SIZE]; ssize_t bytes_received; // 创建一个 IPv4, 数据报(UDP)套接字 sockfd = socket(AF_INET, SOCK_DGRAM, 0); if (sockfd == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } // 设置服务器地址和端口 memset(\u0026server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = INADDR_ANY; // 绑定到本地所有地址 server_addr.sin_port = htons(PORT); // 绑定到端口 12345 // 绑定套接字到地址和端口 if (bind(sockfd, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)) == -1) { perror(\"bind\"); close(sockfd); exit(EXIT_FAILURE); } printf(\"Listening on port %d...\\n\", PORT); while (1) { // 接收来自客户端的数据 addr_len = sizeof(client_addr); bytes_received = recvfrom(sockfd, buffer, BUFFER_SIZE - 1, 0, (struct sockaddr *)\u0026client_addr, \u0026addr_len); if (bytes_received == -1) { perror(\"recvfrom\"); continue; } buffer[bytes_received] = '\\0'; printf(\"Received from %s: %s\\n\", inet_ntoa(client_addr.sin_addr), buffer); // 发送响应到客户端 const char *response = \"Message received\"; if (sendto(sockfd, response, strlen(response), 0, (struct sockaddr *)\u0026client_addr, addr_len) == -1) { perror(\"sendto\"); } } // 关闭套接字 close(sockfd); return 0; } UDP 客户端 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetinet/in.h\u003e #include \u003carpa/inet.h\u003e #include \u003cunistd.h\u003e #define PORT 12345 #define SERVER_IP \"127.0.0.1\" #define BUFFER_SIZE 1024 int main() { int sockfd; struct sockaddr_in server_addr; char buffer[BUFFER_SIZE]; ssize_t bytes_sent, bytes_received; socklen_t addr_len; // 创建一个 IPv4, 数据报(UDP)套接字 sockfd = socket(AF_INET, SOCK_DGRAM, 0); if (sockfd == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } // 设置服务器地址和端口 memset(\u0026server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_port = htons(PORT); // 服务器端口 if (inet_pton(AF_INET, SERVER_IP, \u0026server_addr.sin_addr) \u003c= 0) { perror(\"inet_pton\"); close(sockfd); exit(EXIT_FAILURE); } // 发送数据到服务器 const char *message = \"Hello, Server!\"; bytes_sent = sendto(sockfd, message, strlen(message), 0, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)); if (bytes_sent == -1) { perror(\"sendto\"); close(sockfd); exit(EXIT_FAILURE); } // 接收来自服务器的响应 addr_len = sizeof(server_addr); bytes_received = recvfrom(sockfd, buffer, BUFFER_SIZE - 1, 0, (struct sockaddr *)\u0026server_addr, \u0026addr_len); if (bytes_received == -1) { perror(\"recvfrom\"); close(sockfd); exit(EXIT_FAILURE); } buffer[bytes_received] = '\\0'; printf(\"Received from server: %s\\n\", buffer); // 关闭套接字 close(sockfd); return 0; } ","date":"2024-06-14","objectID":"/posts/12b8a48/:11:3","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"详细说明 创建套接字： sockfd = socket(AF_INET, SOCK_DGRAM, 0); if (sockfd == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } 创建一个数据报(UDP)套接字。如果创建失败，socket() 返回 -1，并设置 errno。 设置服务器地址和端口： memset(\u0026server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = INADDR_ANY; // 绑定到本地所有地址（服务器） server_addr.sin_port = htons(PORT); 设置 server_addr 结构体，用于指定绑定的地址和端口。 绑定套接字（服务器）： if (bind(sockfd, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)) == -1) { perror(\"bind\"); close(sockfd); exit(EXIT_FAILURE); } 调用 bind() 函数将套接字与指定的地址和端口绑定。如果绑定失败，bind() 返回 -1，并设置 errno。 发送数据（客户端）： bytes_sent = sendto(sockfd, message, strlen(message), 0, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)); if (bytes_sent == -1) { perror(\"sendto\"); close(sockfd); exit(EXIT_FAILURE); } 调用 sendto() 函数将数据发送到指定的目标地址和端口。如果发送失败，sendto() 返回 -1，并设置 errno。 接收数据： bytes_received = recvfrom(sockfd, buffer, BUFFER_SIZE - 1, 0, (struct sockaddr *)\u0026client_addr, \u0026addr_len); if (bytes_received == -1) { perror(\"recvfrom\"); continue; } buffer[bytes_received] = '\\0'; printf(\"Received from %s: %s\\n\", inet_ntoa(client_addr.sin_addr), buffer); 调用 recvfrom() 函数从指定的源地址和端口接收数据。如果接收失败，recvfrom() 返回 -1，并设置 errno。 通过这些步骤，UDP 服务器和客户端可以使用 sendto() 和 recvfrom() 函数进行数据传输。这些函数允许在没有连接的 ","date":"2024-06-14","objectID":"/posts/12b8a48/:11:4","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"close() and shutdown() close() 和 shutdown() 函数用于关闭套接字，但它们在行为和使用场景上有所不同。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:12:0","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"close() 函数 close() 函数用于关闭一个文件描述符（包括套接字）。调用 close() 后，文件描述符变为无效，不能再用于读写操作。 函数原型 #include \u003cunistd.h\u003e int close(int fd); 参数 fd：要关闭的文件描述符。 返回值 成功时返回 0。 失败时返回 -1，并设置 errno 来指示错误。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:12:1","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"使用示例 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e #include \u003cunistd.h\u003e int main() { int sockfd; // 创建一个套接字 sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } // 使用套接字进行一些操作... // 关闭套接字 if (close(sockfd) == -1) { perror(\"close\"); exit(EXIT_FAILURE); } printf(\"Socket closed successfully\\n\"); return 0; } ","date":"2024-06-14","objectID":"/posts/12b8a48/:12:2","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"shutdown() 函数 shutdown() 函数用于部分或完全关闭一个套接字的连接。与 close() 不同，shutdown() 允许只关闭套接字的一部分（如只关闭读或只关闭写）。 函数原型 #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e int shutdown(int sockfd, int how); 参数 sockfd：要关闭的套接字描述符。 how：指定如何关闭套接字。可以是以下值之一： SHUT_RD：关闭读这一半连接。 SHUT_WR：关闭写这一半连接。 SHUT_RDWR：同时关闭读和写。 返回值 成功时返回 0。 失败时返回 -1，并设置 errno 来指示错误。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:12:3","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"使用示例 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e #include \u003cunistd.h\u003e int main() { int sockfd; // 创建一个套接字 sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } // 使用套接字进行一些操作... // 关闭套接字的写端 if (shutdown(sockfd, SHUT_WR) == -1) { perror(\"shutdown\"); exit(EXIT_FAILURE); } printf(\"Socket write shutdown successfully\\n\"); // 关闭套接字的读端 if (shutdown(sockfd, SHUT_RD) == -1) { perror(\"shutdown\"); exit(EXIT_FAILURE); } printf(\"Socket read shutdown successfully\\n\"); // 完全关闭套接字 if (close(sockfd) == -1) { perror(\"close\"); exit(EXIT_FAILURE); } printf(\"Socket closed successfully\\n\"); return 0; } ","date":"2024-06-14","objectID":"/posts/12b8a48/:12:4","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"区别和使用场景 close()：完全关闭文件描述符，使其不可用。常用于释放资源。 使用场景：在不再需要使用套接字时调用，以释放资源。 shutdown()：部分或完全关闭套接字的连接。可以关闭读、写或读写。 使用场景：需要关闭套接字的某一部分连接（如不再需要发送数据但还需要接收数据）时使用。 通过这两个函数，可以灵活地控制套接字的关闭方式，确保资源的正确释放和网络连接的正确管理。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:12:5","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"tcp服务器 server.c #include \u003cunistd.h\u003e #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetdb.h\u003e #define MYPORT \"3490\" #define BACKLOG 10 int main() { struct sockaddr_storage their_addr; socklen_t addr_size; struct addrinfo hints, *res; int sockfd, new_fd; memset(\u0026hints, 0, sizeof hints); hints.ai_family = AF_UNSPEC; hints.ai_socktype = SOCK_STREAM; hints.ai_flags = AI_PASSIVE; int status = getaddrinfo(NULL, MYPORT, \u0026hints, \u0026res); if (status != 0) { fprintf(stderr, \"getaddrinfo error: %s\\n\", gai_strerror(status)); return 1; } sockfd = socket(res-\u003eai_family, res-\u003eai_socktype, res-\u003eai_protocol); if (sockfd == -1) { perror(\"socket\"); freeaddrinfo(res); return 1; } if (bind(sockfd, res-\u003eai_addr, res-\u003eai_addrlen) == -1) { close(sockfd); perror(\"bind\"); freeaddrinfo(res); return 1; } freeaddrinfo(res); if (listen(sockfd, BACKLOG) == -1) { perror(\"listen\"); close(sockfd); return 1; } addr_size = sizeof their_addr; new_fd = accept(sockfd, (struct sockaddr *)\u0026their_addr, \u0026addr_size); if (new_fd == -1) { perror(\"accept\"); close(sockfd); return 1; } else { printf(\"连接成功\\n\"); } char *msg = \"Hello, Meowrain, this is server\"; int len = strlen(msg); int bytes_sent = send(new_fd, msg, len, 0); if (bytes_sent == -1) { perror(\"send\"); } close(new_fd); close(sockfd); return 0; } client.c #include \u003cunistd.h\u003e #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetdb.h\u003e #define SERVERPORT \"3490\" // 与server端的端口一致 int main() { struct addrinfo hints, *res; int sockfd; // 设置hints memset(\u0026hints, 0, sizeof hints); hints.ai_family = AF_UNSPEC; hints.ai_socktype = SOCK_STREAM; // 获取server地址信息 int status = getaddrinfo(\"127.0.0.1\", SERVERPORT, \u0026hints, \u0026res); // 假设server在本地运行 if (status != 0) { fprintf(stderr, \"getaddrinfo error: %s\\n\", gai_strerror(status)); return 1; } // 创建socket sockfd = socket(res-\u003eai_family, res-\u003eai_socktype, res-\u003eai_protocol); if (sockfd == -1) { perror(\"socket\"); freeaddrinfo(res); return 1; } // 连接到server if (connect(sockfd, res-\u003eai_addr, res-\u003eai_addrlen) == -1) { perror(\"连接失败\"); close(sockfd); freeaddrinfo(res); return 1; } printf(\"连接成功\\n\"); // 可以在这里添加进一步的通信代码，比如发送或接收数据 char buffer[1024]; int bytes_received = recv(sockfd, buffer, sizeof(buffer) - 1, 0); if (bytes_received == -1) { perror(\"recv\"); } else { buffer[bytes_received] = '\\0'; // 确保字符串终止 printf(\"从服务器接收到消息: %s\\n\", buffer); } // 关闭socket close(sockfd); // 释放地址信息 freeaddrinfo(res); return 0; } ","date":"2024-06-14","objectID":"/posts/12b8a48/:13:0","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"udp服务器 udpserver.c #include \u003cunistd.h\u003e #include \u003cstring.h\u003e #include \u003cstdlib.h\u003e #include \u003cnetdb.h\u003e #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e #include \u003cstdio.h\u003e #define MYPORT \"8090\" int main() { struct addrinfo hints, *res; memset(\u0026hints, 0, sizeof hints); hints.ai_family = AF_INET; // 使用 IPv4 hints.ai_socktype = SOCK_DGRAM; // 使用 UDP hints.ai_flags = AI_PASSIVE; // 使用我的 IP int status = getaddrinfo(NULL, MYPORT, \u0026hints, \u0026res); if (status != 0) { fprintf(stderr, \"getaddrinfo error: %s\\n\", gai_strerror(status)); return 1; } int sockfd; if ((sockfd = socket(res-\u003eai_family, res-\u003eai_socktype, res-\u003eai_protocol)) == -1) { perror(\"socket\"); freeaddrinfo(res); return 1; } if (bind(sockfd, res-\u003eai_addr, res-\u003eai_addrlen) == -1) { perror(\"bind\"); close(sockfd); freeaddrinfo(res); return 1; } struct sockaddr_storage their_addr; socklen_t addr_len = sizeof their_addr; char buf[100]; int numbytes = recvfrom(sockfd, buf, sizeof buf, 0, (struct sockaddr *)\u0026their_addr, \u0026addr_len); if (numbytes == -1) { perror(\"recvfrom\"); close(sockfd); freeaddrinfo(res); return 1; } printf(\"Received: %s\\n\", buf); char *msg = \"UDP server response\"; int bytes_sent = sendto(sockfd, msg, strlen(msg), 0, (struct sockaddr *)\u0026their_addr, addr_len); if (bytes_sent == -1) { perror(\"sendto\"); close(sockfd); freeaddrinfo(res); return 1; } printf(\"Message sent: %s\\n\", msg); close(sockfd); freeaddrinfo(res); return 0; } udpclient.c #include \u003cunistd.h\u003e #include \u003cstring.h\u003e #include \u003cstdlib.h\u003e #include \u003cnetdb.h\u003e #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e #include \u003cstdio.h\u003e #define SERVERPORT \"8090\" #define SERVERADDR \"127.0.0.1\" int main() { struct addrinfo hints, *res; memset(\u0026hints, 0, sizeof hints); hints.ai_family = AF_INET; // 使用 IPv4 hints.ai_socktype = SOCK_DGRAM; // 使用 UDP int status = getaddrinfo(SERVERADDR, SERVERPORT, \u0026hints, \u0026res); if (status != 0) { fprintf(stderr, \"getaddrinfo error: %s\\n\", gai_strerror(status)); return 1; } int sockfd; if ((sockfd = socket(res-\u003eai_family, res-\u003eai_socktype, res-\u003eai_protocol)) == -1) { perror(\"socket\"); freeaddrinfo(res); return 1; } char *msg = \"Hello, UDP server!\"; int bytes_sent = sendto(sockfd, msg, strlen(msg), 0, res-\u003eai_addr, res-\u003eai_addrlen); if (bytes_sent == -1) { perror(\"sendto\"); close(sockfd); freeaddrinfo(res); return 1; } printf(\"Message sent: %s\\n\", msg); struct sockaddr_storage their_addr; socklen_t addr_len = sizeof their_addr; char buf[100]; int numbytes = recvfrom(sockfd, buf, sizeof buf, 0, (struct sockaddr *)\u0026their_addr, \u0026addr_len); if (numbytes == -1) { perror(\"recvfrom\"); close(sockfd); freeaddrinfo(res); return 1; } buf[numbytes] = '\\0'; // Null-terminate the received data printf(\"Received: %s\\n\", buf); close(sockfd); freeaddrinfo(res); return 0; } ","date":"2024-06-14","objectID":"/posts/12b8a48/:14:0","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"getpeername() 是的，在我之前的示例中，使用 getpeername() 函数获取的远程地址信息实际上与通过 accept() 获取的客户端地址信息是相同的。这是因为 accept() 函数已经提供了客户端的地址信息，并存储在 client_addr 结构体中。 为了更好地说明 getpeername() 的使用场景，我将提供一个更清晰的示例。我们将在接受客户端连接后使用 getpeername() 来获取远程客户端的地址信息，以展示如何使用该函数。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:15:0","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"示例：使用 getpeername() 获取客户端地址信息 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetinet/in.h\u003e #include \u003carpa/inet.h\u003e #include \u003cunistd.h\u003e #define PORT 12345 #define BACKLOG 10 int main() { int sockfd, new_sockfd; struct sockaddr_in server_addr, client_addr; struct sockaddr_in peer_addr; socklen_t addr_len, peer_addr_len; char buffer[1024]; ssize_t bytes_received; // 创建一个 IPv4, 流式(TCP)套接字 sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } // 设置服务器地址和端口 memset(\u0026server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = INADDR_ANY; // 绑定到本地所有地址 server_addr.sin_port = htons(PORT); // 绑定到端口 12345 // 绑定套接字到地址和端口 if (bind(sockfd, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)) == -1) { perror(\"bind\"); close(sockfd); exit(EXIT_FAILURE); } // 监听连接请求 if (listen(sockfd, BACKLOG) == -1) { perror(\"listen\"); close(sockfd); exit(EXIT_FAILURE); } printf(\"Listening on port %d...\\n\", PORT); // 接受客户端连接 addr_len = sizeof(client_addr); new_sockfd = accept(sockfd, (struct sockaddr *)\u0026client_addr, \u0026addr_len); if (new_sockfd == -1) { perror(\"accept\"); close(sockfd); exit(EXIT_FAILURE); } printf(\"Accepted connection from %s:%d\\n\", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port)); // 获取远程端地址信息 peer_addr_len = sizeof(peer_addr); if (getpeername(new_sockfd, (struct sockaddr *)\u0026peer_addr, \u0026peer_addr_len) == -1) { perror(\"getpeername\"); close(new_sockfd); close(sockfd); exit(EXIT_FAILURE); } printf(\"Peer address (from getpeername): %s, port: %d\\n\", inet_ntoa(peer_addr.sin_addr), ntohs(peer_addr.sin_port)); // 接收数据 bytes_received = recv(new_sockfd, buffer, sizeof(buffer) - 1, 0); if (bytes_received == -1) { perror(\"recv\"); } else { buffer[bytes_received] = '\\0'; printf(\"Received: %s\\n\", buffer); } // 发送响应 const char *response = \"Message received\"; if (send(new_sockfd, response, strlen(response), 0) == -1) { perror(\"send\"); } // 关闭客户端连接 close(new_sockfd); // 关闭服务器套接字 close(sockfd); return 0; } ","date":"2024-06-14","objectID":"/posts/12b8a48/:15:1","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"说明 创建套接字： sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } 设置服务器地址和端口： memset(\u0026server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = INADDR_ANY; server_addr.sin_port = htons(PORT); 绑定套接字： if (bind(sockfd, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)) == -1) { perror(\"bind\"); close(sockfd); exit(EXIT_FAILURE); } 监听连接请求： if (listen(sockfd, BACKLOG) == -1) { perror(\"listen\"); close(sockfd); exit(EXIT_FAILURE); } 接受客户端连接： addr_len = sizeof(client_addr); new_sockfd = accept(sockfd, (struct sockaddr *)\u0026client_addr, \u0026addr_len); if (new_sockfd == -1) { perror(\"accept\"); close(sockfd); exit(EXIT_FAILURE); } 打印客户端地址信息： printf(\"Accepted connection from %s:%d\\n\", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port)); 使用 getpeername() 获取远程端地址信息： peer_addr_len = sizeof(peer_addr); if (getpeername(new_sockfd, (struct sockaddr *)\u0026peer_addr, \u0026peer_addr_len) == -1) { perror(\"getpeername\"); close(new_sockfd); close(sockfd); exit(EXIT_FAILURE); } printf(\"Peer address (from getpeername): %s, port: %d\\n\", inet_ntoa(peer_addr.sin_addr), ntohs(peer_addr.sin_port)); 接收数据并发送响应： bytes_received = recv(new_sockfd, buffer, sizeof(buffer) - 1, 0); if (bytes_received == -1) { perror(\"recv\"); } else { buffer[bytes_received] = '\\0'; printf(\"Received: %s\\n\", buffer); } const char *response = \"Message received\"; if (send(new_sockfd, response, strlen(response), 0) == -1) { perror(\"send\"); } 关闭套接字： close(new_sockfd); close(sockfd); 通过这个示例，可以看到 getpeername() 函数如何用来获取已连接客户端的地址信息。尽管在大多数情况下，我们可以通过 accept() 直接获取客户端地址，但 getpeername() 提供了一种额外的方法来获取这个信息。 阻塞 ","date":"2024-06-14","objectID":"/posts/12b8a48/:15:2","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"fcntl() fcntl() 是一个用于操作文件描述符的系统调用，常用于设置文件描述符的属性、获取文件状态信息以及执行文件锁定等操作。它在网络编程中也常用于设置套接字的非阻塞模式。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:16:0","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"函数原型 #include \u003cfcntl.h\u003e int fcntl(int fd, int cmd, ... /* arg */ ); ","date":"2024-06-14","objectID":"/posts/12b8a48/:16:1","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"参数 fd：要操作的文件描述符。 cmd：要执行的操作命令。 arg：可选参数，根据 cmd 的不同，参数的数量和类型也不同。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:16:2","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"常用命令 F_GETFL：获取文件描述符状态标志。 F_SETFL：设置文件描述符状态标志。 F_GETFD：获取文件描述符标志。 F_SETFD：设置文件描述符标志。 F_SETLK：设置文件锁（非阻塞）。 F_SETLKW：设置文件锁（阻塞）。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:16:3","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"设置非阻塞模式 在网络编程中，常见的用法是将套接字设置为非阻塞模式。以下是如何使用 fcntl() 将套接字设置为非阻塞模式的示例： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003carpa/inet.h\u003e #include \u003cfcntl.h\u003e #include \u003cerrno.h\u003e #define PORT 12345 #define BUFFER_SIZE 1024 void set_non_blocking(int socket); int main() { int server_socket, client_socket; struct sockaddr_in server_addr, client_addr; socklen_t client_addr_len = sizeof(client_addr); char buffer[BUFFER_SIZE]; ssize_t bytes_received; // 创建套接字 server_socket = socket(AF_INET, SOCK_STREAM, 0); if (server_socket == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } // 设置服务器地址和端口 server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = INADDR_ANY; server_addr.sin_port = htons(PORT); // 绑定套接字 if (bind(server_socket, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)) == -1) { perror(\"bind\"); close(server_socket); exit(EXIT_FAILURE); } // 监听连接请求 if (listen(server_socket, 10) == -1) { perror(\"listen\"); close(server_socket); exit(EXIT_FAILURE); } printf(\"Server listening on port %d\\n\", PORT); // 设置服务器套接字为非阻塞模式 set_non_blocking(server_socket); while (1) { // 接受客户端连接 client_socket = accept(server_socket, (struct sockaddr *)\u0026client_addr, \u0026client_addr_len); if (client_socket == -1) { if (errno == EWOULDBLOCK || errno == EAGAIN) { // 没有可接受的连接，继续循环 usleep(100000); // 睡眠100毫秒 continue; } else { perror(\"accept\"); close(server_socket); exit(EXIT_FAILURE); } } printf(\"New client connected\\n\"); // 设置客户端套接字为非阻塞模式 set_non_blocking(client_socket); // 接收数据 while (1) { bytes_received = recv(client_socket, buffer, BUFFER_SIZE - 1, 0); if (bytes_received == -1) { if (errno == EWOULDBLOCK || errno == EAGAIN) { // 没有更多数据，继续循环 perror(\"info\"); usleep(100000); // 睡眠100毫秒 continue; } else { perror(\"recv\"); close(client_socket); break; } } else if (bytes_received == 0) { // 客户端关闭连接 printf(\"Client disconnected\\n\"); close(client_socket); break; } else { buffer[bytes_received] = '\\0'; printf(\"Received message: %s\\n\", buffer); send(client_socket, buffer, bytes_received, 0); } } } close(server_socket); return 0; } void set_non_blocking(int socket) { int flags; // 获取文件描述符的标志 flags = fcntl(socket, F_GETFL, 0); if (flags == -1) { perror(\"fcntl(F_GETFL)\"); exit(EXIT_FAILURE); } // 设置非阻塞标志 flags |= O_NONBLOCK; if (fcntl(socket, F_SETFL, flags) == -1) { perror(\"fcntl(F_SETFL)\"); exit(EXIT_FAILURE); } } ","date":"2024-06-14","objectID":"/posts/12b8a48/:16:4","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"阻塞模式和非阻塞模式 设置套接字为非阻塞模式后，你可以高效地“轮询”套接字以获取信息。非阻塞模式的一个重要特性是，当你尝试从非阻塞套接字读取数据但没有数据可读时，读取操作不会阻塞进程，而是立即返回 -1，并将 errno 设置为 EAGAIN 或 EWOULDBLOCK。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:17:0","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"具体解释 阻塞模式下的行为： 默认情况下，套接字操作（如 recv() 或 send()）是阻塞的。这意味着，如果你调用 recv() 读取数据，而没有数据可供读取，recv() 调用会阻塞，直到有数据可读或发生错误。 非阻塞模式下的行为： 在非阻塞模式下，如果你调用 recv() 读取数据，而没有数据可供读取，recv() 调用不会阻塞，而是立即返回 -1，并将 errno 设置为 EAGAIN 或 EWOULDBLOCK。 同样地，如果你调用 send() 发送数据，但发送缓冲区已满，send() 调用不会阻塞，而是立即返回 -1，并将 errno 设置为 EAGAIN 或 EWOULDBLOCK。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:17:1","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"示例代码 以下是一个设置套接字为非阻塞模式，并处理 recv() 返回值的示例： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003carpa/inet.h\u003e #include \u003cfcntl.h\u003e #include \u003cerrno.h\u003e #define PORT 12345 #define BUFFER_SIZE 1024 void set_non_blocking(int socket); int main() { int server_socket, client_socket; struct sockaddr_in server_addr, client_addr; socklen_t client_addr_len = sizeof(client_addr); char buffer[BUFFER_SIZE]; ssize_t bytes_received; // 创建套接字 server_socket = socket(AF_INET, SOCK_STREAM, 0); if (server_socket == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } // 设置服务器地址和端口 server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = INADDR_ANY; server_addr.sin_port = htons(PORT); // 绑定套接字 if (bind(server_socket, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)) == -1) { perror(\"bind\"); close(server_socket); exit(EXIT_FAILURE); } // 监听连接请求 if (listen(server_socket, 10) == -1) { perror(\"listen\"); close(server_socket); exit(EXIT_FAILURE); } printf(\"Server listening on port %d\\n\", PORT); // 设置服务器套接字为非阻塞模式 set_non_blocking(server_socket); while (1) { // 接受客户端连接 client_socket = accept(server_socket, (struct sockaddr *)\u0026client_addr, \u0026client_addr_len); if (client_socket == -1) { if (errno == EWOULDBLOCK || errno == EAGAIN) { // 没有可接受的连接，继续循环 usleep(100000); // 睡眠100毫秒 continue; } else { perror(\"accept\"); close(server_socket); exit(EXIT_FAILURE); } } // 设置客户端套接字为非阻塞模式 set_non_blocking(client_socket); // 接收数据 while (1) { bytes_received = recv(client_socket, buffer, BUFFER_SIZE - 1, 0); if (bytes_received \u003e 0) { buffer[bytes_received] = '\\0'; printf(\"Received message: %s\\n\", buffer); send(client_socket, buffer, bytes_received, 0); } else if (bytes_received == 0) { // 客户端关闭连接 close(client_socket); break; } else { if (errno == EWOULDBLOCK || errno == EAGAIN) { // 没有更多数据，继续循环 usleep(100000); // 睡眠100毫秒 continue; } else { perror(\"recv\"); close(client_socket); break; } } } } close(server_socket); return 0; } void set_non_blocking(int socket) { int flags; // 获取文件描述符的标志 flags = fcntl(socket, F_GETFL, 0); if (flags == -1) { perror(\"fcntl(F_GETFL)\"); exit(EXIT_FAILURE); } // 设置非阻塞标志 flags |= O_NONBLOCK; if (fcntl(socket, F_SETFL, flags) == -1) { perror(\"fcntl(F_SETFL)\"); exit(EXIT_FAILURE); } } ","date":"2024-06-14","objectID":"/posts/12b8a48/:17:2","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"代码解释 创建和绑定套接字： 创建一个 TCP 套接字，绑定到指定端口，并开始监听连接请求。 设置套接字为非阻塞模式： void set_non_blocking(int socket) { int flags; flags = fcntl(socket, F_GETFL, 0); if (flags == -1) { perror(\"fcntl(F_GETFL)\"); exit(EXIT_FAILURE); } flags |= O_NONBLOCK; if (fcntl(socket, F_SETFL, flags) == -1) { perror(\"fcntl(F_SETFL)\"); exit(EXIT_FAILURE); } } 接受和处理客户端连接： 使用 accept() 接受客户端连接。由于套接字是非阻塞的，如果没有可接受的连接，accept() 会立即返回 -1，并将 errno 设置为 EWOULDBLOCK 或 EAGAIN。在这种情况下，程序会继续循环，等待新的连接请求。 接收数据时，如果没有数据可读，recv() 会立即返回 -1，并将 errno 设置为 EWOULDBLOCK 或 EAGAIN。程序会继续循环，等待新的数据到达。 通过这种方式，程序可以有效地处理多个客户端连接，而不会因为一个客户端的操作而阻塞整个服务器。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:17:3","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"非阻塞模式的问题 通过非阻塞套接字进行轮询（polling）来检查是否有数据可读可能会导致高 CPU 占用，因为程序可能会在无数据可读的情况下频繁轮询。这种情况下，使用更高效的方法来监控多个文件描述符的状态，例如 poll() 或 select()，会是更优雅的解决方案 ","date":"2024-06-14","objectID":"/posts/12b8a48/:17:4","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"poll() poll() 是一种用于同步 I/O 多路复用的系统调用，它允许程序在多个文件描述符上等待事件。它是 select() 的改进版本，提供了更好的可扩展性和灵活性。poll() 常用于网络编程中，特别是当你需要同时处理多个网络连接时。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:18:0","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"poll() 函数原型 #include \u003cpoll.h\u003e int poll(struct pollfd *fds, nfds_t nfds, int timeout); ","date":"2024-06-14","objectID":"/posts/12b8a48/:18:1","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"参数 fds：一个 pollfd 结构体数组，描述要监视的文件描述符及其事件。 nfds：要监视的文件描述符数量。 timeout：等待的超时时间（毫秒）。如果为 -1，则无限等待。如果为 0，则立即返回。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:18:2","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"pollfd 结构体 struct pollfd { int fd; // the socket descriptor short events; // bitmap of events we're interested in short revents; // when poll() returns, bitmap of events that occurred }; ","date":"2024-06-14","objectID":"/posts/12b8a48/:18:3","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"常用事件标志 POLLIN：有数据可读。 POLLOUT：可以写数据。 POLLERR：发生错误。 POLLHUP：挂起。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:18:4","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"使用 poll() 的示例 以下是一个使用 poll() 的示例，演示如何使用它来处理多个客户端连接。这个示例代码实现了一个简单的回显服务器，能够同时处理多个客户端的连接和数据传输。 服务器代码 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003carpa/inet.h\u003e #include \u003cpoll.h\u003e #include \u003cerrno.h\u003e #define PORT 12345 #define BUFFER_SIZE 1024 #define MAX_CLIENTS 100 int main() { int server_socket, client_socket; struct sockaddr_in server_addr, client_addr; socklen_t client_addr_len = sizeof(client_addr); char buffer[BUFFER_SIZE]; ssize_t bytes_received; struct pollfd fds[MAX_CLIENTS]; int nfds = 1; // 初始只有一个服务器套接字 // 创建套接字 server_socket = socket(AF_INET, SOCK_STREAM, 0); if (server_socket == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } // 设置服务器地址和端口 server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = INADDR_ANY; server_addr.sin_port = htons(PORT); // 绑定套接字 if (bind(server_socket, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)) == -1) { perror(\"bind\"); close(server_socket); exit(EXIT_FAILURE); } // 监听连接请求 if (listen(server_socket, 10) == -1) { perror(\"listen\"); close(server_socket); exit(EXIT_FAILURE); } printf(\"Server listening on port %d\\n\", PORT); // 初始化 pollfd 结构体 fds[0].fd = server_socket; fds[0].events = POLLIN; while (1) { int poll_count = poll(fds, nfds, -1); // 无限等待 if (poll_count == -1) { perror(\"poll\"); close(server_socket); exit(EXIT_FAILURE); } for (int i = 0; i \u003c nfds; i++) { if (fds[i].revents \u0026 POLLIN) { if (fds[i].fd == server_socket) { // 接受新连接 client_socket = accept(server_socket, (struct sockaddr *)\u0026client_addr, \u0026client_addr_len); if (client_socket == -1) { perror(\"accept\"); } else { printf(\"New connection accepted\\n\"); fds[nfds].fd = client_socket; fds[nfds].events = POLLIN; nfds++; } } else { // 处理现有连接的数据 bytes_received = recv(fds[i].fd, buffer, BUFFER_SIZE - 1, 0); if (bytes_received \u003e 0) { buffer[bytes_received] = '\\0'; printf(\"Received message: %s\\n\", buffer); send(fds[i].fd, buffer, bytes_received, 0); } else if (bytes_received == 0) { // 客户端关闭连接 printf(\"Client disconnected\\n\"); close(fds[i].fd); fds[i] = fds[nfds - 1]; nfds--; } else { perror(\"recv\"); close(fds[i].fd); fds[i] = fds[nfds - 1]; nfds--; } } } } } close(server_socket); return 0; } ","date":"2024-06-14","objectID":"/posts/12b8a48/:18:5","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"代码说明 初始化服务器套接字： 创建一个 TCP 套接字，绑定到指定端口，并开始监听连接请求。 初始化 pollfd 结构体数组： fds[0].fd = server_socket; fds[0].events = POLLIN; 使用 poll() 监视文件描述符： 无限等待有事件发生。 检查每个文件描述符的事件。 处理新连接和现有连接的数据： 如果有新的连接请求，接受连接并将新客户端添加到 pollfd 数组中。 如果有数据可读，读取数据并回显给客户端。 处理客户端断开： 如果客户端关闭连接，移除对应的文件描述符。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:18:6","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"注意事项 文件描述符数量：虽然 poll() 没有 select() 那样的文件描述符数量限制，但你仍然需要确保 pollfd 数组的大小足够大，以容纳你要监视的所有文件描述符。 错误处理：务必处理 poll() 调用中的错误情况，如 poll() 返回 -1 时的错误处理。 性能优化：对于大量客户端连接的高并发场景，可以考虑使用 epoll（在 Linux 上）或其他更高效的 I/O 多路复用机制。 通过使用 poll()，你可以更高效地监视和处理多个文件描述符上的 I/O 事件，从而构建更高性能的网络服务器。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:18:7","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"阻塞IO和非阻塞IO下poll的行为状态区别 在使用 poll() 的情况下，套接字是否设置为非阻塞模式会影响到 accept() 和 recv() 等 I/O 操作的行为。以下是阻塞模式和非阻塞模式下使用 poll() 的区别和影响： ","date":"2024-06-14","objectID":"/posts/12b8a48/:19:0","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"阻塞模式下使用 poll() 行为 poll()： poll() 会阻塞，直到至少一个文件描述符上有指定的事件发生。 accept() 和 recv()： accept()：如果没有新的连接请求，会阻塞，直到有新的连接请求到来。 recv()：如果没有数据可读，会阻塞，直到有数据到来。 优点 简单直观：编写阻塞模式代码更简单，不需要处理 EWOULDBLOCK 和 EAGAIN 等错误。 适用于低并发：在低并发情况下，阻塞模式的性能和响应时间可能已经足够。 缺点 可能会导致性能瓶颈：在高并发情况下，如果某个 accept() 或 recv() 调用阻塞，可能会导致整个应用程序的其他部分无法及时响应。 整体响应时间可能更长：由于阻塞操作，某些客户端可能会遭遇较长的等待时间。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:19:1","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"非阻塞模式下使用 poll() 行为 poll()： poll() 会阻塞，直到至少一个文件描述符上有指定的事件发生。 accept() 和 recv()： accept()：如果没有新的连接请求，会立即返回 -1，并设置 errno 为 EWOULDBLOCK 或 EAGAIN。 recv()：如果没有数据可读，会立即返回 -1，并设置 errno 为 EWOULDBLOCK 或 EAGAIN。 优点 提高并发处理能力：非阻塞模式下，程序不会因为单个阻塞操作而被挂起，能够更高效地处理大量并发连接。 更低的延迟：非阻塞模式下，I/O 操作可以更快地返回，提高了整体响应速度。 缺点 编码更复杂：需要处理 EWOULDBLOCK 和 EAGAIN 错误，并在这些错误发生时采取适当的行动（如继续轮询）。 资源管理更复杂：需要注意处理频繁的非阻塞 I/O 操作带来的 CPU 占用。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:19:2","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"示例对比 阻塞模式示例 while (1) { int poll_count = poll(fds, nfds, -1); // 无限等待 if (poll_count == -1) { perror(\"poll\"); close(server_socket); exit(EXIT_FAILURE); } for (int i = 0; i \u003c nfds; i++) { if (fds[i].revents \u0026 POLLIN) { if (fds[i].fd == server_socket) { // 接受新连接，可能阻塞 client_socket = accept(server_socket, (struct sockaddr *)\u0026client_addr, \u0026client_addr_len); if (client_socket == -1) { perror(\"accept\"); } else { fds[nfds].fd = client_socket; fds[nfds].events = POLLIN; nfds++; } } else { // 读取数据，可能阻塞 bytes_received = recv(fds[i].fd, buffer, BUFFER_SIZE - 1, 0); if (bytes_received \u003e 0) { buffer[bytes_received] = '\\0'; send(fds[i].fd, buffer, bytes_received, 0); } else if (bytes_received == 0) { close(fds[i].fd); fds[i] = fds[nfds - 1]; nfds--; } else { perror(\"recv\"); close(fds[i].fd); fds[i] = fds[nfds - 1]; nfds--; } } } } } 非阻塞模式示例 void set_non_blocking(int socket) { int flags = fcntl(socket, F_GETFL, 0); if (flags == -1) { perror(\"fcntl(F_GETFL)\"); exit(EXIT_FAILURE); } if (fcntl(socket, F_SETFL, flags | O_NONBLOCK) == -1) { perror(\"fcntl(F_SETFL)\"); exit(EXIT_FAILURE); } } while (1) { int poll_count = poll(fds, nfds, -1); // 无限等待 if (poll_count == -1) { perror(\"poll\"); close(server_socket); exit(EXIT_FAILURE); } for (int i = 0; i \u003c nfds; i++) { if (fds[i].revents \u0026 POLLIN) { if (fds[i].fd == server_socket) { // 接受新连接，不会阻塞 client_socket = accept(server_socket, (struct sockaddr *)\u0026client_addr, \u0026client_addr_len); if (client_socket == -1) { if (errno != EWOULDBLOCK \u0026\u0026 errno != EAGAIN) { perror(\"accept\"); } } else { set_non_blocking(client_socket); // 设置新连接为非阻塞模式 fds[nfds].fd = client_socket; fds[nfds].events = POLLIN; nfds++; } } else { // 读取数据，不会阻塞 bytes_received = recv(fds[i].fd, buffer, BUFFER_SIZE - 1, 0); if (bytes_received \u003e 0) { buffer[bytes_received] = '\\0'; send(fds[i].fd, buffer, bytes_received, 0); } else if (bytes_received == 0) { close(fds[i].fd); fds[i] = fds[nfds - 1]; nfds--; } else { if (errno != EWOULDBLOCK \u0026\u0026 errno != EAGAIN) { perror(\"recv\"); close(fds[i].fd); fds[i] = fds[nfds - 1]; nfds--; } } } } } } ","date":"2024-06-14","objectID":"/posts/12b8a48/:19:3","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"结论 阻塞模式：代码更简单，适用于低并发或简单应用，但在高并发情况下可能会导致性能瓶颈。 非阻塞模式：更适合高并发应用，能够提高响应速度和并发处理能力，但需要处理更多的错误和边界情况，代码更复杂。 通过根据应用的具体需求选择合适的模式，你可以实现最佳的性能和可扩展性。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:19:4","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"实践–聊天室 使用poll函数实现IO多路复用，实现一个聊天室。 ","date":"2024-06-14","objectID":"/posts/12b8a48/:20:0","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"目录结构 ","date":"2024-06-14","objectID":"/posts/12b8a48/:20:1","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"代码实现 Makefile CC = gcc CFLAGS = -Iinclude -Wall -g SRC_DIR = src INC_DIR = include OBJ_DIR = obj SRCS = $(wildcard $(SRC_DIR)/*.c) OBJS = $(patsubst $(SRC_DIR)/%.c,$(OBJ_DIR)/%.o,$(SRCS)) TARGET = chat_server all: $(TARGET) $(TARGET): $(OBJS) $(CC) $(CFLAGS) -o $@ $^ $(OBJ_DIR)/%.o: $(SRC_DIR)/%.c | $(OBJ_DIR) $(CC) $(CFLAGS) -c -o $@ $^ $(OBJ_DIR): mkdir -p $(OBJ_DIR) clean: rm -rf $(OBJ_DIR) chat_server .PHONY: all clean server.h #ifndef SERVER_H #define SERVER_H #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e #include \u003cpoll.h\u003e #include \u003cerrno.h\u003e #include \u003carpa/inet.h\u003e #include \u003cstring.h\u003e #define PORT 8099 #define MAXCLIENTS 100 int create_server_socket(); #endif // SERVER_H client_handler.h #ifndef CLIENT_HANDLER_H #define CLIENT_HANDLER_H #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003carpa/inet.h\u003e #include \u003cpoll.h\u003e #include \u003cerrno.h\u003e #define BUFFER_SIZE 1024 void handle_new_connection(int server_socket, struct pollfd *fds, int *nfds); void handle_client_message(struct pollfd *fds, int *nfds, int i); void broadcast_message(struct pollfd *fds, int nfds, int sender_fd, const char *message, ssize_t message_len); #endif server.c #include \"server.h\" #include \"client_handler.h\" int create_server_socket() { int server_socket = socket(PF_INET, SOCK_STREAM, 0); if (server_socket == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } struct sockaddr_in server_addr; server_addr.sin_family = PF_INET; server_addr.sin_port = htons(PORT); server_addr.sin_addr.s_addr = INADDR_ANY; if(bind(server_socket,(struct sockaddr*)\u0026server_addr,sizeof(server_addr)) == -1) { perror(\"bind\"); close(server_socket); exit(EXIT_FAILURE); } if(listen(server_socket,10) == -1) { perror(\"listen\"); close(server_socket); exit(EXIT_FAILURE); } return server_socket; } client_handler.c #include \"client_handler.h\" #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003carpa/inet.h\u003e #include \u003cerrno.h\u003e void handle_new_connection(int server_socket, struct pollfd *fds, int *nfds) { struct sockaddr_in client_addr; socklen_t clientaddr_len = sizeof(client_addr); int client_socket = accept(server_socket, (struct sockaddr *)\u0026client_addr, \u0026clientaddr_len); if (client_socket == -1) { perror(\"accept\"); exit(EXIT_FAILURE); } else { char client_ip[INET_ADDRSTRLEN]; inet_ntop(AF_INET, \u0026client_addr.sin_addr, client_ip, sizeof(client_ip)); printf(\"New connection accepted from %s:%d\\n\", client_ip, ntohs(client_addr.sin_port)); char newbuffer[BUFFER_SIZE]; sprintf(newbuffer,\"Welcome,Friends,You are login in my server now,your ip is:%s\\n\", client_ip); send(client_socket,newbuffer,strlen(newbuffer),0); fds[*nfds].fd = client_socket; fds[*nfds].events = POLLIN; (*nfds)++; } } void handle_client_message(struct pollfd *fds, int *nfds, int i) { char buffer[BUFFER_SIZE]; ssize_t bytes_received = recv(fds[i].fd, buffer, BUFFER_SIZE - 1, 0); if (bytes_received \u003e 0) { buffer[bytes_received] = '\\0'; printf(\"Received message: %s\\n\", buffer); // 获取发送者的 IP 和端口 struct sockaddr_in sender_addr; socklen_t addr_len = sizeof(sender_addr); getpeername(fds[i].fd, (struct sockaddr *)\u0026sender_addr, \u0026addr_len); char sender_ip[INET_ADDRSTRLEN]; inet_ntop(AF_INET, \u0026sender_addr.sin_addr, sender_ip, sizeof(sender_ip)); int sender_port = ntohs(sender_addr.sin_port); // 计算前缀长度和剩余空间 const char *prefix_format = \"From %s:%d: \"; int prefix_len = snprintf(NULL, 0, prefix_format, sender_ip, sender_port); int remaining_space = BUFFER_SIZE - prefix_len - 1; // 确保 buffer 不会超过 remaining_space if (bytes_received \u003e remaining_space) { bytes_received = remaining_space; buffer[bytes_received] = '\\0'; // 确保 buffer 以空字符结尾 } // 创建新的消息缓冲区并添加发送者的 IP 和端口信息 char newbuffer[BUFFER_SIZE]; snprintf(newbuffer, sizeof(newbuffer), prefix_format, sender_ip, sender_port); strncat(newbuffer, buffer, remaining_space); broadcast_message(fds, *nfds, fds[i].fd, newbuffer, strlen(newbuffer)); } else if (bytes_received == 0) { printf(\"Client disconnected\\n\"); close(fds[i].fd)","date":"2024-06-14","objectID":"/posts/12b8a48/:20:2","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["网络编程"],"content":"代码分析 接下来，我们分析一下代码。 首先，我们来看一下 server.h 文件。 #ifndef SERVER_H #define SERVER_H #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e #include \u003cpoll.h\u003e #include \u003cerrno.h\u003e #include \u003carpa/inet.h\u003e #include \u003cstring.h\u003e #define PORT 8099 #define MAXCLIENTS 100 int create_server_socket(); #endif // SERVER_H 我们在这里定义了服务器的端口号和最大客户端数量。以及一些必要的头文件。还有一个create_server_socket函数,这个函数用来创建服务器的socket。 然后我们看server.c文件，看看这个create_server_socket()函数怎么实现的 #include \"server.h\" #include \"client_handler.h\" int create_server_socket() { int server_socket = socket(PF_INET, SOCK_STREAM, 0); if (server_socket == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } struct sockaddr_in server_addr; server_addr.sin_family = PF_INET; server_addr.sin_port = htons(PORT); server_addr.sin_addr.s_addr = INADDR_ANY; if(bind(server_socket,(struct sockaddr*)\u0026server_addr,sizeof(server_addr)) == -1) { perror(\"bind\"); close(server_socket); exit(EXIT_FAILURE); } if(listen(server_socket,10) == -1) { perror(\"listen\"); close(server_socket); exit(EXIT_FAILURE); } return server_socket; } 在create_server_socket() 函数中，我们首先使用socket函数创建了一个socket，使用ipv4协议，使用tcp协议. 接着我们创建了一个sockaddr_in结构体，这个结构体用来保存服务器的地址信息。 其中sin_addr.s_addr设置为INADDR_ANY，表示服务器可以接受来自任何ip的连接。 然后使用bind函数将socket绑定到服务器的地址上 最后使用listen函数监听端口。 listen函数的第二个参数 backlog 是用来指定连接队列的最大长度，即服务器可以排队等待处理的未完成连接请求的最大数量。 最后我们把创建的server_socket返回。 然后呢，我们来看看最重要的client_handler部分 首先是client_handler.h文件 #ifndef CLIENT_HANDLER_H #define CLIENT_HANDLER_H #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003carpa/inet.h\u003e #include \u003cpoll.h\u003e #include \u003cerrno.h\u003e #define BUFFER_SIZE 1024 void handle_new_connection(int server_socket, struct pollfd *fds, int *nfds); void handle_client_message(struct pollfd *fds, int *nfds, int i); void broadcast_message(struct pollfd *fds, int nfds, int sender_fd, const char *message, ssize_t message_len); #endif 我们看到，这里定义了缓冲区大小，以及一些必要的头文件。 然后是三个函数，handle_new_connection，handle_client_message和broadcast_message handle_new_connection 这个函数是用来处理连接的，我们看看这个函数的实现 void handle_new_connection(int server_socket, struct pollfd *fds, int *nfds) { struct sockaddr_in client_addr; socklen_t clientaddr_len = sizeof(client_addr); int client_socket = accept(server_socket, (struct sockaddr *)\u0026client_addr, \u0026clientaddr_len); if (client_socket == -1) { perror(\"accept\"); exit(EXIT_FAILURE); } else { char client_ip[INET_ADDRSTRLEN]; inet_ntop(AF_INET, \u0026client_addr.sin_addr, client_ip, sizeof(client_ip)); printf(\"New connection accepted from %s:%d\\n\", client_ip, ntohs(client_addr.sin_port)); char newbuffer[BUFFER_SIZE]; sprintf(newbuffer,\"Welcome,Friends,You are login in my server now,your ip is:%s\\n\", client_ip); send(client_socket,newbuffer,strlen(newbuffer),0); fds[*nfds].fd = client_socket; fds[*nfds].events = POLLIN; (*nfds)++; } } struct sockaddr_in client_addr; 套接字地址结构体，用于在套接字编程中表示IPV4类型的套接字地址 然后我们用一个变量存储这个套接字结构体的大小 ","date":"2024-06-14","objectID":"/posts/12b8a48/:20:3","tags":["网络编程","Linux","C"],"title":"Linux C网络编程","uri":"/posts/12b8a48/"},{"categories":["计算机网络"],"content":"基础知识 ","date":"2024-05-26","objectID":"/posts/297df01/:0:0","tags":["计算机网络协议","TCP","UDP","网络协议"],"title":"计算机网络基础知识","uri":"/posts/297df01/"},{"categories":["计算机网络"],"content":"MAC 地址 （1）计算机联网必须的硬件是安装在计算机上的网卡 （2）通信中，用来标识主机身份的地址就是制作在网卡上的一个硬件地址。每块网卡在 生产出来后，都有一个全球唯一的编号来标识自己，这个地址就是 MAC 地址，即网卡的 物理地址 （3）MAC 地址由 48 位二进制数组成，通常分成六段，用 16 进制表示，其中前 24 位是生 产厂商向 IEEE 申请的厂商编号，后 24 位是网络接口卡序列号 （4）MAC 地址的第 8 位为 0 时，表示该 MAC 地址为单播地址；为 1 时，表示该 MAC 地址 为组播 MAC 地址。 （5）单播的发送方式为一对一，即一台主机发送的数据只发送给另一台主机。 （6）广播方式为一对多，即一台主机发送一个数据，在这个网段的所有主机都能收到 （7）组播方式介于单播和广播之间，也是一对多，但接收者不是网段上的全体成员，而 是一个特定的组的成员。 以太网帧格式： ","date":"2024-05-26","objectID":"/posts/297df01/:1:0","tags":["计算机网络协议","TCP","UDP","网络协议"],"title":"计算机网络基础知识","uri":"/posts/297df01/"},{"categories":["计算机网络"],"content":"IP IP 在 TCP/IP 参考模型中处于第三层，也就是网络层。 网络层的主要作用是：实现主机与主机之间的通信，也叫点对点（end to end）通信。 ","date":"2024-05-26","objectID":"/posts/297df01/:2:0","tags":["计算机网络协议","TCP","UDP","网络协议"],"title":"计算机网络基础知识","uri":"/posts/297df01/"},{"categories":["计算机网络"],"content":"IP 包格式 ","date":"2024-05-26","objectID":"/posts/297df01/:2:1","tags":["计算机网络协议","TCP","UDP","网络协议"],"title":"计算机网络基础知识","uri":"/posts/297df01/"},{"categories":["计算机网络"],"content":"IP 地址的基础知识 IP 地址（IPv4 地址）由 32 位正整数来表示，IP 地址在计算机是以二进制的方式处理的。 人类为了方便记忆采用了点分十进制的标记方式，也就是将 32 位 IP 地址以每 8 位为组，共分为 4 组，每组以「.」隔开，再将每组转换成十进制。 ","date":"2024-05-26","objectID":"/posts/297df01/:2:2","tags":["计算机网络协议","TCP","UDP","网络协议"],"title":"计算机网络基础知识","uri":"/posts/297df01/"},{"categories":["计算机网络"],"content":"IP 地址分类 A 类: 0.0.0.0 ~ 127.255.255.255 B 类: 128.0.0.0 ~ 191.255.255.255 C 类: 192.0.0.0 ~ 223.255.255.255 A 类就是 32 位里面，第 1 位是 0，后面 7 位是网络号，剩下的都是主机号(24 位) B 类就是 32 位里面，前 2 位是 10，后面 14 位为网络号，剩下都是主机号(16 位) C 类就是 32 位里面，前 3 位是 110，后面 21 位为网络号，剩下都是主机号(8 位) 最大主机数计算方法: 假如主机号位数是 n，那么最大主机数就是2^n - 2 减 2 是因为在 IP 地址中，有两个 IP 是特殊的，分别是主机号全为 1 和 全为 0 地址。 主机号全为 1 指定某个网络下的所有主机，用于广播 主机号全为 0 指定某个网络 ","date":"2024-05-26","objectID":"/posts/297df01/:2:3","tags":["计算机网络协议","TCP","UDP","网络协议"],"title":"计算机网络基础知识","uri":"/posts/297df01/"},{"categories":["计算机网络"],"content":"广播地址作用 广播地址作用: 广播地址用于在同一个链路中相互连接的主机之间发送数据包。 ","date":"2024-05-26","objectID":"/posts/297df01/:2:4","tags":["计算机网络协议","TCP","UDP","网络协议"],"title":"计算机网络基础知识","uri":"/posts/297df01/"},{"categories":["计算机网络"],"content":"D,E 类地址 什么是 D、E 类地址？ 而 D 类和 E 类地址是没有主机号的，所以不可用于主机 IP，D 类常被用于多播，E 类是预留的分类，暂时未使用。 ","date":"2024-05-26","objectID":"/posts/297df01/:2:5","tags":["计算机网络协议","TCP","UDP","网络协议"],"title":"计算机网络基础知识","uri":"/posts/297df01/"},{"categories":["计算机网络"],"content":"多播作用 多播用于将包发送给特定组内的所有主机。 ","date":"2024-05-26","objectID":"/posts/297df01/:2:6","tags":["计算机网络协议","TCP","UDP","网络协议"],"title":"计算机网络基础知识","uri":"/posts/297df01/"},{"categories":["计算机网络"],"content":"无分类地址 CIDR 因为 IP 分类存在许多缺点，所以后面提出了无分类地址的方案，即 CIDR。 这种方式不再有分类地址的概念，32 比特的 IP 地址被划分为两部分，前面是网络号，后面是主机号。 表示形式 a.b.c.d/x，其中 /x 表示前 x 位属于网络号， x 的范围是 0 ~ 32，这就使得 IP 地址更加具有灵活性。 比如 10.100.122.2/24，这种地址表示形式就是 CIDR，/24 表示前 24 位是网络号，剩余的 8 位是主机号。 还有另一种划分网络号与主机号形式，那就是子网掩码，掩码的意思就是掩盖掉主机号，剩余的就是网络号。 ","date":"2024-05-26","objectID":"/posts/297df01/:2:7","tags":["计算机网络协议","TCP","UDP","网络协议"],"title":"计算机网络基础知识","uri":"/posts/297df01/"},{"categories":["计算机网络"],"content":"子网划分 假设对 C 类地址进行子网划分，网络地址 192.168.1.0，使用子网掩码 255.255.255.192 对其进行子网划分。 C 类地址中前 24 位是网络号，最后 8 位是主机号，根据子网掩码可知从 8 位主机号中借用 2 位作为子网号。 由于子网网络地址被划分成 2 位，那么子网地址就有 4 个，分别是 00、01、10、11，具体划分如下图： 划分后的 4 个子网如下表格： ","date":"2024-05-26","objectID":"/posts/297df01/:2:8","tags":["计算机网络协议","TCP","UDP","网络协议"],"title":"计算机网络基础知识","uri":"/posts/297df01/"},{"categories":["计算机网络"],"content":"IP 地址与路由控制 ","date":"2024-05-26","objectID":"/posts/297df01/:2:9","tags":["计算机网络协议","TCP","UDP","网络协议"],"title":"计算机网络基础知识","uri":"/posts/297df01/"},{"categories":["计算机网络"],"content":"TCP ","date":"2024-05-26","objectID":"/posts/297df01/:3:0","tags":["计算机网络协议","TCP","UDP","网络协议"],"title":"计算机网络基础知识","uri":"/posts/297df01/"},{"categories":["计算机网络"],"content":"TCP 报文格式 TCP 报文由首部和数据两部分组成。首部一般由 20-60 字节（Byte）构成，长度可变。其中前 20B 格式固定，后 40B 为可选。 因为，TCP 报文还得传给下层网络层，封装成 IP 包，而一个 IP 包最大长度为 65535，同时 IP 包首部也包含最少 20B，所以一个 IP 包或 TCP 包可以包含的数据部分最大长度为 65535-20-20=65495B。 TCP 报文中数据部分是可选的，即 TCP 报文可以不包含数据（同理 IP 包也可以不包含数据）。不含数据的 TCP 报文通常是一些确认和控制信息类的报文，如 TCP 建立连接时的三次握手和 TCP 终止时的四次挥手等。 1、源端口号（Source Port） 长度为 16 位，指明发送数据的进程。 2、目的端口号（Destination Port） 长度为 16 位，指明目的主机接收数据的进程。 3、序号（Sequence Number） 也称为序列号，长度为 32 位，序号用来标识从 TCP 发送端向接入端发送的数据字节流进行编号，可以理解成对字节流的计数。 4、确认号（Acknowledgement Number） 长度为 32 位，确认号包含发送确认的一端所期望收到的下一个序号。确认号只有在 ACK 标志为 1 时才有效。 5、首部长度 长度为 4 位，用于表示 TCP 报文首部的长度。用 4 位（bit）表示，十进制值就是[0,15]，一个 TCP 报文前 20 个字节是必有的，后 40 个字节根据情况可能有可能没有。如果 TCP 报文首部是 20 个字节，则该位应是 20/4=5。 6、保留位（Reserved） 长度为 6 位，必须是 0，它是为将来定义新用途保留的。 7、标志（Code Bits） 长度为 6 位，在 TCP 报文中不管是握手还是挥手还是传数据等，这 6 位标志都很重要。6 位从左到右依次为： URG：紧急标志位，说明紧急指针有效； ACK：确认标志位，多数情况下空，说明确认序号有效； PSH：推标志位，置位时表示接收方应立即请求将报文交给应用层； RST：复位标志，用于重建一个已经混乱的连接； SYN：同步标志，该标志仅在三次握手建立 TCP 连接时有效 FIN：结束标志，带该标志位的数据包用于结束一个 TCP 会话。 8、窗口大小（Window Size） 长度为 16 位，TCP 流量控制由连接的每一端通过声明的窗口大小来提供。 9、检验和（Checksum） 长度为 16 位，该字段覆盖整个 TCP 报文端，是个强制性的字段，是由发送端计算和存储，到接收端后，由接收端进行验证。 10、紧急指针（Urgent Pointer） 长度为 16 位，指向数据中优先部分的最后一个字节，通知接收方紧急数据的长度，该字段在 URG 标志置位时有效。 11、选项（Options） 长度为 0-40B（字节），必须以 4B 为单位变化，必要时可以填充 0。通常包含：最长报文大小（MaximumSegment Size，MSS）、窗口扩大选项、时间戳选项、选择性确认（Selective ACKnowlegement，SACK）等。 12、数据 ","date":"2024-05-26","objectID":"/posts/297df01/:3:1","tags":["计算机网络协议","TCP","UDP","网络协议"],"title":"计算机网络基础知识","uri":"/posts/297df01/"},{"categories":["计算机网络"],"content":"UDP ","date":"2024-05-26","objectID":"/posts/297df01/:4:0","tags":["计算机网络协议","TCP","UDP","网络协议"],"title":"计算机网络基础知识","uri":"/posts/297df01/"},{"categories":["计算机网络"],"content":"UDP 报文格式 UDP 数据报由首部和数据两部分组成，其中首部只有 8B（字节）。 1、源端口号（Source Port） 长度为 16 位，指明发送数据的进程。 2、目的端口号（Destination Port） 长度为 16 位，指明目的主机接收数据的进程。 3、长度 长度为 16 位，该字段值为报头和数据两部分的总字节数。 4、检验和（Checksum） 长度为 16 位，UDP 检验和作用于 UDP 报头和 UDP 数据的所有位。由发送端计算和存储，由接收端校验。 5、数据 CSMA/CD 协议 CSMA/CA 协议 CSMA/CD 协议是载波监听多点接入/碰撞检测，是一种以太网中使用的介质访问控制方法。 载波监听多点接入：多个设备共享一个信道，当一个设备发送数据时，其他设备不能发送数据，必须等待。 碰撞检测：当一个设备发送数据时，其他设备不能发送数据，必须等待。当一个设备发送数据时，其他设备不能发送数据，必须等待。 CAMA/CA 用于无线网络中(包括蜂窝数据网络) RIP 和 OSPF RIP（Routing Information Protocol，路由信息协议）是一种基于距离矢量的路由协议，用于在小型到中型网络中动态地分发路由信息。其工作原理如下： 距离矢量算法： RIP 使用距离矢量算法（Distance Vector Algorithm），其核心思想是通过不断地向相邻路由器通告（即交换）路由信息来更新路由表。 在这类算法中，路由器会保存一张路由表，表中包含到达每个目的网络的最短距离（以跳数表示）和下一跳路由器的地址。 周期性更新： RIP 路由器会定期（默认每 30 秒）向其所有相邻路由器广播其路由表。这种方式被称为“路由更新”。 当一个路由器收到一个更新包时，它会检查包中的每一项路由，看是否有更短的路径。如果有，它会更新自己的路由表。 跳数限制： RIP 使用跳数作为衡量路径代价的度量标准。每经过一个路由器就算作一个跳（hop）。 RIP 设置了一个最大跳数限制为 15 跳，这意味着如果某目的网络的跳数超过 15，RIP 将认为该网络不可达。 防环机制： 水平分割（Split Horizon）：防止路由器将从某个接口学到的路由信息再次通过同一接口发送出去，从而减少路由环路的可能性。 毒性逆转（Route Poisoning）：当某条路由不可达时，路由器会将该路由的跳数设置为 16（不可达）并通告给其他路由器。 触发更新（Triggered Updates）：当路由发生变化时，立即向相邻路由器发送更新，而不是等待常规的更新周期。 路由计时器： 路由更新计时器：定期发送路由更新，默认每 30 秒一次。 路由老化计时器：如果在 180 秒内没有收到某条路由的更新，则认为该路由可能不可用。 路由失效计时器：如果在 240 秒内没有收到某条路由的更新，则认为该路由不可用，并将其从路由表中删除。 通过这些机制，RIP 能够在动态变化的网络环境中更新和维护路由表，但由于其跳数限制和收敛速度慢等问题，它通常适用于较小规模的网络。 OSPF OSPF（Open Shortest Path First，开放最短路径优先）是一种链路状态路由协议，广泛应用于大型复杂网络中。与基于距离矢量的 RIP 不同，OSPF 使用链路状态算法（Link State Algorithm）来计算路由，并具有更快的收敛速度和更高的可扩展性。以下是 OSPF 的工作原理和关键特性： ","date":"2024-05-26","objectID":"/posts/297df01/:4:1","tags":["计算机网络协议","TCP","UDP","网络协议"],"title":"计算机网络基础知识","uri":"/posts/297df01/"},{"categories":["计算机网络"],"content":"工作原理 链路状态广告（LSA）： OSPF 使用链路状态广告（Link State Advertisements, LSA）来通告网络拓扑信息。 每个路由器生成 LSAs，并将其发送给同一区域（area）内的所有其他路由器。 LSAs 包含关于路由器接口状态、链路代价（通常基于带宽）、邻接关系等信息。 链路状态数据库（LSDB）： 每个 OSPF 路由器维护一份链路状态数据库，包含该区域内所有路由器的 LSAs。 LSDB 是整个网络拓扑的完整视图，所有区域内的路由器都共享相同的 LSDB。 Dijkstra 算法： OSPF 使用 Dijkstra 算法（最短路径优先算法）来计算从自身到所有网络目的地的最短路径。 基于 LSDB，路由器计算出一棵最短路径树（Shortest Path Tree, SPT），并据此更新其路由表。 区域划分： OSPF 支持将自治系统（AS）划分为多个区域（Area），以简化管理和优化性能。 核心区域（Backbone Area，即 Area 0）连接其他所有区域，并负责跨区域的路由信息交换。 每个区域内的路由器只需了解本区域的详细拓扑，减少了路由器的计算和存储负担。 邻接关系和路由更新： 路由器通过发送 Hello 报文在同一子网内建立邻接关系。 邻接路由器之间交换 LSAs，确保 LSDB 的同步。 OSPF 采用可靠的传输机制，确保 LSAs 不会丢失，并通过泛洪（Flooding）机制将 LSAs 传播到整个网络。 ","date":"2024-05-26","objectID":"/posts/297df01/:4:2","tags":["计算机网络协议","TCP","UDP","网络协议"],"title":"计算机网络基础知识","uri":"/posts/297df01/"},{"categories":["计算机网络"],"content":"关键特性 快速收敛： OSPF 在网络拓扑发生变化时能够迅速更新路由表，提供较快的收敛速度。 无类域间路由（CIDR）支持： OSPF 支持可变长度子网掩码（VLSM），允许更高效的 IP 地址利用。 负载均衡： OSPF 支持多条等价路径的负载均衡，增加网络冗余和可靠性。 路由认证： OSPF 支持多种认证机制（如简单密码认证和 MD5），提高了路由信息的安全性。 可扩展性： 通过区域划分和层次化设计，OSPF 能够有效管理大型网络。 多播更新： OSPF 使用多播地址（224.0.0.5 和 224.0.0.6）发送路由更新，减少了对非 OSPF 设备的干扰。 ","date":"2024-05-26","objectID":"/posts/297df01/:4:3","tags":["计算机网络协议","TCP","UDP","网络协议"],"title":"计算机网络基础知识","uri":"/posts/297df01/"},{"categories":["计算机网络"],"content":"总结 OSPF 作为一种链路状态路由协议，具有快速收敛、可扩展性强、支持多播更新和负载均衡等优点，广泛应用于大型企业网络和服务提供商网络中。其复杂的功能和灵活的配置选项使其在高性能和高可靠性要求的网络环境中表现出色。 网络协议组成 网络协议由 3 个要素组成，分别是语法、语义和同步。 （1）语法，即数据与控制信息的结构或格式； （2）语义，即需要发出何种控制信息，完成何种动作以及做出何种响应； （3）同步，即事件顺序的详细说明 数据经历总时延 发送时延 –\u003e发送时延 = 数据包大小 / 链路带宽 传播时延 –\u003e 传播时延 = 链路距离 / 信号传播速度 处理时延 排队时延 排队时延 是四种时延中随时间变化最大的。这是因为： 排队时延直接受到网络流量和拥塞情况的影响，这些因素在不同时间段可能会有很大的波动。 在高流量时段，排队时延可能会显著增加，甚至导致网络拥塞。 在低流量时段，排队时延可能会非常小或接近于零。 IEEE802 局域网标准 LAN（Localareanetwork，局域网）是一个相对与 WAN（Wideareanetwork，广域网）而言的概念。 IEEE 802.3（有线） （以太网是采用目前最为通用的通信标准的一种局域网） IEEE 802.3u 100Mb/s 快速以太网 IEEE 802.3z 光纤介质1Gb/s 以太网标准规范 IEEE 802.3ab 双绞线实现1Gb/s以太网标准规范 IEEE 802.3ae 光纤10Gb/s 以太网标准 IEEE 802.3ba 实现100Gb/s 以太网标准 IEEE 802.11（无线） IEEE 802.11a 载波频率5GHz速率最高可达54M/s IEEE 802.11b 载波频率2.4GHz速率最高可达11Mb/s IEEE 802.11g 载波频率2.4GHz速率最高可达54Mb/s IEEE 802.11n 速率最高可达600Mb/s 11n 的三大优势：纯属速度快、覆盖范围广、兼容性强。 网络模型 ","date":"2024-05-26","objectID":"/posts/297df01/:4:4","tags":["计算机网络协议","TCP","UDP","网络协议"],"title":"计算机网络基础知识","uri":"/posts/297df01/"},{"categories":["计算机网络"],"content":"OSI 七层网络模型 应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 ","date":"2024-05-26","objectID":"/posts/297df01/:5:0","tags":["计算机网络协议","TCP","UDP","网络协议"],"title":"计算机网络基础知识","uri":"/posts/297df01/"},{"categories":["计算机网络"],"content":"网络中常见的设备 集线器： 工作在物理层 中继器：工作在物理层 交换机： 工作在数据链路层 网桥： 工作在数据链路层 路由器： 工作在网络层 网关： 工作在应用层 ","date":"2024-05-26","objectID":"/posts/297df01/:6:0","tags":["计算机网络协议","TCP","UDP","网络协议"],"title":"计算机网络基础知识","uri":"/posts/297df01/"},{"categories":["计算机网络"],"content":"各层传输的数据单元(Protocol Data Unit) https://zh.wikipedia.org/wiki/%E5%8D%8F%E8%AE%AE%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83 物理层: 比特流(bit) 数据链路层: 数据帧(frame) 网络层: 数据包(packet) 传输层: 数据段(segment)--\u003eTCP 数据报(datagram) --\u003e UDP 应用层: 报文(message) ","date":"2024-05-26","objectID":"/posts/297df01/:6:1","tags":["计算机网络协议","TCP","UDP","网络协议"],"title":"计算机网络基础知识","uri":"/posts/297df01/"},{"categories":["计算机网络"],"content":"TCP/IP 网络模型 应用层 传输层 网络层 网络接口层 ","date":"2024-05-26","objectID":"/posts/297df01/:7:0","tags":["计算机网络协议","TCP","UDP","网络协议"],"title":"计算机网络基础知识","uri":"/posts/297df01/"},{"categories":["计算机网络"],"content":"数据封装过程 ","date":"2024-05-26","objectID":"/posts/297df01/:8:0","tags":["计算机网络协议","TCP","UDP","网络协议"],"title":"计算机网络基础知识","uri":"/posts/297df01/"},{"categories":["Java - Spring"],"content":"Bean的实例化模式 Spring为Bean提供了多种实例化方式，通常包括4种方式。（也就是说在Spring中为Bean对象的创建准备了多种方案，目的是：更加灵活） ● 第一种：通过构造方法实例化 ● 第二种：通过简单工厂模式实例化 ● 第三种：通过factory-bean实例化 ● 第四种：通过FactoryBean接口实例化 通过构造方法实例化 ConstructorBean.java package com.powercode.spring6.beans; public class ConstructorBean { public ConstructorBean(){ } } \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"constructorBean\" class=\"com.powercode.spring6.beans.ConstructorBean\"\u003e\u003c/bean\u003e \u003c/beans\u003e 测试程序` @Test public void testConstrucotrBean(){ Logger logger = LoggerFactory.getLogger(FirstSpringTest.class); ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring9.xml\"); ConstructorBean constructorBean = applicationContext.getBean(\"constructorBean\",ConstructorBean.class); System.out.println(constructorBean); } /usr/lib/jvm/java-17-openjdk/bin/java -ea -Didea.test.cyclic.buffer.size=1048576 -javaagent:/opt/intellij-idea-ultimate-edition/lib/idea_rt.jar=36789:/opt/intellij-idea-ultimate-edition/bin -Dfile.encoding=UTF-8 -classpath /home/meowrain/.m2/repository/org/junit/platform/junit-platform-launcher/1.10.1/junit-platform-launcher-1.10.1.jar:/home/meowrain/.m2/repository/org/junit/platform/junit-platform-engine/1.10.1/junit-platform-engine-1.10.1.jar:/home/meowrain/.m2/repository/org/junit/jupiter/junit-jupiter-engine/5.10.1/junit-jupiter-engine-5.10.1.jar:/opt/intellij-idea-ultimate-edition/lib/idea_rt.jar:/opt/intellij-idea-ultimate-edition/plugins/junit/lib/junit5-rt.jar:/opt/intellij-idea-ultimate-edition/plugins/junit/lib/junit-rt.jar:/home/meowrain/IdeaProjects/spring_first/target/test-classes:/home/meowrain/IdeaProjects/spring_first/target/classes:/home/meowrain/.m2/repository/org/springframework/spring-context/6.1.0-SNAPSHOT/spring-context-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-aop/6.1.0-SNAPSHOT/spring-aop-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-beans/6.1.0-SNAPSHOT/spring-beans-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-core/6.1.0-SNAPSHOT/spring-core-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-jcl/6.1.0-SNAPSHOT/spring-jcl-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-expression/6.1.0-SNAPSHOT/spring-expression-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/io/micrometer/micrometer-observation/1.12.0/micrometer-observation-1.12.0.jar:/home/meowrain/.m2/repository/io/micrometer/micrometer-commons/1.12.0/micrometer-commons-1.12.0.jar:/home/meowrain/.m2/repository/org/junit/jupiter/junit-jupiter-api/5.10.1/junit-jupiter-api-5.10.1.jar:/home/meowrain/.m2/repository/org/opentest4j/opentest4j/1.3.0/opentest4j-1.3.0.jar:/home/meowrain/.m2/repository/org/junit/platform/junit-platform-commons/1.10.1/junit-platform-commons-1.10.1.jar:/home/meowrain/.m2/repository/org/apiguardian/apiguardian-api/1.1.2/apiguardian-api-1.1.2.jar:/home/meowrain/.m2/repository/org/apache/logging/log4j/log4j-core/2.19.0/log4j-core-2.19.0.jar:/home/meowrain/.m2/repository/org/apache/logging/log4j/log4j-api/2.19.0/log4j-api-2.19.0.jar:/home/meowrain/.m2/repository/org/apache/logging/log4j/log4j-slf4j2-impl/2.19.0/log4j-slf4j2-impl-2.19.0.jar:/home/meowrain/.m2/repository/org/slf4j/slf4j-api/2.0.0/slf4j-api-2.0.0.jar com.intellij.rt.junit.JUnitStarter -ideVersion5 -junit5 com.powercode.spring6.test.FirstSpringTest,testConstrucotrBean 2024-01-11 09:28:44 658 [main] DEBUG org.springframework.context.support.ClassPathXmlApplicationContext - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@556d0826 2024-01-11 09:28:44 843 [main] DEBUG org.springframework.beans.factory.xml.XmlBeanDefinitionReader - Loaded 1 ","date":"2024-05-23","objectID":"/posts/6607266/:0:0","tags":["Spring","Java"],"title":"Java Spring笔记06 Bean的实例化模式 Spring","uri":"/posts/6607266/"},{"categories":["Java - Spring"],"content":"BeanFactory和FactoryBean的区别 ","date":"2024-05-23","objectID":"/posts/6607266/:1:0","tags":["Spring","Java"],"title":"Java Spring笔记06 Bean的实例化模式 Spring","uri":"/posts/6607266/"},{"categories":["Java - Spring"],"content":"BeanFactory Spring IoC容器的顶级对象，BeanFactory被翻译为“Bean工厂”，在Spring的IoC容器中，“Bean工厂”负责创建Bean对象。 BeanFactory是工厂。 ","date":"2024-05-23","objectID":"/posts/6607266/:1:1","tags":["Spring","Java"],"title":"Java Spring笔记06 Bean的实例化模式 Spring","uri":"/posts/6607266/"},{"categories":["Java - Spring"],"content":"FactoryBean FactoryBean：它是一个Bean，是一个能够辅助Spring实例化其它Bean对象的一个Bean。 在Spring中，Bean可以分为两类： ● 第一类：普通Bean ● 第二类：工厂Bean（记住：工厂Bean也是一种Bean，只不过这种Bean比较特殊，它可以辅助Spring实例化其它Bean对象。） 注入自定义Date 我们前面说过，java.util.Date在Spring中被当做简单类型，简单类型在注入的时候可以直接使用value属性或value标签来完成。但我们之前已经测试过了，对于Date类型来说，采用value属性或value标签赋值的时候，对日期字符串的格式要求非常严格，必须是这种格式的：Mon Oct 10 14:30:26 CST 2022。其他格式是不会被识别的。如以下代码： package com.powercode.spring6.beans; import java.util.Date; public class Human { private Date date; public Human(Date date) { this.date = date; } public void setDate(Date date) { this.date = date; } @Override public String toString() { return \"Human{\" + \"date=\" + date + '}'; } } \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"dateBean\" class=\"com.powercode.spring6.beans.DateFactory\"\u003e \u003cconstructor-arg name=\"date\"\u003e \u003cvalue\u003e2022-12-10\u003c/value\u003e \u003c/constructor-arg\u003e \u003c/bean\u003e \u003cbean id=\"humanBean\" class=\"com.powercode.spring6.beans.Human\"\u003e \u003cconstructor-arg name=\"date\" ref=\"dateBean\"\u003e\u003c/constructor-arg\u003e \u003c/bean\u003e \u003c/beans\u003e 我们上面构建的birth不是标准格式，会报错 我们需要编写一个DateFactoryBean,这个类实现FactoryBean接口！ package com.powercode.spring6.beans; import org.springframework.beans.factory.FactoryBean; import java.text.SimpleDateFormat; import java.util.Date; public class DateFactory implements FactoryBean\u003cDate\u003e { private String date; public DateFactory(String date) { this.date = date; } @Override public Date getObject() throws Exception { SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd\"); return simpleDateFormat.parse(date); } @Override public Class\u003c?\u003e getObjectType() { return null; } @Override public boolean isSingleton() { return FactoryBean.super.isSingleton(); } } /usr/lib/jvm/java-17-openjdk/bin/java -ea -Didea.test.cyclic.buffer.size=1048576 -javaagent:/opt/intellij-idea-ultimate-edition/lib/idea_rt.jar=46505:/opt/intellij-idea-ultimate-edition/bin -Dfile.encoding=UTF-8 -classpath /home/meowrain/.m2/repository/org/junit/platform/junit-platform-launcher/1.10.1/junit-platform-launcher-1.10.1.jar:/home/meowrain/.m2/repository/org/junit/platform/junit-platform-engine/1.10.1/junit-platform-engine-1.10.1.jar:/home/meowrain/.m2/repository/org/junit/jupiter/junit-jupiter-engine/5.10.1/junit-jupiter-engine-5.10.1.jar:/opt/intellij-idea-ultimate-edition/lib/idea_rt.jar:/opt/intellij-idea-ultimate-edition/plugins/junit/lib/junit5-rt.jar:/opt/intellij-idea-ultimate-edition/plugins/junit/lib/junit-rt.jar:/home/meowrain/IdeaProjects/spring_first/target/test-classes:/home/meowrain/IdeaProjects/spring_first/target/classes:/home/meowrain/.m2/repository/org/springframework/spring-context/6.1.0-SNAPSHOT/spring-context-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-aop/6.1.0-SNAPSHOT/spring-aop-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-beans/6.1.0-SNAPSHOT/spring-beans-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-core/6.1.0-SNAPSHOT/spring-core-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-jcl/6.1.0-SNAPSHOT/spring-jcl-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-expression/6.1.0-SNAPSHOT/spring-expression-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/io/micrometer/micrometer-observation/1.12.0/micrometer-observation-1.12.0.jar:/home/meowrain/.m2/repository/io/micrometer/micrometer-commons/1.12.0/micrometer-commons-1.12.0.jar:/home/meowrain/.m2/repository/org/junit/jupiter/junit-jupiter-api/5.10.1/junit-jupiter-api-5.10.1.jar:/home/meowrain/.m2/repository/org/opentest4j/opentest4j/1.3.0/opentest4j-1.3.0.jar:/home/meowrain/.m2/repository/org/junit/platform/junit-platform-commons/1.10.1/junit-platform-commons-1.10.1.jar:/home/meowrain/.m2/rep","date":"2024-05-23","objectID":"/posts/6607266/:1:2","tags":["Spring","Java"],"title":"Java Spring笔记06 Bean的实例化模式 Spring","uri":"/posts/6607266/"},{"categories":["Java - Spring"],"content":"工厂模式的三种形态 工厂模式通常有三种形态： ● 第一种：简单工厂模式（Simple Factory）：不属于23种设计模式之一。简单工厂模式又叫做：静态 工厂方法模式。简单工厂模式是工厂方法模式的一种特殊实现。 ● 第二种：工厂方法模式（Factory Method）：是23种设计模式之一。 ● 第三种：抽象工厂模式（Abstract Factory）：是23种设计模式之一。 简单工厂模式 简单工厂模式的角色包括三个： ● 抽象产品 角色 ● 具体产品 角色 ● 工厂类 角色 抽象产品角色： package com.powernode.factory; /** * 武器（抽象产品角色） * @author 动力节点 * @version 1.0 * @className Weapon * @since 1.0 **/ public abstract class Weapon { /** * 所有的武器都有攻击行为 */ public abstract void attack(); } 具体产品角色： package com.powernode.factory; /** * 坦克（具体产品角色） * @author 动力节点 * @version 1.0 * @className Tank * @since 1.0 **/ public class Tank extends Weapon{ @Override public void attack() { System.out.println(\"坦克开炮！\"); } } package com.powernode.factory; /** * 战斗机（具体产品角色） * @author 动力节点 * @version 1.0 * @className Fighter * @since 1.0 **/ public class Fighter extends Weapon{ @Override public void attack() { System.out.println(\"战斗机投下原子弹！\"); } } package com.powernode.factory; /** * 匕首（具体产品角色） * @author 动力节点 * @version 1.0 * @className Dagger * @since 1.0 **/ public class Dagger extends Weapon{ @Override public void attack() { System.out.println(\"砍他丫的！\"); } } 工厂类角色： package com.powernode.factory; /** * 工厂类角色 * @author 动力节点 * @version 1.0 * @className WeaponFactory * @since 1.0 **/ public class WeaponFactory { /** * 根据不同的武器类型生产武器 * @param weaponType 武器类型 * @return 武器对象 */ public static Weapon get(String weaponType){ if (weaponType == null || weaponType.trim().length() == 0) { return null; } Weapon weapon = null; if (\"TANK\".equals(weaponType)) { weapon = new Tank(); } else if (\"FIGHTER\".equals(weaponType)) { weapon = new Fighter(); } else if (\"DAGGER\".equals(weaponType)) { weapon = new Dagger(); } else { throw new RuntimeException(\"不支持该武器！\"); } return weapon; } } 测试程序（客户端程序）： package com.powernode.factory; /** * @author 动力节点 * @version 1.0 * @className Client * @since 1.0 **/ public class Client { public static void main(String[] args) { Weapon weapon1 = WeaponFactory.get(\"TANK\"); weapon1.attack(); Weapon weapon2 = WeaponFactory.get(\"FIGHTER\"); weapon2.attack(); Weapon weapon3 = WeaponFactory.get(\"DAGGER\"); weapon3.attack(); } } 简单工厂模式的优点： ● 客户端程序不需要关心对象的创建细节，需要哪个对象时，只需要向工厂索要即可，初步实现了责任的分离。客户端只负责“消费”，工厂负责“生产”。生产和消费分离。 简单工厂模式的缺点： ● 缺点1：工厂类集中了所有产品的创造逻辑，形成一个无所不知的全能类，有人把它叫做上帝类。显然工厂类非常关键，不能出问题，一旦出问题，整个系统瘫痪。 ● 缺点2：不符合OCP开闭原则，在进行系统扩展时，需要修改工厂类。 Spring中的BeanFactory就使用了简单工厂模式。 ","date":"2024-05-23","objectID":"/posts/b5d8f62/:0:0","tags":["Spring","Java"],"title":"Java Spring笔记05 工厂模式 设计模式","uri":"/posts/b5d8f62/"},{"categories":["Java - Spring"],"content":"工厂方法模式 工厂方法模式既保留了简单工厂模式的优点，同时又解决了简单工厂模式的缺点。 工厂方法模式的角色包括： ● 抽象工厂角色 ● 具体工厂角色 ● 抽象产品角色 ● 具体产品角色 抽象产品角色 package com.powernode.factory; /** * 武器类（抽象产品角色） * @author 动力节点 * @version 1.0 * @className Weapon * @since 1.0 **/ public abstract class Weapon { /** * 所有武器都有攻击行为 */ public abstract void attack(); } 具体产品角色 package com.powernode.factory; /** * 具体产品角色 * @author 动力节点 * @version 1.0 * @className Gun * @since 1.0 **/ public class Gun extends Weapon{ @Override public void attack() { System.out.println(\"开枪射击！\"); } } 具体产品角色 package com.powernode.factory; /** * 具体产品角色 * @author 动力节点 * @version 1.0 * @className Fighter * @since 1.0 **/ public class Fighter extends Weapon{ @Override public void attack() { System.out.println(\"战斗机发射核弹！\"); } } 抽象工厂角色 package com.powernode.factory; /** * 武器工厂接口(抽象工厂角色) * @author 动力节点 * @version 1.0 * @className WeaponFactory * @since 1.0 **/ public interface WeaponFactory { Weapon get(); } 具体工厂角色 package com.powernode.factory; /** * 具体工厂角色 * @author 动力节点 * @version 1.0 * @className GunFactory * @since 1.0 **/ public class GunFactory implements WeaponFactory{ @Override public Weapon get() { return new Gun(); } } 具体工厂角色 package com.powernode.factory; /** * 具体工厂角色 * @author 动力节点 * @version 1.0 * @className FighterFactory * @since 1.0 **/ public class FighterFactory implements WeaponFactory{ @Override public Weapon get() { return new Fighter(); } } 客户端 package com.powernode.factory; /** * @author 动力节点 * @version 1.0 * @className Client * @since 1.0 **/ public class Client { public static void main(String[] args) { WeaponFactory factory = new GunFactory(); Weapon weapon = factory.get(); weapon.attack(); WeaponFactory factory1 = new FighterFactory(); Weapon weapon1 = factory1.get(); weapon1.attack(); } } 如果想扩展一个新的产品，只要新增一个产品类，再新增一个该产品对应的工厂即可，例如新增：匕首 package com.powernode.factory; /** * @author 动力节点 * @version 1.0 * @className Dagger * @since 1.0 **/ public class Dagger extends Weapon{ @Override public void attack() { System.out.println(\"砍丫的！\"); } } package com.powernode.factory; /** * @author 动力节点 * @version 1.0 * @className DaggerFactory * @since 1.0 **/ public class DaggerFactory implements WeaponFactory{ @Override public Weapon get() { return new Dagger(); } } package com.powernode.factory; /** * @author 动力节点 * @version 1.0 * @className Client * @since 1.0 **/ public class Client { public static void main(String[] args) { WeaponFactory factory = new GunFactory(); Weapon weapon = factory.get(); weapon.attack(); WeaponFactory factory1 = new FighterFactory(); Weapon weapon1 = factory1.get(); weapon1.attack(); WeaponFactory factory2 = new DaggerFactory(); Weapon weapon2 = factory2.get(); weapon2.attack(); } } 执行结果如下： 我们可以看到在进行功能扩展的时候，不需要修改之前的源代码，显然工厂方法模式符合OCP原则。 ocp原则详情见 https://meowrain.cn/archives/diveintodesignpatterns%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0 中的开闭原则 工厂方法模式的优点： ● 一个调用者想创建一个对象，只要知道其名称就可以了。 ● 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 ● 屏蔽产品的具体实现，调用者只关心产品的接口。 工厂方法模式的缺点： ● 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。 抽象工厂模式（了解） 抽象工厂模式相对于工厂方法模式来说，就是工厂方法模式是针对一个产品系列的，而抽象工厂模式是针对多个产品系列的，即工厂方法模式是一个产品系列一个工厂类，而抽象工厂模式是多个产品系列一个工厂类。 抽象工厂模式特点：抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象。它有多个抽象产品类，每个抽象产品类可以派生出多个具体产品类，一个抽象工厂类，可以派生出多个具体工厂类，每个具体工厂类可以创建多个具体产品类的实例。每一个模式都是针对一定问题的解决方案，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式针对的是多个产品等级结果。 抽象工厂中包含4个角色： ● 抽象工厂角色 ● 具体工厂角色 ● 抽象产品角色 ● 具体产品角色 抽象工厂模式代码如下： 第一部分：武器产品族 package com.powernode.product; /** * 武器产品族 * @author 动力节点 * @version 1.0 * @className Weapon * @since 1.0 **/ public abstract class Weapon { public abstract void attack(); } package com.powernode.product; /** * 武器产品族中的产品等级1 * @author 动力节点 * @version 1.0 * @className Gun * @since 1.0 **/ public class Gun extends Weapon{ @Override public void attack() { System.out.println(\"开枪射击！\"); } } package com.powernode.product; /** * 武器产品族中的产品等级2 * @author 动力节点 * @version 1.0 * @className Dagger * @since 1.0 **/ public class Dagger extends Weapon{ @Override ","date":"2024-05-23","objectID":"/posts/b5d8f62/:1:0","tags":["Spring","Java"],"title":"Java Spring笔记05 工厂模式 设计模式","uri":"/posts/b5d8f62/"},{"categories":["Java - Spring"],"content":"Spring引入外部属性配置文件 我们都知道编写数据源的时候是需要连接数据库的信息的，例如：driver url username password等信息。这些信息可以单独写到一个属性配置文件中吗，这样用户修改起来会更加的方便。当然可以。 第一步：写一个数据源类，提供相关属性。 MyDataSource.java package com.powercode.spring6.beans; import javax.sql.DataSource; import java.io.PrintWriter; import java.sql.Connection; import java.sql.ConnectionBuilder; import java.sql.SQLException; import java.sql.SQLFeatureNotSupportedException; import java.util.logging.Logger; public class MyDataSource implements DataSource { @Override public String toString() { return \"MyDataSource{\" + \"driver='\" + driver + '\\'' + \", url='\" + url + '\\'' + \", username='\" + username + '\\'' + \", password='\" + password + '\\'' + '}'; } private String driver; private String url; private String username; private String password; public void setDriver(String driver) { this.driver = driver; } public void setUrl(String url) { this.url = url; } public void setUsername(String username) { this.username = username; } public void setPassword(String password) { this.password = password; } @Override public Connection getConnection() throws SQLException { return null; } @Override public Connection getConnection(String s, String s1) throws SQLException { return null; } @Override public PrintWriter getLogWriter() throws SQLException { return null; } @Override public void setLogWriter(PrintWriter printWriter) throws SQLException { } @Override public void setLoginTimeout(int i) throws SQLException { } @Override public int getLoginTimeout() throws SQLException { return 0; } @Override public Logger getParentLogger() throws SQLFeatureNotSupportedException { return null; } @Override public ConnectionBuilder createConnectionBuilder() throws SQLException { return DataSource.super.createConnectionBuilder(); } @Override public \u003cT\u003e T unwrap(Class\u003cT\u003e aClass) throws SQLException { return null; } @Override public boolean isWrapperFor(Class\u003c?\u003e aClass) throws SQLException { return false; } } jdbc.properties driver=com.mysql.cj.jdbc.Driver url=jdbc:mysql://localhost:3306/spring username=root password=root123 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u003ccontext:property-placeholder location=\"jdbc.properties\"/\u003e \u003cbean id=\"dataSource\" class=\"com.powercode.spring6.beans.MyDataSource\"\u003e \u003cproperty name=\"driver\" value=\"${driver}\"\u003e\u003c/property\u003e \u003cproperty name=\"url\" value=\"${url}\"\u003e\u003c/property\u003e \u003cproperty name=\"username\" value=\"${username}\"\u003e\u003c/property\u003e \u003cproperty name=\"password\" value=\"${password}\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c/beans\u003e xmlns:context=\"http://www.springframework.org/schema/context\" 在beans里面添加了这个字段，还有 \u003ccontext:property-placeholder location=\"jdbc.properties\"/\u003e 后面就可以使用其中的key对应的value值了 测试函数 @Test public void testPropertiesSpringCode(){ Logger logger = LoggerFactory.getLogger(FirstSpringTest.class); ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring_jdbc.xml\"); MyDataSource myDataSource = applicationContext.getBean(\"dataSource\",MyDataSource.class); logger.info(myDataSource.toString()); } /usr/lib/jvm/java-17-openjdk/bin/java -ea -Didea.test.cyclic.buffer.size=1048576 -javaagent:/opt/intellij-idea-ultimate-edition/lib/idea_rt.jar=35121:/opt/intellij-idea-ultimate-edition/bin -Dfile.encoding=UTF-8 -classpath /home/meowrain/.m2/repository/org/junit/platform/junit-platform-launcher/1.10.1/junit-platform-launcher-1.10.1.jar:/home/meowrain/.m2/repository/org/junit/platform/junit-platform-engine/1.10.1/junit-platform-engine-1.10.1.jar:/home/meowrain/.m2/repository/org/junit/jupiter/junit-jupiter-engine/5.10.1/junit-jupiter-engine-5.10.1.jar:/opt/intellij-idea-ultimate-edition/lib/idea_rt.jar:/opt/intellij-idea-ultimate-edi","date":"2024-05-23","objectID":"/posts/102939e/:0:0","tags":["Spring","Java"],"title":"Java Spring笔记04 Spring引入外部属性配置文件","uri":"/posts/102939e/"},{"categories":["Java - Spring"],"content":"p命名空间注入 目的：简化配置。 使用p命名空间注入的前提条件包括两个： ● 第一：在XML头部信息中添加p命名空间的配置信息：xmlns:p=“http://www.springframework.org/schema/p\" ● 第二：p命名空间注入是基于setter方法的，所以需要对应的属性提供setter方法。 Customer.java package com.powercode.spring6.beans; public class Customer { private String name; private int age; public void setName(String name) { this.name = name; } public void setAge(int age){ this.age = age; } @Override public String toString() { return \"Customer{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } spring3.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"customerBean\" class=\"com.powercode.spring6.beans.Customer\" p:name=\"meowrain\" p:age=\"20\"\u003e\u003c/bean\u003e \u003c/beans\u003e 测试函数 @Test public void testThirdSpringCode() { Logger logger = LoggerFactory.getLogger(FirstSpringTest.class); ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring3.xml\"); Customer customer = applicationContext.getBean(\"customerBean\",Customer.class); logger.info(customer.toString()); } 函数执行结果 /usr/lib/jvm/java-17-openjdk/bin/java -ea -Didea.test.cyclic.buffer.size=1048576 -javaagent:/opt/intellij-idea-ultimate-edition/lib/idea_rt.jar=39503:/opt/intellij-idea-ultimate-edition/bin -Dfile.encoding=UTF-8 -classpath /home/meowrain/.m2/repository/org/junit/platform/junit-platform-launcher/1.10.1/junit-platform-launcher-1.10.1.jar:/home/meowrain/.m2/repository/org/junit/platform/junit-platform-engine/1.10.1/junit-platform-engine-1.10.1.jar:/home/meowrain/.m2/repository/org/junit/jupiter/junit-jupiter-engine/5.10.1/junit-jupiter-engine-5.10.1.jar:/opt/intellij-idea-ultimate-edition/lib/idea_rt.jar:/opt/intellij-idea-ultimate-edition/plugins/junit/lib/junit5-rt.jar:/opt/intellij-idea-ultimate-edition/plugins/junit/lib/junit-rt.jar:/home/meowrain/IdeaProjects/spring_first/target/test-classes:/home/meowrain/IdeaProjects/spring_first/target/classes:/home/meowrain/.m2/repository/org/springframework/spring-context/6.1.0-SNAPSHOT/spring-context-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-aop/6.1.0-SNAPSHOT/spring-aop-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-beans/6.1.0-SNAPSHOT/spring-beans-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-core/6.1.0-SNAPSHOT/spring-core-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-jcl/6.1.0-SNAPSHOT/spring-jcl-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-expression/6.1.0-SNAPSHOT/spring-expression-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/io/micrometer/micrometer-observation/1.12.0/micrometer-observation-1.12.0.jar:/home/meowrain/.m2/repository/io/micrometer/micrometer-commons/1.12.0/micrometer-commons-1.12.0.jar:/home/meowrain/.m2/repository/org/junit/jupiter/junit-jupiter-api/5.10.1/junit-jupiter-api-5.10.1.jar:/home/meowrain/.m2/repository/org/opentest4j/opentest4j/1.3.0/opentest4j-1.3.0.jar:/home/meowrain/.m2/repository/org/junit/platform/junit-platform-commons/1.10.1/junit-platform-commons-1.10.1.jar:/home/meowrain/.m2/repository/org/apiguardian/apiguardian-api/1.1.2/apiguardian-api-1.1.2.jar:/home/meowrain/.m2/repository/org/apache/logging/log4j/log4j-core/2.19.0/log4j-core-2.19.0.jar:/home/meowrain/.m2/repository/org/apache/logging/log4j/log4j-api/2.19.0/log4j-api-2.19.0.jar:/home/meowrain/.m2/repository/org/apache/logging/log4j/log4j-slf4j2-impl/2.19.0/log4j-slf4j2-impl-2.19.0.jar:/home/meowrain/.m2/repository/org/slf4j/slf4j-api/2.0.0/slf4j-api-2.0.0.jar com.intellij.rt.junit.JUnitStarter -ideVersion5 -junit5 com.powercode.spring6.test.FirstSpringTest,testThirdSpringCode 2024-01-09 12:52:54 636 [main] DEBUG org.springframew","date":"2024-05-23","objectID":"/posts/bb23c8c/:1:0","tags":["Spring","Java"],"title":"Java Spring笔记03 Spring三种命名空间","uri":"/posts/bb23c8c/"},{"categories":["Java - Spring"],"content":"c命名空间注入 c命名空间是简化构造方法注入的。 使用c命名空间的两个前提条件： 第一：需要在xml配置文件头部添加信息：xmlns:c=\"http://www.springframework.org/schema/c\" 第二：需要提供构造方法。 配置文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:c=\"http://www.springframework.org/schema/c\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"myTimeBean\" class=\"com.powercode.spring6.beans.MyTime\" c:day=\"9\" c:month=\"1\" c:year=\"2024\"\u003e \u003c/bean\u003e \u003c/beans\u003e MyTime.java package com.powercode.spring6.beans; public class MyTime { private int year; private int month; private int day; public MyTime(int year,int month,int day) { this.year = year; this.month = month; this.day = day; } @Override public String toString() { return \"MyTime{\" + \"year=\" + year + \", month=\" + month + \", day=\" + day + '}'; } } 测试函数 @Test public void testForthSpringCode() { Logger logger = LoggerFactory.getLogger(FirstSpringTest.class); ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring4.xml\"); MyTime myTime = applicationContext.getBean(\"myTimeBean\",MyTime.class); logger.info(myTime.toString()); } /usr/lib/jvm/java-17-openjdk/bin/java -ea -Didea.test.cyclic.buffer.size=1048576 -javaagent:/opt/intellij-idea-ultimate-edition/lib/idea_rt.jar=41855:/opt/intellij-idea-ultimate-edition/bin -Dfile.encoding=UTF-8 -classpath /home/meowrain/.m2/repository/org/junit/platform/junit-platform-launcher/1.10.1/junit-platform-launcher-1.10.1.jar:/home/meowrain/.m2/repository/org/junit/platform/junit-platform-engine/1.10.1/junit-platform-engine-1.10.1.jar:/home/meowrain/.m2/repository/org/junit/jupiter/junit-jupiter-engine/5.10.1/junit-jupiter-engine-5.10.1.jar:/opt/intellij-idea-ultimate-edition/lib/idea_rt.jar:/opt/intellij-idea-ultimate-edition/plugins/junit/lib/junit5-rt.jar:/opt/intellij-idea-ultimate-edition/plugins/junit/lib/junit-rt.jar:/home/meowrain/IdeaProjects/spring_first/target/test-classes:/home/meowrain/IdeaProjects/spring_first/target/classes:/home/meowrain/.m2/repository/org/springframework/spring-context/6.1.0-SNAPSHOT/spring-context-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-aop/6.1.0-SNAPSHOT/spring-aop-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-beans/6.1.0-SNAPSHOT/spring-beans-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-core/6.1.0-SNAPSHOT/spring-core-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-jcl/6.1.0-SNAPSHOT/spring-jcl-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-expression/6.1.0-SNAPSHOT/spring-expression-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/io/micrometer/micrometer-observation/1.12.0/micrometer-observation-1.12.0.jar:/home/meowrain/.m2/repository/io/micrometer/micrometer-commons/1.12.0/micrometer-commons-1.12.0.jar:/home/meowrain/.m2/repository/org/junit/jupiter/junit-jupiter-api/5.10.1/junit-jupiter-api-5.10.1.jar:/home/meowrain/.m2/repository/org/opentest4j/opentest4j/1.3.0/opentest4j-1.3.0.jar:/home/meowrain/.m2/repository/org/junit/platform/junit-platform-commons/1.10.1/junit-platform-commons-1.10.1.jar:/home/meowrain/.m2/repository/org/apiguardian/apiguardian-api/1.1.2/apiguardian-api-1.1.2.jar:/home/meowrain/.m2/repository/org/apache/logging/log4j/log4j-core/2.19.0/log4j-core-2.19.0.jar:/home/meowrain/.m2/repository/org/apache/logging/log4j/log4j-api/2.19.0/log4j-api-2.19.0.jar:/home/meowrain/.m2/repository/org/apache/logging/log4j/log4j-slf4j2-impl/2.19.0/log4j-slf4j2-impl-2.19.0.jar:/home/meowrain/.m2/repository/org/slf4j/slf4j-api/2.0.0/slf4j-api-2.0.0.jar com.intellij.rt.junit.JUnitStarter -ideVersion5 -junit5 com.powercode.spring6.test.FirstSpringTest,testForthSpringCode 2024-01-09 13:07:18 711 [main] DEBUG org.springframework.context.support.ClassPathXmlApp","date":"2024-05-23","objectID":"/posts/bb23c8c/:2:0","tags":["Spring","Java"],"title":"Java Spring笔记03 Spring三种命名空间","uri":"/posts/bb23c8c/"},{"categories":["Java - Spring"],"content":"util命名空间 使用util命名空间可以让配置复用。 使用util命名空间的前提是：在spring配置文件头部添加配置信息。如下： 配置文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:util=\"http://www.springframework.org/schema/util\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd \"\u003e \u003c/beans\u003e \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:util=\"http://www.springframework.org/schema/util\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd \"\u003e \u003cutil:properties id=\"prop\"\u003e \u003cprop key=\"driver\"\u003ecom.mysql.cj.jdbc.Driver\u003c/prop\u003e \u003cprop key=\"url\"\u003ejdbc:mysql://localhost:3306/spring\u003c/prop\u003e \u003cprop key=\"username\"\u003eroot\u003c/prop\u003e \u003cprop key=\"password\"\u003e123456\u003c/prop\u003e \u003c/util:properties\u003e \u003cbean id=\"dataSource1\" class=\"com.powercode.spring6.beans.MyDataSource1\"\u003e \u003cproperty name=\"properties\" ref=\"prop\"/\u003e \u003c/bean\u003e \u003cbean id=\"dataSource2\" class=\"com.powercode.spring6.beans.MyDataSource2\"\u003e \u003cproperty name=\"properties\" ref=\"prop\"/\u003e \u003c/bean\u003e \u003c/beans\u003e MyDataSource1.java package com.powercode.spring6.beans; import java.util.Properties; public class MyDataSource1 { private Properties properties; public void setProperties(Properties properties) { this.properties = properties; } @Override public String toString() { return \"MyDataSource1{\" + \"properties=\" + properties + '}'; } } MyDataSource2.java package com.powercode.spring6.beans; import java.util.Properties; public class MyDataSource2 { private Properties properties; public void setProperties(Properties properties) { this.properties = properties; } @Override public String toString() { return \"MyDataSource2{\" + \"properties=\" + properties + '}'; } } 测试函数 @Test public void testFifthSpringCode() { Logger logger = LoggerFactory.getLogger(FirstSpringTest.class); ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring5.xml\"); MyDataSource1 myDataSource1 = applicationContext.getBean(\"dataSource1\",MyDataSource1.class); MyDataSource2 myDataSource2 = applicationContext.getBean(\"dataSource2\",MyDataSource2.class); logger.info(myDataSource1.toString()); logger.info(myDataSource2.toString()); } 运行结果 /usr/lib/jvm/java-17-openjdk/bin/java -ea -Didea.test.cyclic.buffer.size=1048576 -javaagent:/opt/intellij-idea-ultimate-edition/lib/idea_rt.jar=45041:/opt/intellij-idea-ultimate-edition/bin -Dfile.encoding=UTF-8 -classpath /home/meowrain/.m2/repository/org/junit/platform/junit-platform-launcher/1.10.1/junit-platform-launcher-1.10.1.jar:/home/meowrain/.m2/repository/org/junit/platform/junit-platform-engine/1.10.1/junit-platform-engine-1.10.1.jar:/home/meowrain/.m2/repository/org/junit/jupiter/junit-jupiter-engine/5.10.1/junit-jupiter-engine-5.10.1.jar:/opt/intellij-idea-ultimate-edition/lib/idea_rt.jar:/opt/intellij-idea-ultimate-edition/plugins/junit/lib/junit5-rt.jar:/opt/intellij-idea-ultimate-edition/plugins/junit/lib/junit-rt.jar:/home/meowrain/IdeaProjects/spring_first/target/test-classes:/home/meowrain/IdeaProjects/spring_first/target/classes:/home/meowrain/.m2/repository/org/springframework/spring-context/6.1.0-SNAPSHOT/spring-context-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-aop/6.1.0-SNAPSHOT/spring-aop-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-beans/6.1.0-SNAPSHOT/spring-beans-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-core/6.1.0-SNAPSHOT/spring-core-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-jcl/6.1.0-SNAPSHOT/spring-jcl-6.1","date":"2024-05-23","objectID":"/posts/bb23c8c/:3:0","tags":["Spring","Java"],"title":"Java Spring笔记03 Spring三种命名空间","uri":"/posts/bb23c8c/"},{"categories":["Java - Spring"],"content":"基于的XML自动装配 ","date":"2024-05-23","objectID":"/posts/84be7f4/:1:0","tags":["Spring","Java"],"title":"Java Spring笔记02 Spring自动装配","uri":"/posts/84be7f4/"},{"categories":["Java - Spring"],"content":"根据名称自动装配 UserDao.java package com.powercode.spring6.dao; import org.slf4j.Logger; import org.slf4j.LoggerFactory; /* * Bean * * */ public class UserDao { private static final Logger logger = LoggerFactory.getLogger(UserDao.class); public void insert() { //用log4j2日志框架 logger.info(\"数据库正在插入用户信息\"); } } UserService.java package com.powercode.spring6.service; import com.powercode.spring6.dao.UserDao; public class UserService { private UserDao userDao; private String userName; public int age; public void setUserName(String userName) { this.userName = userName; } public void setAge(int age) { this.age = age; } /*必须提供一个set方法进行set注入*/ public void setUserDao(UserDao userdao) { this.userDao = userdao; } public void saveUser() { //保存用户信息到数据库 userDao.insert(); } @Override public String toString() { return \"UserService{\" + \"userDao=\" + userDao + \", userName='\" + userName + '\\'' + \", age=\" + age + '}'; } } \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"userDao\" class=\"com.powercode.spring6.dao.UserDao\"\u003e\u003c/bean\u003e \u003cbean id=\"userServiceBean\" class=\"com.powercode.spring6.service.UserService\" autowire=\"byName\"\u003e \u003cproperty name=\"userName\" value=\"John Doe\"/\u003e \u003cproperty name=\"age\" value=\"30\"/\u003e \u003c/bean\u003e \u003c/beans\u003e 测试函数 @Test public void testSixthspringCode() { Logger logger = LoggerFactory.getLogger(FirstSpringTest.class); ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring6.xml\"); UserService userService = applicationContext.getBean(\"userServiceBean\", UserService.class); userService.saveUser(); logger.info(userService.toString()); } 注意，java中set方法命名规则 https://blog.csdn.net/hong10086/article/details/78852105 /usr/lib/jvm/java-17-openjdk/bin/java -ea -Didea.test.cyclic.buffer.size=1048576 -javaagent:/opt/intellij-idea-ultimate-edition/lib/idea_rt.jar=36339:/opt/intellij-idea-ultimate-edition/bin -Dfile.encoding=UTF-8 -classpath /home/meowrain/.m2/repository/org/junit/platform/junit-platform-launcher/1.10.1/junit-platform-launcher-1.10.1.jar:/home/meowrain/.m2/repository/org/junit/platform/junit-platform-engine/1.10.1/junit-platform-engine-1.10.1.jar:/home/meowrain/.m2/repository/org/junit/jupiter/junit-jupiter-engine/5.10.1/junit-jupiter-engine-5.10.1.jar:/opt/intellij-idea-ultimate-edition/lib/idea_rt.jar:/opt/intellij-idea-ultimate-edition/plugins/junit/lib/junit5-rt.jar:/opt/intellij-idea-ultimate-edition/plugins/junit/lib/junit-rt.jar:/home/meowrain/IdeaProjects/spring_first/target/test-classes:/home/meowrain/IdeaProjects/spring_first/target/classes:/home/meowrain/.m2/repository/org/springframework/spring-context/6.1.0-SNAPSHOT/spring-context-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-aop/6.1.0-SNAPSHOT/spring-aop-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-beans/6.1.0-SNAPSHOT/spring-beans-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-core/6.1.0-SNAPSHOT/spring-core-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-jcl/6.1.0-SNAPSHOT/spring-jcl-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-expression/6.1.0-SNAPSHOT/spring-expression-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/io/micrometer/micrometer-observation/1.12.0/micrometer-observation-1.12.0.jar:/home/meowrain/.m2/repository/io/micrometer/micrometer-commons/1.12.0/micrometer-commons-1.12.0.jar:/home/meowrain/.m2/repository/org/junit/jupiter/junit-jupiter-api/5.10.1/junit-jupiter-api-5.10.1.jar:/home/meowrain/.m2/repository/org/opentest4j/opentest4j/1.3.0/opentest4j-1.3.0.jar:/home/meowrain/.m2/repository/org/junit/platform/junit-platform-commons/1.10.1/junit-platform-commons-1.10.1.jar:/home/meowrain/.m2/reposito","date":"2024-05-23","objectID":"/posts/84be7f4/:1:1","tags":["Spring","Java"],"title":"Java Spring笔记02 Spring自动装配","uri":"/posts/84be7f4/"},{"categories":["Java - Spring"],"content":"根据类型自动装配 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"accountService\" class=\"com.powercode.spring6.service.AccountService\" autowire=\"byType\"/\u003e \u003cbean class=\"com.powercode.spring6.dao.AccountDao\"/\u003e \u003c/beans\u003e AccountDao.java package com.powercode.spring6.dao; public class AccountDao { public void insert(){ System.out.println(\"正在保存账户信息\"); } } AccountService.java package com.powercode.spring6.service; import com.powercode.spring6.dao.AccountDao; public class AccountService { private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) { this.accountDao = accountDao; } public void save(){ accountDao.insert(); } @Override public String toString() { return \"AccountService{\" + \"accountDao=\" + accountDao + '}'; } } 测试函数 @Test public void testSenventhSpringCode() { Logger logger = LoggerFactory.getLogger(FirstSpringTest.class); ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring7.xml\"); AccountService accountService = applicationContext.getBean(\"accountService\",AccountService.class); accountService.save(); logger.info(accountService.toString()); } /usr/lib/jvm/java-17-openjdk/bin/java -ea -Didea.test.cyclic.buffer.size=1048576 -javaagent:/opt/intellij-idea-ultimate-edition/lib/idea_rt.jar=46597:/opt/intellij-idea-ultimate-edition/bin -Dfile.encoding=UTF-8 -classpath /home/meowrain/.m2/repository/org/junit/platform/junit-platform-launcher/1.10.1/junit-platform-launcher-1.10.1.jar:/home/meowrain/.m2/repository/org/junit/platform/junit-platform-engine/1.10.1/junit-platform-engine-1.10.1.jar:/home/meowrain/.m2/repository/org/junit/jupiter/junit-jupiter-engine/5.10.1/junit-jupiter-engine-5.10.1.jar:/opt/intellij-idea-ultimate-edition/lib/idea_rt.jar:/opt/intellij-idea-ultimate-edition/plugins/junit/lib/junit5-rt.jar:/opt/intellij-idea-ultimate-edition/plugins/junit/lib/junit-rt.jar:/home/meowrain/IdeaProjects/spring_first/target/test-classes:/home/meowrain/IdeaProjects/spring_first/target/classes:/home/meowrain/.m2/repository/org/springframework/spring-context/6.1.0-SNAPSHOT/spring-context-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-aop/6.1.0-SNAPSHOT/spring-aop-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-beans/6.1.0-SNAPSHOT/spring-beans-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-core/6.1.0-SNAPSHOT/spring-core-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-jcl/6.1.0-SNAPSHOT/spring-jcl-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-expression/6.1.0-SNAPSHOT/spring-expression-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/io/micrometer/micrometer-observation/1.12.0/micrometer-observation-1.12.0.jar:/home/meowrain/.m2/repository/io/micrometer/micrometer-commons/1.12.0/micrometer-commons-1.12.0.jar:/home/meowrain/.m2/repository/org/junit/jupiter/junit-jupiter-api/5.10.1/junit-jupiter-api-5.10.1.jar:/home/meowrain/.m2/repository/org/opentest4j/opentest4j/1.3.0/opentest4j-1.3.0.jar:/home/meowrain/.m2/repository/org/junit/platform/junit-platform-commons/1.10.1/junit-platform-commons-1.10.1.jar:/home/meowrain/.m2/repository/org/apiguardian/apiguardian-api/1.1.2/apiguardian-api-1.1.2.jar:/home/meowrain/.m2/repository/org/apache/logging/log4j/log4j-core/2.19.0/log4j-core-2.19.0.jar:/home/meowrain/.m2/repository/org/apache/logging/log4j/log4j-api/2.19.0/log4j-api-2.19.0.jar:/home/meowrain/.m2/repository/org/apache/logging/log4j/log4j-slf4j2-impl/2.19.0/log4j-slf4j2-impl-2.19.0.jar:/home/meowrain/.m2/repository/org/slf4j/slf4j-api/2.0.0/slf4j-api-2.0.0.jar com.intellij.rt.junit.JUnitStarter -ideVersion5 -junit5 com.powercode.spring6.test.FirstSp","date":"2024-05-23","objectID":"/posts/84be7f4/:1:2","tags":["Spring","Java"],"title":"Java Spring笔记02 Spring自动装配","uri":"/posts/84be7f4/"},{"categories":["Java - Spring"],"content":"maven配置 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003eorg.example\u003c/groupId\u003e \u003cartifactId\u003espring_first\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003cproperties\u003e \u003cmaven.compiler.source\u003e17\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e17\u003c/maven.compiler.target\u003e \u003cproject.build.sourceEncoding\u003eUTF-8\u003c/project.build.sourceEncoding\u003e \u003c/properties\u003e \u003crepositories\u003e \u003crepository\u003e \u003cid\u003espring-snapshots\u003c/id\u003e \u003cname\u003eSpring Snapshots\u003c/name\u003e \u003curl\u003ehttps://repo.spring.io/snapshot\u003c/url\u003e \u003creleases\u003e \u003cenabled\u003efalse\u003c/enabled\u003e \u003c/releases\u003e \u003c/repository\u003e \u003c/repositories\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-context\u003c/artifactId\u003e \u003cversion\u003e6.1.0-SNAPSHOT\u003c/version\u003e \u003c/dependency\u003e \u003c!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-api\u003c/artifactId\u003e \u003cversion\u003e5.10.1\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c!--log4j2的依赖--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.logging.log4j\u003c/groupId\u003e \u003cartifactId\u003elog4j-core\u003c/artifactId\u003e \u003cversion\u003e2.19.0\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.logging.log4j\u003c/groupId\u003e \u003cartifactId\u003elog4j-slf4j2-impl\u003c/artifactId\u003e \u003cversion\u003e2.19.0\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e set注入 ","date":"2024-05-23","objectID":"/posts/410ddaa/:0:0","tags":["Spring","Java"],"title":"Java Spring笔记01 Set注入","uri":"/posts/410ddaa/"},{"categories":["Java - Spring"],"content":"注入外部Bean \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"userDaoBean\" class=\"com.powernode.spring6.dao.UserDao\"/\u003e \u003cbean id=\"userServiceBean\" class=\"com.powernode.spring6.service.UserService\"\u003e \u003cproperty name=\"userDao\" ref=\"userDaoBean\"/\u003e \u003c/bean\u003e \u003c/beans\u003e ","date":"2024-05-23","objectID":"/posts/410ddaa/:1:0","tags":["Spring","Java"],"title":"Java Spring笔记01 Set注入","uri":"/posts/410ddaa/"},{"categories":["Java - Spring"],"content":"注入内部Bean \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"userServiceBean\" class=\"com.powernode.spring6.service.UserService\"\u003e \u003cproperty name=\"userDao\"\u003e \u003cbean class=\"com.powernode.spring6.dao.UserDao\"/\u003e \u003c/property\u003e \u003c/bean\u003e \u003c/beans\u003e 不使用ref,直接在里面嵌套一个bean ","date":"2024-05-23","objectID":"/posts/410ddaa/:2:0","tags":["Spring","Java"],"title":"Java Spring笔记01 Set注入","uri":"/posts/410ddaa/"},{"categories":["Java - Spring"],"content":"注入简单类型 UserDaoService.java package com.powercode.spring6.service; import com.powercode.spring6.dao.UserDao; public class UserService { private UserDao userDao; private String userName; public int age; public void setUserName(String userName) { this.userName = userName; } public void setAge(int age) { this.age = age; } /*必须提供一个set方法进行set注入*/ public void setUserDao(UserDao userDao) { this.userDao = userDao; } public void saveUser() { //保存用户信息到数据库 userDao.insert(); } @Override public String toString() { return \"UserService{\" + \"userDao=\" + userDao + \", userName='\" + userName + '\\'' + \", age=\" + age + '}'; } } 对应的xml \u003cbean id=\"userServiceBean\" class=\"com.powercode.spring6.service.UserService\"\u003e \u003cproperty name=\"userDao\" ref=\"userDaoBean\"\u003e\u003c/property\u003e \u003cproperty name=\"userName\"\u003e \u003cvalue\u003emeowrain\u003c/value\u003e \u003c/property\u003e \u003cproperty name=\"age\"\u003e \u003cvalue\u003e20\u003c/value\u003e \u003c/property\u003e \u003c/bean\u003e 我们测试以下 package com.powercode.spring6.test; import com.powercode.spring6.service.UserService; import org.junit.jupiter.api.Test; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class FirstSpringTest { @Test public void testFirstSpringCode() { //第一步：获取spring容器对象 // ApplicationContext 翻译为：应用上下文，也就是Spring容器 // ApplicationContext是一个接口 // ApplicationContext 接口下有很多实现类 // 其中有一个实现类叫做：ClassPathXmlApplicationContext // 这个实现类是专门从类路径中加载spring配置文件的 // ApplicationContext applicationContext = new ClassPathXmlApplicationContext(类路径); Logger logger = LoggerFactory.getLogger(FirstSpringTest.class); ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring.xml\"); // 第二步：根据bean的id从Spring容器中获取这个对象 UserService userService = applicationContext.getBean(\"userServiceBean\", UserService.class); logger.info(userService.toString()); } } 需要特别注意：如果给简单类型赋值，使用value属性或value标签。而不是ref。 ","date":"2024-05-23","objectID":"/posts/410ddaa/:3:0","tags":["Spring","Java"],"title":"Java Spring笔记01 Set注入","uri":"/posts/410ddaa/"},{"categories":["Java - Spring"],"content":"级联属性赋值 要点： ● 在spring配置文件中，如上，注意顺序。 ● 在spring配置文件中，clazz属性必须提供getter方法。 Student.java package com.powercode.spring6.beans; public class Student { private String name; private int age; private Clazz clazz; public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; } public void setClazz(Clazz clazz) { this.clazz = clazz; } public Clazz getClazz() { return clazz; } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + \", clazz=\" + clazz + '}'; } } Clazz.java package com.powercode.spring6.beans; public class Clazz { private String name; public void setName(String name) { this.name = name; } } spring.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"student\" class=\"com.powercode.spring6.beans.Student\"\u003e \u003cproperty name=\"age\" value=\"20\"\u003e\u003c/property\u003e \u003cproperty name=\"name\" value=\"meowrain\"\u003e\u003c/property\u003e \u003cproperty name=\"clazz\" ref=\"clazz\"\u003e\u003c/property\u003e \u003c!--级联属性赋值--\u003e \u003cproperty name=\"clazz.name\" value=\"246\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003cbean id=\"clazz\" class=\"com.powercode.spring6.beans.Clazz\"\u003e\u003c/bean\u003e \u003c/beans\u003e 测试函数 @Test public void testSecondSpringCode() { Logger logger = LoggerFactory.getLogger(FirstSpringTest.class); ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring2.xml\"); Student student = applicationContext.getBean(\"student\", Student.class); logger.info(student.toString()); } ","date":"2024-05-23","objectID":"/posts/410ddaa/:4:0","tags":["Spring","Java"],"title":"Java Spring笔记01 Set注入","uri":"/posts/410ddaa/"},{"categories":["Java - Spring"],"content":"注入数组 Student.java ```java package com.powercode.spring6.beans; public class Student { private String name; private int age; private Clazz clazz; private String[] hobbies; public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; } public void setClazz(Clazz clazz) { this.clazz = clazz; } public void setHobbies(String[] hobbies) { this.hobbies = hobbies; } public Clazz getClazz() { return clazz; } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + \", clazz=\" + clazz + \", hobbies=\" + Arrays.toString(hobbies) + '}'; } } spring2.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"student\" class=\"com.powercode.spring6.beans.Student\"\u003e \u003cproperty name=\"age\" value=\"20\"\u003e\u003c/property\u003e \u003cproperty name=\"name\" value=\"meowrain\"\u003e\u003c/property\u003e \u003cproperty name=\"clazz\" ref=\"clazz\"\u003e\u003c/property\u003e \u003c!--级联属性赋值--\u003e \u003cproperty name=\"clazz.name\" value=\"246\"\u003e\u003c/property\u003e \u003c!--数组属性赋值--\u003e \u003cproperty name=\"hobbies\"\u003e \u003carray\u003e \u003cvalue\u003eplay games\u003c/value\u003e \u003cvalue\u003eprogramming\u003c/value\u003e \u003cvalue\u003elearn use computer\u003c/value\u003e \u003cvalue\u003eplay football\u003c/value\u003e \u003cvalue\u003eeat apples\u003c/value\u003e \u003c/array\u003e \u003c/property\u003e \u003c/bean\u003e \u003cbean id=\"clazz\" class=\"com.powercode.spring6.beans.Clazz\"\u003e\u003c/bean\u003e \u003c/beans\u003e 测试函数 @Test public void testSecondSpringCode() { Logger logger = LoggerFactory.getLogger(FirstSpringTest.class); ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring2.xml\"); Student student = applicationContext.getBean(\"student\", Student.class); logger.info(student.toString()); } /usr/lib/jvm/java-17-openjdk/bin/java -ea -Didea.test.cyclic.buffer.size=1048576 -javaagent:/opt/intellij-idea-ultimate-edition/lib/idea_rt.jar=36671:/opt/intellij-idea-ultimate-edition/bin -Dfile.encoding=UTF-8 -classpath /home/meowrain/.m2/repository/org/junit/platform/junit-platform-launcher/1.10.1/junit-platform-launcher-1.10.1.jar:/home/meowrain/.m2/repository/org/junit/platform/junit-platform-engine/1.10.1/junit-platform-engine-1.10.1.jar:/home/meowrain/.m2/repository/org/junit/jupiter/junit-jupiter-engine/5.10.1/junit-jupiter-engine-5.10.1.jar:/opt/intellij-idea-ultimate-edition/lib/idea_rt.jar:/opt/intellij-idea-ultimate-edition/plugins/junit/lib/junit5-rt.jar:/opt/intellij-idea-ultimate-edition/plugins/junit/lib/junit-rt.jar:/home/meowrain/IdeaProjects/spring_first/target/test-classes:/home/meowrain/IdeaProjects/spring_first/target/classes:/home/meowrain/.m2/repository/org/springframework/spring-context/6.1.0-SNAPSHOT/spring-context-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-aop/6.1.0-SNAPSHOT/spring-aop-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-beans/6.1.0-SNAPSHOT/spring-beans-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-core/6.1.0-SNAPSHOT/spring-core-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-jcl/6.1.0-SNAPSHOT/spring-jcl-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-expression/6.1.0-SNAPSHOT/spring-expression-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/io/micrometer/micrometer-observation/1.12.0/micrometer-observation-1.12.0.jar:/home/meowrain/.m2/repository/io/micrometer/micrometer-commons/1.12.0/micrometer-commons-1.12.0.jar:/home/meowrain/.m2/repository/org/junit/jupiter/junit-jupiter-api/5.10.1/junit-jupiter-api-5.10.1.jar:/home/meowrain/.m2/repository/org/opentest4j/opentest4j/1.3.0/opentest4j-1.3.0.jar:/home/meowrain/.m2/repository/org/junit/platform/junit-platform-commons/1.10.1/junit-platform-commons-1.10.1.jar:/home/meowrain/.m2/repository/org/apiguardian/apiguardian-api/1.1.2/apiguardian-api-1.1.2.jar:/home/meowrain/.m2/reposito","date":"2024-05-23","objectID":"/posts/410ddaa/:5:0","tags":["Spring","Java"],"title":"Java Spring笔记01 Set注入","uri":"/posts/410ddaa/"},{"categories":["Java - Spring"],"content":"注入list集合 package com.powercode.spring6.beans; import java.util.Arrays; import java.util.List; public class Student { private String name; private int age; private Clazz clazz; private List hobbies; public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; } public void setClazz(Clazz clazz) { this.clazz = clazz; } public void setHobbies(List hobbies) { this.hobbies = hobbies; } public Clazz getClazz() { return clazz; } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + \", clazz=\" + clazz + \", hobbies=\" + hobbies + '}'; } } \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"student\" class=\"com.powercode.spring6.beans.Student\"\u003e \u003cproperty name=\"age\" value=\"20\"\u003e\u003c/property\u003e \u003cproperty name=\"name\" value=\"meowrain\"\u003e\u003c/property\u003e \u003cproperty name=\"clazz\" ref=\"clazz\"\u003e\u003c/property\u003e \u003c!--级联属性赋值--\u003e \u003cproperty name=\"clazz.name\" value=\"246\"\u003e\u003c/property\u003e \u003c!--数组属性赋值--\u003e \u003cproperty name=\"hobbies\"\u003e \u003clist\u003e \u003cvalue\u003eplay games\u003c/value\u003e \u003cvalue\u003eprogramming\u003c/value\u003e \u003cvalue\u003elearn use computer\u003c/value\u003e \u003cvalue\u003eplay football\u003c/value\u003e \u003cvalue\u003eeat apples\u003c/value\u003e \u003c/list\u003e \u003c/property\u003e \u003c/bean\u003e \u003cbean id=\"clazz\" class=\"com.powercode.spring6.beans.Clazz\"\u003e\u003c/bean\u003e \u003c/beans\u003e 2024-01-09 11:49:17 697 [main] DEBUG org.springframework.context.support.ClassPathXmlApplicationContext - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@75ed9710 2024-01-09 11:49:17 798 [main] DEBUG org.springframework.beans.factory.xml.XmlBeanDefinitionReader - Loaded 2 bean definitions from class path resource [spring2.xml] 2024-01-09 11:49:17 814 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'student' 2024-01-09 11:49:17 837 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'clazz' 2024-01-09 11:49:17 850 [main] INFO com.powercode.spring6.test.FirstSpringTest - Student{name='meowrain', age=20, clazz=com.powercode.spring6.beans.Clazz@1ad777f, hobbies=[play games, programming, learn use computer, play football, eat apples]} 进程已结束，退出代码为 0 注意：注入List集合的时候使用list标签，如果List集合中是简单类型使用value标签，反之使用ref标签。 ","date":"2024-05-23","objectID":"/posts/410ddaa/:6:0","tags":["Spring","Java"],"title":"Java Spring笔记01 Set注入","uri":"/posts/410ddaa/"},{"categories":["Java - Spring"],"content":"注入set集合 不多说，和上面差不多 要点： ● 使用标签 ● set集合中元素是简单类型的使用value标签，反之使用ref标签。 ","date":"2024-05-23","objectID":"/posts/410ddaa/:7:0","tags":["Spring","Java"],"title":"Java Spring笔记01 Set注入","uri":"/posts/410ddaa/"},{"categories":["Java - Spring"],"content":"注入Properties java.util.Properties继承java.util.Hashtable，所以Properties也是一个Map集合。 Student.java package com.powercode.spring6.beans; import java.util.Arrays; import java.util.List; import java.util.Properties; public class Student { private String name; private int age; private Clazz clazz; private List hobbies; private Properties properties; public void setProperties(Properties properties) { this.properties = properties; } public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; } public void setClazz(Clazz clazz) { this.clazz = clazz; } public void setHobbies(List hobbies) { this.hobbies = hobbies; } public Clazz getClazz() { return clazz; } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + \", clazz=\" + clazz + \", hobbies=\" + hobbies + \", properties=\" + properties + '}'; } } 测试函数 @Test public void testSecondSpringCode() { Logger logger = LoggerFactory.getLogger(FirstSpringTest.class); ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring2.xml\"); Student student = applicationContext.getBean(\"student\", Student.class); logger.info(student.toString()); } /usr/lib/jvm/java-17-openjdk/bin/java -ea -Didea.test.cyclic.buffer.size=1048576 -javaagent:/opt/intellij-idea-ultimate-edition/lib/idea_rt.jar=44101:/opt/intellij-idea-ultimate-edition/bin -Dfile.encoding=UTF-8 -classpath /home/meowrain/.m2/repository/org/junit/platform/junit-platform-launcher/1.10.1/junit-platform-launcher-1.10.1.jar:/home/meowrain/.m2/repository/org/junit/platform/junit-platform-engine/1.10.1/junit-platform-engine-1.10.1.jar:/home/meowrain/.m2/repository/org/junit/jupiter/junit-jupiter-engine/5.10.1/junit-jupiter-engine-5.10.1.jar:/opt/intellij-idea-ultimate-edition/lib/idea_rt.jar:/opt/intellij-idea-ultimate-edition/plugins/junit/lib/junit5-rt.jar:/opt/intellij-idea-ultimate-edition/plugins/junit/lib/junit-rt.jar:/home/meowrain/IdeaProjects/spring_first/target/test-classes:/home/meowrain/IdeaProjects/spring_first/target/classes:/home/meowrain/.m2/repository/org/springframework/spring-context/6.1.0-SNAPSHOT/spring-context-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-aop/6.1.0-SNAPSHOT/spring-aop-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-beans/6.1.0-SNAPSHOT/spring-beans-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-core/6.1.0-SNAPSHOT/spring-core-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-jcl/6.1.0-SNAPSHOT/spring-jcl-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-expression/6.1.0-SNAPSHOT/spring-expression-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/io/micrometer/micrometer-observation/1.12.0/micrometer-observation-1.12.0.jar:/home/meowrain/.m2/repository/io/micrometer/micrometer-commons/1.12.0/micrometer-commons-1.12.0.jar:/home/meowrain/.m2/repository/org/junit/jupiter/junit-jupiter-api/5.10.1/junit-jupiter-api-5.10.1.jar:/home/meowrain/.m2/repository/org/opentest4j/opentest4j/1.3.0/opentest4j-1.3.0.jar:/home/meowrain/.m2/repository/org/junit/platform/junit-platform-commons/1.10.1/junit-platform-commons-1.10.1.jar:/home/meowrain/.m2/repository/org/apiguardian/apiguardian-api/1.1.2/apiguardian-api-1.1.2.jar:/home/meowrain/.m2/repository/org/apache/logging/log4j/log4j-core/2.19.0/log4j-core-2.19.0.jar:/home/meowrain/.m2/repository/org/apache/logging/log4j/log4j-api/2.19.0/log4j-api-2.19.0.jar:/home/meowrain/.m2/repository/org/apache/logging/log4j/log4j-slf4j2-impl/2.19.0/log4j-slf4j2-impl-2.19.0.jar:/home/meowrain/.m2/repository/org/slf4j/slf4j-api/2.0.0/slf4j-api-2.0.0.jar com.intellij.rt.junit.JUnitStarter -ideVersion5 -junit5 com.powercode.spring6.test.FirstSpringTest,testSecondSpringCode 2024-01-09 12:13:56 046 [main] DEBUG org.springframework.context.support.ClassPathXmlApplicationContext - Refreshing org.springfra","date":"2024-05-23","objectID":"/posts/410ddaa/:8:0","tags":["Spring","Java"],"title":"Java Spring笔记01 Set注入","uri":"/posts/410ddaa/"},{"categories":["Java - Spring"],"content":"注入null和空字符串 注入空字符串使用：\u003cvalue/\u003e 或者 value=\"\" 注入null使用：\u003cnull/\u003e 或者 不为该属性赋值 Student.java package com.powercode.spring6.beans; import java.util.Arrays; import java.util.List; import java.util.Properties; public class Student { private String name; private int age; private Clazz clazz; private List hobbies; private Properties properties; private String email; public void setEmail(String email) { this.email = email; } public void setProperties(Properties properties) { this.properties = properties; } public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; } public void setClazz(Clazz clazz) { this.clazz = clazz; } public void setHobbies(List hobbies) { this.hobbies = hobbies; } public Clazz getClazz() { return clazz; } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + \", clazz=\" + clazz + \", hobbies=\" + hobbies + \", properties=\" + properties + \", email='\" + email + '\\'' + '}'; } } spring2.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u003c!-- bean标签的两个重要属性 id: 是这个bean的身份证号，不能重复，是唯一的标识 class: 必须填写类的全路径，带包名的类名 --\u003e \u003c!-- 配置其他的bean--\u003e \u003cbean id=\"userDaoBean\" class=\"com.powercode.spring6.dao.UserDao\"\u003e\u003c/bean\u003e \u003c!--配置iservice--\u003e \u003cbean id=\"userServiceBean\" class=\"com.powercode.spring6.service.UserService\"\u003e \u003cproperty name=\"userDao\" ref=\"userDaoBean\"\u003e\u003c/property\u003e \u003cproperty name=\"userName\"\u003e \u003cvalue\u003emeowrain\u003c/value\u003e \u003c/property\u003e \u003cproperty name=\"age\"\u003e \u003cvalue\u003e20\u003c/value\u003e \u003c/property\u003e \u003c/bean\u003e \u003cbean id=\"orderDaoBean\" class=\"com.powercode.spring6.dao.OrderDao\"\u003e\u003c/bean\u003e \u003cbean id=\"orderDaoService\" class=\"com.powercode.spring6.service.OrderDaoService\"\u003e \u003cconstructor-arg index=\"0\" ref=\"orderDaoBean\"\u003e\u003c/constructor-arg\u003e \u003cconstructor-arg index=\"1\" ref=\"userDaoBean\"\u003e\u003c/constructor-arg\u003e \u003c/bean\u003e \u003c/beans\u003e --- ```java 测试程序 @Test public void testSecondSpringCode() { Logger logger = LoggerFactory.getLogger(FirstSpringTest.class); ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring2.xml\"); Student student = applicationContext.getBean(\"student\", Student.class); logger.info(student.toString()); } /usr/lib/jvm/java-17-openjdk/bin/java -ea -Didea.test.cyclic.buffer.size=1048576 -javaagent:/opt/intellij-idea-ultimate-edition/lib/idea_rt.jar=37501:/opt/intellij-idea-ultimate-edition/bin -Dfile.encoding=UTF-8 -classpath /home/meowrain/.m2/repository/org/junit/platform/junit-platform-launcher/1.10.1/junit-platform-launcher-1.10.1.jar:/home/meowrain/.m2/repository/org/junit/platform/junit-platform-engine/1.10.1/junit-platform-engine-1.10.1.jar:/home/meowrain/.m2/repository/org/junit/jupiter/junit-jupiter-engine/5.10.1/junit-jupiter-engine-5.10.1.jar:/opt/intellij-idea-ultimate-edition/lib/idea_rt.jar:/opt/intellij-idea-ultimate-edition/plugins/junit/lib/junit5-rt.jar:/opt/intellij-idea-ultimate-edition/plugins/junit/lib/junit-rt.jar:/home/meowrain/IdeaProjects/spring_first/target/test-classes:/home/meowrain/IdeaProjects/spring_first/target/classes:/home/meowrain/.m2/repository/org/springframework/spring-context/6.1.0-SNAPSHOT/spring-context-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-aop/6.1.0-SNAPSHOT/spring-aop-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-beans/6.1.0-SNAPSHOT/spring-beans-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-core/6.1.0-SNAPSHOT/spring-core-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-jcl/6.1.0-SNAPSHOT/spring-jcl-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/o","date":"2024-05-23","objectID":"/posts/410ddaa/:9:0","tags":["Spring","Java"],"title":"Java Spring笔记01 Set注入","uri":"/posts/410ddaa/"},{"categories":["Java - Spring"],"content":"注入的值中含有特殊符号 XML中有5个特殊字符，分别是：\u003c、\u003e、'、\"、\u0026 以上5个特殊符号在XML中会被特殊对待，会被当做XML语法的一部分进行解析，如果这些特殊符号直接出现在注入的字符串当中，会报错。 解决方案包括两种： ● 第一种：特殊符号使用转义字符代替。 ● 第二种：将含有特殊符号的字符串放到：\u003c![CDATA[]]\u003e 当中。因为放在CDATA区中的数据不会被XML文件解析器解析。 特殊字符 转义字符 \u003e \u0026gt; \u003c \u0026lt; \" \u0026quot; \u0026 \u0026amp; ' \u0026apos; Student.java package com.powercode.spring6.beans; import java.util.Arrays; import java.util.List; import java.util.Properties; public class Student { private String name; private int age; private Clazz clazz; private List hobbies; private Properties properties; private String email; private String result; public void setEmail(String email) { this.email = email; } public void setProperties(Properties properties) { this.properties = properties; } public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; } public void setClazz(Clazz clazz) { this.clazz = clazz; } public void setHobbies(List hobbies) { this.hobbies = hobbies; } public Clazz getClazz() { return clazz; } public void setResult(String result) { this.result = result; } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + \", clazz=\" + clazz + \", hobbies=\" + hobbies + \", properties=\" + properties + \", email='\" + email + '\\'' + \", result='\" + result + '\\'' + '}'; } } \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"student\" class=\"com.powercode.spring6.beans.Student\"\u003e \u003c!--简单属性赋值--\u003e \u003cproperty name=\"age\" value=\"20\"\u003e\u003c/property\u003e \u003cproperty name=\"name\" value=\"meowrain\"\u003e\u003c/property\u003e \u003cproperty name=\"result\" value=\"2 \u0026lt; 3\"/\u003e \u003cproperty name=\"email\"\u003e \u003cvalue/\u003e \u003c!--注入空字符串--\u003e \u003c/property\u003e \u003c!--复合属性赋值--\u003e \u003cproperty name=\"clazz\"\u003e \u003cnull/\u003e \u003c!--注入null--\u003e \u003c/property\u003e \u003c!--数组属性赋值--\u003e \u003cproperty name=\"hobbies\"\u003e \u003clist\u003e \u003cvalue\u003eplay games\u003c/value\u003e \u003cvalue\u003eprogramming\u003c/value\u003e \u003cvalue\u003elearn use computer\u003c/value\u003e \u003cvalue\u003eplay football\u003c/value\u003e \u003cvalue\u003eeat apples\u003c/value\u003e \u003c/list\u003e \u003c/property\u003e \u003c!--propertiess属性赋值--\u003e \u003cproperty name=\"properties\"\u003e \u003cprops\u003e \u003cprop key=\"driver\"\u003ecom.mysql.cj.jdbc.Driver\u003c/prop\u003e \u003cprop key=\"url\"\u003ejdbc:mysql://localhost:3306/spring\u003c/prop\u003e \u003cprop key=\"username\"\u003eroot\u003c/prop\u003e \u003cprop key=\"password\"\u003e123456\u003c/prop\u003e \u003c/props\u003e \u003c/property\u003e \u003c/bean\u003e \u003cbean id=\"clazz\" class=\"com.powercode.spring6.beans.Clazz\"\u003e\u003c/bean\u003e \u003c/beans\u003e \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"student\" class=\"com.powercode.spring6.beans.Student\"\u003e \u003c!--简单属性赋值--\u003e \u003cproperty name=\"age\" value=\"20\"\u003e\u003c/property\u003e \u003cproperty name=\"name\" value=\"meowrain\"\u003e\u003c/property\u003e \u003cproperty name=\"result\"\u003e \u003cvalue\u003e\u003c![CDATA[2\u003c3]]\u003e\u003c/value\u003e \u003c/property\u003e \u003cproperty name=\"email\"\u003e \u003cvalue/\u003e \u003c!--注入空字符串--\u003e \u003c/property\u003e \u003c!--复合属性赋值--\u003e \u003cproperty name=\"clazz\"\u003e \u003cnull/\u003e \u003c!--注入null--\u003e \u003c/property\u003e \u003c!--数组属性赋值--\u003e \u003cproperty name=\"hobbies\"\u003e \u003clist\u003e \u003cvalue\u003eplay games\u003c/value\u003e \u003cvalue\u003eprogramming\u003c/value\u003e \u003cvalue\u003elearn use computer\u003c/value\u003e \u003cvalue\u003eplay football\u003c/value\u003e \u003cvalue\u003eeat apples\u003c/value\u003e \u003c/list\u003e \u003c/property\u003e \u003c!--propertiess属性赋值--\u003e \u003cproperty name=\"properties\"\u003e \u003cprops\u003e \u003cprop key=\"driver\"\u003ecom.mysql.cj.jdbc.Driver\u003c/prop\u003e \u003cprop key=\"url\"\u003ejdbc:mysql://localhost:3306/spring\u003c/prop\u003e \u003cprop key=\"username\"\u003eroot\u003c/prop\u003e \u003cprop key=\"password\"\u003e123456\u003c/prop\u003e \u003c/props\u003e \u003c/property\u003e \u003c/bean\u003e \u003cbean id=\"clazz\" class=\"com.powercode.spring6.beans.Clazz\"\u003e\u003c/bean\u003e \u003c/beans\u003e /usr/lib/jvm/java-17-openjdk/bin/java -ea -Didea.test.cyclic.buffer.size=1048576 -javaagent:/opt/intellij-idea-ultimate-edition/lib/idea_rt.jar=43345:/opt/intellij-idea-ultimate-edition/bin -Dfile.encoding=UTF-8 -classpath /home/meowrain/.m2/repository/org/junit/platform/junit-platform-launcher/1.10.1/junit-platform-launcher-1.10.1.jar:/home/meow","date":"2024-05-23","objectID":"/posts/410ddaa/:10:0","tags":["Spring","Java"],"title":"Java Spring笔记01 Set注入","uri":"/posts/410ddaa/"},{"categories":["Java - Spring"],"content":"p命名空间注入 目的：简化配置。 使用p命名空间注入的前提条件包括两个： ● 第一：在XML头部信息中添加p命名空间的配置信息：xmlns:p=“http://www.springframework.org/schema/p\" ● 第二：p命名空间注入是基于setter方法的，所以需要对应的属性提供setter方法。 Customer.java package com.powercode.spring6.beans; public class Customer { private String name; private int age; public void setName(String name) { this.name = name; } public void setAge(int age){ this.age = age; } @Override public String toString() { return \"Customer{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } spring3.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"customerBean\" class=\"com.powercode.spring6.beans.Customer\" p:name=\"meowrain\" p:age=\"20\"\u003e\u003c/bean\u003e \u003c/beans\u003e 测试函数 @Test public void testThirdSpringCode() { Logger logger = LoggerFactory.getLogger(FirstSpringTest.class); ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring3.xml\"); Customer customer = applicationContext.getBean(\"customerBean\",Customer.class); logger.info(customer.toString()); } 函数执行结果 /usr/lib/jvm/java-17-openjdk/bin/java -ea -Didea.test.cyclic.buffer.size=1048576 -javaagent:/opt/intellij-idea-ultimate-edition/lib/idea_rt.jar=39503:/opt/intellij-idea-ultimate-edition/bin -Dfile.encoding=UTF-8 -classpath /home/meowrain/.m2/repository/org/junit/platform/junit-platform-launcher/1.10.1/junit-platform-launcher-1.10.1.jar:/home/meowrain/.m2/repository/org/junit/platform/junit-platform-engine/1.10.1/junit-platform-engine-1.10.1.jar:/home/meowrain/.m2/repository/org/junit/jupiter/junit-jupiter-engine/5.10.1/junit-jupiter-engine-5.10.1.jar:/opt/intellij-idea-ultimate-edition/lib/idea_rt.jar:/opt/intellij-idea-ultimate-edition/plugins/junit/lib/junit5-rt.jar:/opt/intellij-idea-ultimate-edition/plugins/junit/lib/junit-rt.jar:/home/meowrain/IdeaProjects/spring_first/target/test-classes:/home/meowrain/IdeaProjects/spring_first/target/classes:/home/meowrain/.m2/repository/org/springframework/spring-context/6.1.0-SNAPSHOT/spring-context-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-aop/6.1.0-SNAPSHOT/spring-aop-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-beans/6.1.0-SNAPSHOT/spring-beans-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-core/6.1.0-SNAPSHOT/spring-core-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-jcl/6.1.0-SNAPSHOT/spring-jcl-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-expression/6.1.0-SNAPSHOT/spring-expression-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/io/micrometer/micrometer-observation/1.12.0/micrometer-observation-1.12.0.jar:/home/meowrain/.m2/repository/io/micrometer/micrometer-commons/1.12.0/micrometer-commons-1.12.0.jar:/home/meowrain/.m2/repository/org/junit/jupiter/junit-jupiter-api/5.10.1/junit-jupiter-api-5.10.1.jar:/home/meowrain/.m2/repository/org/opentest4j/opentest4j/1.3.0/opentest4j-1.3.0.jar:/home/meowrain/.m2/repository/org/junit/platform/junit-platform-commons/1.10.1/junit-platform-commons-1.10.1.jar:/home/meowrain/.m2/repository/org/apiguardian/apiguardian-api/1.1.2/apiguardian-api-1.1.2.jar:/home/meowrain/.m2/repository/org/apache/logging/log4j/log4j-core/2.19.0/log4j-core-2.19.0.jar:/home/meowrain/.m2/repository/org/apache/logging/log4j/log4j-api/2.19.0/log4j-api-2.19.0.jar:/home/meowrain/.m2/repository/org/apache/logging/log4j/log4j-slf4j2-impl/2.19.0/log4j-slf4j2-impl-2.19.0.jar:/home/meowrain/.m2/repository/org/slf4j/slf4j-api/2.0.0/slf4j-api-2.0.0.jar com.intellij.rt.junit.JUnitStarter -ideVersion5 -junit5 com.powercode.spring6.test.FirstSpringTest,testThirdSpringCode 2024-01-09 12:52:54 636 [main] DEBUG org.springframew","date":"2024-05-23","objectID":"/posts/410ddaa/:11:0","tags":["Spring","Java"],"title":"Java Spring笔记01 Set注入","uri":"/posts/410ddaa/"},{"categories":["Java - Spring"],"content":"c命名空间注入 c命名空间是简化构造方法注入的。 使用c命名空间的两个前提条件： 第一：需要在xml配置文件头部添加信息：xmlns:c=\"http://www.springframework.org/schema/c\" 第二：需要提供构造方法。 配置文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:c=\"http://www.springframework.org/schema/c\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"myTimeBean\" class=\"com.powercode.spring6.beans.MyTime\" c:day=\"9\" c:month=\"1\" c:year=\"2024\"\u003e \u003c/bean\u003e \u003c/beans\u003e MyTime.java package com.powercode.spring6.beans; public class MyTime { private int year; private int month; private int day; public MyTime(int year,int month,int day) { this.year = year; this.month = month; this.day = day; } @Override public String toString() { return \"MyTime{\" + \"year=\" + year + \", month=\" + month + \", day=\" + day + '}'; } } 测试函数 @Test public void testForthSpringCode() { Logger logger = LoggerFactory.getLogger(FirstSpringTest.class); ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring4.xml\"); MyTime myTime = applicationContext.getBean(\"myTimeBean\",MyTime.class); logger.info(myTime.toString()); } /usr/lib/jvm/java-17-openjdk/bin/java -ea -Didea.test.cyclic.buffer.size=1048576 -javaagent:/opt/intellij-idea-ultimate-edition/lib/idea_rt.jar=41855:/opt/intellij-idea-ultimate-edition/bin -Dfile.encoding=UTF-8 -classpath /home/meowrain/.m2/repository/org/junit/platform/junit-platform-launcher/1.10.1/junit-platform-launcher-1.10.1.jar:/home/meowrain/.m2/repository/org/junit/platform/junit-platform-engine/1.10.1/junit-platform-engine-1.10.1.jar:/home/meowrain/.m2/repository/org/junit/jupiter/junit-jupiter-engine/5.10.1/junit-jupiter-engine-5.10.1.jar:/opt/intellij-idea-ultimate-edition/lib/idea_rt.jar:/opt/intellij-idea-ultimate-edition/plugins/junit/lib/junit5-rt.jar:/opt/intellij-idea-ultimate-edition/plugins/junit/lib/junit-rt.jar:/home/meowrain/IdeaProjects/spring_first/target/test-classes:/home/meowrain/IdeaProjects/spring_first/target/classes:/home/meowrain/.m2/repository/org/springframework/spring-context/6.1.0-SNAPSHOT/spring-context-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-aop/6.1.0-SNAPSHOT/spring-aop-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-beans/6.1.0-SNAPSHOT/spring-beans-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-core/6.1.0-SNAPSHOT/spring-core-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-jcl/6.1.0-SNAPSHOT/spring-jcl-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-expression/6.1.0-SNAPSHOT/spring-expression-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/io/micrometer/micrometer-observation/1.12.0/micrometer-observation-1.12.0.jar:/home/meowrain/.m2/repository/io/micrometer/micrometer-commons/1.12.0/micrometer-commons-1.12.0.jar:/home/meowrain/.m2/repository/org/junit/jupiter/junit-jupiter-api/5.10.1/junit-jupiter-api-5.10.1.jar:/home/meowrain/.m2/repository/org/opentest4j/opentest4j/1.3.0/opentest4j-1.3.0.jar:/home/meowrain/.m2/repository/org/junit/platform/junit-platform-commons/1.10.1/junit-platform-commons-1.10.1.jar:/home/meowrain/.m2/repository/org/apiguardian/apiguardian-api/1.1.2/apiguardian-api-1.1.2.jar:/home/meowrain/.m2/repository/org/apache/logging/log4j/log4j-core/2.19.0/log4j-core-2.19.0.jar:/home/meowrain/.m2/repository/org/apache/logging/log4j/log4j-api/2.19.0/log4j-api-2.19.0.jar:/home/meowrain/.m2/repository/org/apache/logging/log4j/log4j-slf4j2-impl/2.19.0/log4j-slf4j2-impl-2.19.0.jar:/home/meowrain/.m2/repository/org/slf4j/slf4j-api/2.0.0/slf4j-api-2.0.0.jar com.intellij.rt.junit.JUnitStarter -ideVersion5 -junit5 com.powercode.spring6.test.FirstSpringTest,testForthSpringCode 2024-01-09 13:07:18 711 [main] DEBUG org.springframework.context.support.ClassPathXmlApp","date":"2024-05-23","objectID":"/posts/410ddaa/:12:0","tags":["Spring","Java"],"title":"Java Spring笔记01 Set注入","uri":"/posts/410ddaa/"},{"categories":["Java - Spring"],"content":"util命名空间 使用util命名空间可以让配置复用。 使用util命名空间的前提是：在spring配置文件头部添加配置信息。如下： 配置文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:util=\"http://www.springframework.org/schema/util\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd \"\u003e \u003c/beans\u003e MyDataSource1.java package com.powercode.spring6.beans; import java.util.Properties; public class MyDataSource1 { private Properties properties; public void setProperties(Properties properties) { this.properties = properties; } @Override public String toString() { return \"MyDataSource1{\" + \"properties=\" + properties + '}'; } } MyDataSource2.java package com.powercode.spring6.beans; import java.util.Properties; public class MyDataSource2 { private Properties properties; public void setProperties(Properties properties) { this.properties = properties; } @Override public String toString() { return \"MyDataSource2{\" + \"properties=\" + properties + '}'; } } 测试函数 @Test public void testFifthSpringCode() { Logger logger = LoggerFactory.getLogger(FirstSpringTest.class); ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring5.xml\"); MyDataSource1 myDataSource1 = applicationContext.getBean(\"dataSource1\",MyDataSource1.class); MyDataSource2 myDataSource2 = applicationContext.getBean(\"dataSource2\",MyDataSource2.class); logger.info(myDataSource1.toString()); logger.info(myDataSource2.toString()); } 运行结果 /usr/lib/jvm/java-17-openjdk/bin/java -ea -Didea.test.cyclic.buffer.size=1048576 -javaagent:/opt/intellij-idea-ultimate-edition/lib/idea_rt.jar=45041:/opt/intellij-idea-ultimate-edition/bin -Dfile.encoding=UTF-8 -classpath /home/meowrain/.m2/repository/org/junit/platform/junit-platform-launcher/1.10.1/junit-platform-launcher-1.10.1.jar:/home/meowrain/.m2/repository/org/junit/platform/junit-platform-engine/1.10.1/junit-platform-engine-1.10.1.jar:/home/meowrain/.m2/repository/org/junit/jupiter/junit-jupiter-engine/5.10.1/junit-jupiter-engine-5.10.1.jar:/opt/intellij-idea-ultimate-edition/lib/idea_rt.jar:/opt/intellij-idea-ultimate-edition/plugins/junit/lib/junit5-rt.jar:/opt/intellij-idea-ultimate-edition/plugins/junit/lib/junit-rt.jar:/home/meowrain/IdeaProjects/spring_first/target/test-classes:/home/meowrain/IdeaProjects/spring_first/target/classes:/home/meowrain/.m2/repository/org/springframework/spring-context/6.1.0-SNAPSHOT/spring-context-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-aop/6.1.0-SNAPSHOT/spring-aop-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-beans/6.1.0-SNAPSHOT/spring-beans-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-core/6.1.0-SNAPSHOT/spring-core-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-jcl/6.1.0-SNAPSHOT/spring-jcl-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/org/springframework/spring-expression/6.1.0-SNAPSHOT/spring-expression-6.1.0-20231116.112758-846.jar:/home/meowrain/.m2/repository/io/micrometer/micrometer-observation/1.12.0/micrometer-observation-1.12.0.jar:/home/meowrain/.m2/repository/io/micrometer/micrometer-commons/1.12.0/micrometer-commons-1.12.0.jar:/home/meowrain/.m2/repository/org/junit/jupiter/junit-jupiter-api/5.10.1/junit-jupiter-api-5.10.1.jar:/home/meowrain/.m2/repository/org/opentest4j/opentest4j/1.3.0/opentest4j-1.3.0.jar:/home/meowrain/.m2/repository/org/junit/platform/junit-platform-commons/1.10.1/junit-platform-commons-1.10.1.jar:/home/meowrain/.m2/repository/org/apiguardian/apiguardian-api/1.1.2/apiguardian-api-1.1.2.jar:/home/meowrain/.m2/repository/org/apache/logging/log4j/log4j-core/2.19.0/log4j-core-2.19.0.jar:/home/meowrain/.m2/repository/org/apache/logging/log4j/log4j-api","date":"2024-05-23","objectID":"/posts/410ddaa/:13:0","tags":["Spring","Java"],"title":"Java Spring笔记01 Set注入","uri":"/posts/410ddaa/"},{"categories":["Java"],"content":"Java PO,BO,VO,DTO,POJO,DAO概念 一篇文章讲清楚VO，BO，PO，DO，DTO的区别 - 知乎 (zhihu.com) ","date":"2024-05-23","objectID":"/posts/31c8a8c/:0:0","tags":["后端开发","Java"],"title":"JavaPO,BO,VO,DTO,POJO,DAO概念","uri":"/posts/31c8a8c/"},{"categories":["Java"],"content":"POJO (Plain Old Java Object) Java POJO (Plain Old Java Object) 是指一个最基本的、普通的Java对象。POJO通常具有以下特点: 只包含私有属性,没有public、protected的属性。属性通常用private修饰。 提供getter和setter方法来访问和修改属性。 不继承或实现任何特定的接口和类。 不包含任何注解。 不依赖外部jar包和类库。 除了基本的构造方法、getter/setter方法、equals/hashCode/toString方法之外,没有任何其他方法。 POJO主要用于表示简单的数据结构,其设计符合面向对象的基本原则,可以很方便地进行序列化和反序列化。在Java Web应用中,POJO常用来接收和传递数据,例如作为Model对象。Spring框架也大量采用POJO设计模式。所以简单来说,POJO就是一个最基本的Java类,没有复杂的依赖关系,用来表示简单的数据模型。 ","date":"2024-05-23","objectID":"/posts/31c8a8c/:1:0","tags":["后端开发","Java"],"title":"JavaPO,BO,VO,DTO,POJO,DAO概念","uri":"/posts/31c8a8c/"},{"categories":["Java"],"content":"DTO（Data Transfer Object）数据传输对象 DTO是一个比较特殊的对象，他有两种存在形式： 在后端，他的存在形式是java对象，也就是在controller里面定义的那个东东，通常在后端不需要关心怎么从json转成java对象的，这个都是由一些成熟的框架帮你完成啦，比如spring框架 在前端，他的存在形式通常是js里面的对象（也可以简单理解成json），也就是通过ajax请求的那个数据体 这也是为什么把他画成横跨两层的原因 这里可能会遇到个问题，现在微服务盛行，服务和服务之间调用的传输对象能叫DTO吗？ 我的理解是看情况 DTO本身的一个隐含的意义是要能够完整的表达一个业务模块的输出 如果服务和服务之间相对独立，那就可以叫DTO 如果服务和服务之间不独立，每个都不是一个完整的业务模块，拆开可能仅仅是因为计算复杂度或者性能的问题，那这就不能够叫做DTO，只能是BO ","date":"2024-05-23","objectID":"/posts/31c8a8c/:2:0","tags":["后端开发","Java"],"title":"JavaPO,BO,VO,DTO,POJO,DAO概念","uri":"/posts/31c8a8c/"},{"categories":["Java"],"content":"VO (View Object) VO就是展示用的数据，不管展示方式是网页，还是客户端，还是APP，只要是这个东西是让人看到的，这就叫VO VO主要的存在形式就是js里面的对象（也可以简单理解成json） ","date":"2024-05-23","objectID":"/posts/31c8a8c/:3:0","tags":["后端开发","Java"],"title":"JavaPO,BO,VO,DTO,POJO,DAO概念","uri":"/posts/31c8a8c/"},{"categories":["Java"],"content":"VO和DTO的区别 ","date":"2024-05-23","objectID":"/posts/31c8a8c/:4:0","tags":["后端开发","Java"],"title":"JavaPO,BO,VO,DTO,POJO,DAO概念","uri":"/posts/31c8a8c/"},{"categories":["Java"],"content":"PO(bean,entity等命名) Persisitant Object 持久对象，数据库表中的记录在java对象中的显示状态 一个PO的数据结构对应着库中表的结构，表中的一条记录就是一个PO对象 通常PO里面除了get，set之外没有别的方法 对于PO来说，数量是相对固定的，一定不会超过数据库表的数量 等同于Entity，这俩概念是一致的 BO（Business Object）业务对象 BO就是PO的组合 简单的例子比如说PO是一条交易记录，BO是一个人全部的交易记录集合对象 复杂点儿的例子PO1是交易记录，PO2是登录记录，PO3是商品浏览记录，PO4是添加购物车记录，PO5是搜索记录，BO是个人网站行为对象 BO是一个业务对象，一类业务就会对应一个BO，数量上没有限制，而且BO会有很多业务操作，也就是说除了get，set方法以外，BO会有很多针对自身数据进行计算的方法 为什么BO也画成横跨两层呢？原因是现在很多持久层框架自身就提供了数据组合的功能，因此BO有可能是在业务层由业务来拼装PO而成，也有可能是在数据库访问层由框架直接生成 很多情况下为了追求查询的效率，框架跳过PO直接生成BO的情况非常普遍，PO只是用来增删改使用 ","date":"2024-05-23","objectID":"/posts/31c8a8c/:5:0","tags":["后端开发","Java"],"title":"JavaPO,BO,VO,DTO,POJO,DAO概念","uri":"/posts/31c8a8c/"},{"categories":["Java"],"content":"BO和DTO的区别 这两个的区别主要是就是字段的删减 BO对内，为了进行业务计算需要辅助数据，或者是一个业务有多个对外的接口，BO可能会含有很多接口对外所不需要的数据，因此DTO需要在BO的基础上，只要自己需要的数据，然后对外提供 在这个关系上，通常不会有数据内容的变化，内容变化要么在BO内部业务计算的时候完成，要么在解释VO的时候完成 ","date":"2024-05-23","objectID":"/posts/31c8a8c/:6:0","tags":["后端开发","Java"],"title":"JavaPO,BO,VO,DTO,POJO,DAO概念","uri":"/posts/31c8a8c/"},{"categories":["Java"],"content":"DAO(Data Access Object) 数据访问对象 DAO(Data Access Object) 是数据访问对象的简称,是JavaWeb应用中用于封装对数据源的访问的组件。 DAO主要具有以下特征: 封装了对数据源(通常是关系型数据库)的访问,屏蔽了数据源的访问细节。 定义了操作数据所需要的接口方法,例如 CRUD(创建、读取、更新、删除)接口。 与具体的数据源解耦,如果需要改变底层的数据源,只需要改变DAO层的实现,不影响调用它的Service层。 通常与POJO和Model对象交互,将Model对象持久化到数据库,或者从数据库读取数据到Model对象。 不同的DAO负责不同的数据模型对象,DAO可以分为UserDAO、ProductDAO等。 DAO被Service层调用,Service层依赖DAO执行数据访问和持久化操作。 所以DAO层主要作用是为高层应用屏蔽数据库的访问细节,提供简单的CRUD接口来操作POJO对象,实现业务逻辑和数据访问的分离。它是表现层和持久层之间的桥梁和中介。 ","date":"2024-05-23","objectID":"/posts/31c8a8c/:7:0","tags":["后端开发","Java"],"title":"JavaPO,BO,VO,DTO,POJO,DAO概念","uri":"/posts/31c8a8c/"},{"categories":["网络编程"],"content":"Socket Socket有两种编程方式 tcp编程 udp编程 Java Socket建立连接 Server.java import java.io.IOException; import java.net.ServerSocket; import java.net.Socket; public class Server { public static void main(String[] args) { try { ServerSocket server = new ServerSocket(8080); // 8080 is the port number System.out.println(\"Server is running... waiting for client to connect\"); Socket socket = server.accept();// wait for client to connect System.out.println(\"Client connected\" + socket.getInetAddress().getHostAddress());// get the ip address of the client server.close(); } catch (IOException e) { e.printStackTrace(); } } } Cilent.java import java.io.IOException; import java.net.InetSocketAddress; import java.net.Socket; public class Cilent { public static void main(String[] args) { try(Socket socket = new Socket()) { socket.connect(new InetSocketAddress(\"localhost\", 8080)); System.out.println(\"Connected to server\"); }catch (IOException e) { e.printStackTrace(); // } } } 通过Socket进行数据传输 SocketServer.java package com.meowrain.tcpserver; import java.io.IOException; import java.io.InputStream; import java.net.ServerSocket; import java.net.Socket; public class SocketTCP01Server { public static void main(String[] args) throws IOException { ServerSocket server = new ServerSocket(8080); System.out.println(\"Server is running... waiting for client to connect\"); Socket socket = server.accept(); System.out.println(\"Connet successfully\"); InputStream inputStream = socket.getInputStream(); byte[] bytes = new byte[1024]; int readLen = 0; while ((readLen = inputStream.read(bytes)) != -1) { System.out.println(new String(bytes, 0, readLen)); } server.close(); } } SocketCilent.java package com.meowrain.tcpserver; import java.io.IOException; import java.io.OutputStream; import java.net.InetAddress; import java.net.Socket; public class SocketTCP01Cilent { public static void main(String[] args) throws IOException { Socket socket = new Socket(InetAddress.getLocalHost(), 8080); OutputStream outputStream = socket.getOutputStream(); outputStream.write(\"Hello, I am client\".getBytes()); socket.close(); System.out.println(\"Connet over\"); } } ","date":"2024-05-23","objectID":"/posts/45570b6/:0:0","tags":["Java网络编程"],"title":"Java网络编程 Socket套接字","uri":"/posts/45570b6/"},{"categories":["网络编程"],"content":"TCP网络通信编程-文件传输 package org.example.socket; import java.io.*; import java.net.ServerSocket; import java.net.Socket; public class TcpServerCopy { public static void main(String[] args) throws IOException { ServerSocket serverSocket = new ServerSocket(8888); System.out.println(\"等待客户端连接...\"); Socket socket = serverSocket.accept(); System.out.println(\"客户端连接成功\"); /* 读入文件 */ File file = new File(\"src/org/example/111658775_p0.png\"); FileInputStream fileInputStream = new FileInputStream(file); BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream); /*输出流，向客户端发送文件*/ OutputStream outputStream = socket.getOutputStream(); byte[] buf = new byte[1024]; int bytesRead; while((bytesRead = bufferedInputStream.read(buf))!=-1){ outputStream.write(buf,0,bytesRead); } socket.shutdownOutput(); System.out.println(\"文件发送完成\"); bufferedInputStream.close(); outputStream.close(); socket.close(); serverSocket.close(); } } package org.example.socket; import java.io.*; import java.net.InetAddress; import java.net.Socket; import java.net.UnknownHostException; public class TcpClientCopy { public static void main(String[] args) throws IOException { Socket socket = new Socket(InetAddress.getLocalHost(),8888); System.out.println(\"服务器连接成功\"); //接受文件内容 InputStream inputStream = socket.getInputStream(); File file = new File(\"src/client/client.png\"); FileOutputStream fileOutputStream = new FileOutputStream(file); BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(fileOutputStream); byte[] buf = new byte[1024]; int bytesRead; while((bytesRead = inputStream.read(buf))!=-1){ bufferedOutputStream.write(buf,0,bytesRead); } System.out.println(\"文件接受成功！\"); socket.shutdownInput(); /*关闭资源*/ inputStream.close(); bufferedOutputStream.close(); socket.close(); } } ","date":"2024-05-23","objectID":"/posts/d76e347/:0:0","tags":["Java","网络编程"],"title":"Java网络编程 TCP网络通信编程文件传输","uri":"/posts/d76e347/"},{"categories":["网络编程"],"content":"TCP字符流编程 代码 package org.example.socket; import java.io.*; import java.net.ServerSocket; import java.net.Socket; public class SocketTcp03Server { public static void main(String[] args) throws IOException { ServerSocket serverSocket = new ServerSocket(9999); Socket socket = serverSocket.accept(); System.out.println(\"服务端启动，正在监听9999端口\"); InputStream inputStream = socket.getInputStream(); InputStreamReader reader = new InputStreamReader(inputStream); BufferedReader bufferedReader = new BufferedReader(reader); String s = bufferedReader.readLine(); System.out.println(s); socket.shutdownInput(); OutputStream outputStream = socket.getOutputStream(); OutputStreamWriter writer = new OutputStreamWriter(outputStream); BufferedWriter bufferedWriter = new BufferedWriter(writer); bufferedWriter.write(\"hello,client字符流\"); bufferedWriter.newLine(); bufferedWriter.flush(); socket.shutdownOutput(); //关闭外层流即可 bufferedReader.close(); bufferedWriter.close(); serverSocket.close(); socket.close(); } } package org.example.socket; import java.io.*; import java.net.InetAddress; import java.net.Socket; public class SocketTcp03Client { public static void main(String[] args) throws IOException { Socket socket = new Socket(InetAddress.getLocalHost(),9999); System.out.println(\"客户端启动，准备向9999端口发送信息\"); OutputStream outputStream = socket.getOutputStream(); OutputStreamWriter writer = new OutputStreamWriter(outputStream); BufferedWriter bufferedWriter = new BufferedWriter(writer); bufferedWriter.write(\"hello,server字符流\"); bufferedWriter.newLine(); //写用newLIne方法，read也要用readLine方法 bufferedWriter.flush(); //需要刷新 socket.shutdownOutput(); InputStream inputStream = socket.getInputStream(); InputStreamReader reader = new InputStreamReader(inputStream); BufferedReader bufferedReader = new BufferedReader(reader); String s = bufferedReader.readLine(); System.out.println(s); socket.close(); bufferedWriter.close(); bufferedReader.close(); } } ","date":"2024-05-23","objectID":"/posts/4893d97/:0:0","tags":["Java","网络编程"],"title":"Java网络编程 TCP网络通信编程字符流","uri":"/posts/4893d97/"},{"categories":["网络编程"],"content":"TCP网络通信编程1 SockeTcp01Client.java package org.example.socket; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.InetAddress; import java.net.Socket; public class SocketTcp01Client { public static void main(String[] args) throws IOException { Socket socket = new Socket(InetAddress.getLocalHost(),9999); System.out.println(\"客户端socket返回\" + socket.getClass()); OutputStream outputStream = socket.getOutputStream(); byte[] content = \"HelloServer,This is a message come from Client\".getBytes(); outputStream.write(content); outputStream.close(); socket.close(); } } TCP网络通信编程2 SocketTcp02Server.java package org.example.socket; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.ServerSocket; import java.net.Socket; public class SocketTcp02Server { public static void main(String[] args) throws IOException { ServerSocket serverSocket = new ServerSocket(9999); Socket socket = serverSocket.accept(); System.out.println(\"Server端运行，监听9999端口\"); // 输出 OutputStream outputStream = socket.getOutputStream(); outputStream.write(\"hello,client\".getBytes()); socket.shutdownOutput();//OutputStream结束标记 //输入 InputStream inputStream = socket.getInputStream(); byte[] buf = new byte[1024]; int readLen = 0; while ((readLen = inputStream.read(buf))!=-1){ System.out.print(new String(buf,0,readLen)); } socket.shutdownInput();//InputStream结束标记 outputStream.close(); inputStream.close(); socket.close(); serverSocket.close(); } } SocketTcp02Client.java package org.example.socket; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.InetAddress; import java.net.Socket; public class SocketTcp02Client { public static void main(String[] args) throws IOException { Socket socket = new Socket(InetAddress.getLocalHost(),9999); // 输出 OutputStream outputStream = socket.getOutputStream(); outputStream.write(\"hello,server\".getBytes()); socket.shutdownOutput(); //OutputStream结束标记 // 输入 InputStream inputStream = socket.getInputStream(); byte[] buf = new byte[1024]; int readLen = 0; while((readLen = inputStream.read(buf))!=-1){ System.out.println(new String(buf,0,readLen)); } socket.shutdownInput();//InputStream结束标记 //关闭流 outputStream.close(); inputStream.close(); socket.close(); } } ","date":"2024-05-23","objectID":"/posts/7078f80/:0:0","tags":["Java","网络编程"],"title":"Java网络编程 TCP网络通信编程字节流","uri":"/posts/7078f80/"},{"categories":["单片机"],"content":"Pin引脚类的应用 from machine import Pin # 创建一个输出引脚在0引脚 p0 = Pin(0,Pin.OUT) # 给P0引脚线输出低电平，再输出高电平 p0.value(0) p0.value(1) # 给P0引脚线输出低电平，再输出高电平 p0.on() p0.off() # 给P0引脚先输出低电平，再输出高电平 p0.low() p0.high() #再P2创建一个输入引脚，并设置上拉电阻 p2 = Pin(2,Pin.IN,Pin.PULL_UP) # 打印P2的值 print(p2.value()) ","date":"2024-05-23","objectID":"/posts/4a6a66b/:0:0","tags":["嵌入式","micropython","单片机"],"title":"Micropython——ESP32使用","uri":"/posts/4a6a66b/"},{"categories":["单片机"],"content":"软件设计1-点亮一个LED from machine import Pin # 构建 pin_12 引脚对象，GPIO12输出 pin_12 = Pin(12,Pin.OUT) #使Pin12输出高电平 pin_12.high() ","date":"2024-05-23","objectID":"/posts/4a6a66b/:1:0","tags":["嵌入式","micropython","单片机"],"title":"Micropython——ESP32使用","uri":"/posts/4a6a66b/"},{"categories":["单片机"],"content":"软件设计2-闪烁的LED from machine import Pin # 导入time模块 import time # 构建pin12引脚对象，GPIO12输出 pin_12 = Pin(12,Pin.OUT) while True: pin_12.high() time.sleep(1) #延时1秒 pin_12.low() ","date":"2024-05-23","objectID":"/posts/4a6a66b/:2:0","tags":["嵌入式","micropython","单片机"],"title":"Micropython——ESP32使用","uri":"/posts/4a6a66b/"},{"categories":["单片机"],"content":"软件设计3-流水灯 import time from machine import Pin # 定义GPIO引脚对象 pin_index_list = [13,12,14,27,26] # 定义led对象列表 led_pin_list = [] # 添加LED引脚对象 for i in pin_index_list: led_pin_list.append(Pin(i,Pin.Out)) # 初始化引脚对象 for led_pin in led_pin_list: led_pin.low() #初始化为关灯状态 while True: #逐个点亮LED for led_pin in led_pin_list: led_pin.high() time.sleep(0.5) #延时0.5s # 逐个熄灭LED for led_pin in led_pin_list: led_pin.low() time.sleep(0.5) #延时0.5 ","date":"2024-05-23","objectID":"/posts/4a6a66b/:3:0","tags":["嵌入式","micropython","单片机"],"title":"Micropython——ESP32使用","uri":"/posts/4a6a66b/"},{"categories":["单片机"],"content":"软件设计3-数码管显示 按键消抖 import time from machine import Pin # 定义按键输入引脚 pin_button = Pin(14,Pin.IN,Pin.PULL_DOWN) ## 这里按钮接的是电源正极，按下按钮会传递一个高电平，所以我们要使用下拉电阻 # 定义LED输出引脚 pin_led = Pin(2,Pin.OUT) # 记录LED是否修改过的状态 status = 0 while True: if pin_button.value() == 1: # 按键消抖 time.sleep_ms(80) # 延时结束后，继续判断状态 if pin_button.value() == 1 and status == 0: status = 1 pin_led.value(not pin_led.value()) elif pin_button.value() == 0 status = 0 PWM ","date":"2024-05-23","objectID":"/posts/4a6a66b/:4:0","tags":["嵌入式","micropython","单片机"],"title":"Micropython——ESP32使用","uri":"/posts/4a6a66b/"},{"categories":["单片机"],"content":"PWM 呼吸灯 from machine import Pin,PWM #创建PWM对象 led = PWM(Pin(12),freq=20000,duty=512) led.freq() #获取当前频率 led.freq(1000) #设置频率 led.duty() #获取当前占空比 led.duty(200) # 设置占空比 led.duty_u16(12345) # 使用 duty_u16方法 led.duty_ns() #使用duty_ns 方法 led.deinit() #关闭引脚的PWM 呼吸灯代码： import time from machine import Pin,PWM # 定义PWM对象 led = PWM(Pin(12,Pin.OUT),freq=1000) while True: # 由暗到亮 for i in range(1024): led.duty(i) time.sleep_ms(1) # 由亮到灭 for i in range(1023,0,-1): led.duty(i) time.sleep_ms(1) ","date":"2024-05-23","objectID":"/posts/4a6a66b/:5:0","tags":["嵌入式","micropython","单片机"],"title":"Micropython——ESP32使用","uri":"/posts/4a6a66b/"},{"categories":["单片机"],"content":"PWM 控制舵机 下面是舵机的驱动原理 注意：舵机单独供电，要和单片机共地 import time from machine import Pin,PWM # 定义PWM控制对象 my_servo = PWM(Pin(13)) #定义舵机频率 my_servo.freq(50) # 使用不通的占空比方法控制转动角度 # duty(),0-1023 # 转动到0° 1023*0.5/20 my_servo.duty(1023*0.5/20); # duty_u16() 0-65535 # 转动到90° 65535*1.5/20 # myservo.duty(65535*1.5/20) ","date":"2024-05-23","objectID":"/posts/4a6a66b/:6:0","tags":["嵌入式","micropython","单片机"],"title":"Micropython——ESP32使用","uri":"/posts/4a6a66b/"},{"categories":["面向对象"],"content":"面向对象设计原则(部分) https://zhuanlan.zhihu.com/p/60791596 共同重用原则：一个包中里的所有类应该是共同重用的，如果重用了包里的一个类，那么就要重用包中的所有类。 共同封闭原则： 如果一个变化对一个包产生影响，则将对该包里的所有类产生影响，而对其它包不产生任何影响。 开放-封闭原则：对扩展开放，对修改关闭。 接口分离原则： 接口的功能尽可能单一，降低模块的耦合性。 面向对象测试的四个层次 算法层 –\u003e 单元测试 类层 –\u003e 模块测试 模板层 –\u003e 主题层 系统层 –\u003e 把各个子系统组装成完整的面向对象软件系统，在组装过程进行测试 设计模式 面向对象类关系(继承、实现、依赖、关联、聚合、组合)：https://www.cnblogs.com/zhongj/p/11169780.html UML: https://blog.csdn.net/quyingzhe0217/article/details/133683814 ","date":"2024-05-19","objectID":"/posts/831975a/:0:0","tags":["软考"],"title":"软考-笔记","uri":"/posts/831975a/"},{"categories":["面向对象"],"content":"创建型模式 创建型设计模式包括以下几种常见的模式： 工厂模式（Factory Pattern）：通过工厂方法或抽象工厂来创建对象，将对象的创建过程封装起来，使得客户端代码与具体类解耦。 抽象工厂模式（Abstract Factory Pattern）：提供一个接口，用于创建相关或依赖对象的家族，而不需要指定具体类。 单例模式（Singleton Pattern）：确保一个类只有一个实例，并提供一个全局访问点来访问该实例。 建造者模式（Builder Pattern）：将一个复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。 原型模式（Prototype Pattern）：通过复制现有对象来创建新对象，而不是通过实例化来创建。 ","date":"2024-05-19","objectID":"/posts/831975a/:1:0","tags":["软考"],"title":"软考-笔记","uri":"/posts/831975a/"},{"categories":["面向对象"],"content":"结构型模式 结构型设计模式主要包括以下几种常见的模式： 适配器模式（Adapter Pattern）：将一个类的接口转换成客户端所期望的另一个接口，使得原本不兼容的类可以一起工作。 桥接模式（Bridge Pattern）：将抽象部分与实现部分分离，使它们可以独立地变化，从而提高系统的灵活性。 组合模式（Composite Pattern）：将对象组合成树形结构，以表示“部分-整体”的层次结构，使得客户端可以统一地处理单个对象和组合对象。 装饰器模式（Decorator Pattern）：动态地给对象添加额外的职责，同时又不改变其接口。 外观模式（Facade Pattern）：提供一个统一的接口，用于访问子系统中的一组接口，从而简化客户端与子系统之间的交互。 享元模式（Flyweight Pattern）：通过共享细粒度的对象，以减少内存使用和提高性能。 代理模式（Proxy Pattern）：为其他对象提供一个代理，以控制对这个对象的访问。 ","date":"2024-05-19","objectID":"/posts/831975a/:2:0","tags":["软考"],"title":"软考-笔记","uri":"/posts/831975a/"},{"categories":["面向对象"],"content":"行为模式 行为型设计模式主要包括以下几种常见的模式： 观察者模式（Observer Pattern）：定义了一种一对多的依赖关系，使得多个观察者对象可以同时监听并收到被观察者对象的通知。 策略模式（Strategy Pattern）：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，从而使算法的变化独立于使用算法的客户端。 命令模式（Command Pattern）：将请求封装成对象，以使得可以用不同的请求对客户端进行参数化，同时支持请求的排队、记录和撤销。 迭代器模式（Iterator Pattern）：提供一种顺序访问聚合对象中各个元素的方法，而又不暴露该对象的内部表示。 状态模式（State Pattern）：允许对象在内部状态发生改变时改变其行为，使对象看起来像是修改了其类。 责任链模式（Chain of Responsibility Pattern）：将请求的发送者和接收者解耦，使多个对象都有机会处理请求，从而避免请求的发送者与接收者之间的耦合关系。 访问者模式（Visitor Pattern）：在不改变被访问类的前提下，定义了一种新的访问操作，使得可以在不修改被访问类的情况下对其进行操作。 中介者模式（Mediator Pattern）：定义了一个中介对象，封装了一组对象之间的交互方式，使其能够独立地改变交互方式。 备忘录模式（Memento Pattern）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可以在以后恢复到这个状态。 解释器模式（Interpreter Pattern）：给定一个语言，定义它的文法的一种表示，并定义一个解释器，用于解释语言中的句子。 二分查找关键字序列判断 第一个关键字一定是序列的中间元素 第一个关键字以后的数字要么都大于第一个关键字，要么都小于第一个关键字 第二个关键字以后的关键字，要么都位于第一个关键字和第二个关键字之间，要么都在第二个关键字之外 第三个关键字以后的关键字，要么都位于第二个关键字和第三个关键字之间，要么都在第三个关键字之外 计组 DRAM使用电容存储信息，而且需要周期性地进行刷新。 编译原理 对高级语言源程序进行编译或者解释过程中需要进行语法分析，递归子程序分析属于自上而下的分析法 模块设计 高内聚低耦合是模块设计的基本原则。 模块之间的耦合性由低到高依次为: 非直接耦合：两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。耦合度最弱，模块独立性最强。 数据耦合：调用模块和被调用模块之间只传递简单的数据项参数。相当于高级语言中的值传递。 标记耦合：调用模块和被调用模块之间传递数据结构而不是简单数据，同时也称作特征耦合。 控制耦合：模块之间传递的不是数据信息，而是控制信息例如标志、开关量等，一个模块控制了另一个模块的功能。从控制耦合开始，模块的数据就放在自己内部了，不同模块之间通过接口互相调用。 外部耦合：一组模块都访问同一全局简单变量，而且不通过参数表传递该全局变量的信息，则称之为外部耦合。外部耦合和公共耦合很像，区别就是一个是简单变量，一个是复杂数据结构。 公共耦合： 多个模块都访问同一个公共数据环境，公共的数据环境可以是全局数据结构、共享的通信区，内存的公共覆盖区等 内容耦合：内容耦合是最紧的耦合程度，一个模块直接访问另一模块的内容，则称这两个模块为内容耦合。 1）功能内聚（Functional Cohesion） 如果一个模块内所有处理元素完成一个，而且仅完成一个功能，则称为功能内聚。 功能内聚是最高程度的内聚。但在软件结构中，并不是每个模块都能设计成一个功能内聚模块。 2）顺序内聚（Sequential Cohesion） 如果一个模块内处理元素和同一个功能密切相关，而且这些处理元素必须顺序执行，则称为顺序内聚。 3）通信内聚（Communicational Cohesion） 如果一个模块中所有处理元素都使用同一个输入数据和（或）产生同一个输出数据，称为通信内聚。 4）过程内聚（Procedural Cohesion） 如果一个模块内的处理元素是相关的，而且必须以特定的次序执行，称为过程内聚。 过程内聚与顺序内聚的区别是： 顺序内聚中是数据流从一个处理单元流到另一个处理单元，而过程内聚是控制流从一个动作流向另一个动作。 5）时间内聚（Temporal Cohesion） 如果一个模块包含的任务必须在同一段时间内执行，称为时间内聚。也称为瞬时内聚。 6）逻辑内聚（Logical Cohesion） 如果模块完成的任务在逻辑上属于相同或相似的一类，称为逻辑内聚。 7）偶然内聚（Coincidental Cohesion） 如果一个模块由完成若干毫无关系的功能处理元素偶然组合在一起的，就叫偶然内聚 数据流图 分层的数据流图是结构化分析方法的重要组成部分。 对数据流图中的每个基本加工，需要加工规格说明书。 加工规格说明书描述把输入数据流变换为输出数据流的加工规则。但是不需要描述实现加工的具体流程。 可以使用结构化语言，判定表和判定树来表达基本加工。 软件许可 独占许可： 软件著作权人不得将软件使用权授权第三方，软件著作权人不能使用该软件。 独家许可：软件著作权人不得将软件使用权授权第三方，软件著作权人可以使用该软件 普通许可：软件著作权人可以将软件使用权授权第三方，软件著作权人自己也可以使用该软件 模块控制范围 模块的控制范围包括模块本身及其所有的从属模块。模块的作用范围是指受该模块内任意一个判定影响的所有模块的集合，这其中可能由处于控制范围之外的模块。 原则上，一个模块的作用范围应该在其控制范围内，如果没有，可以采用下面的方法： 将判定所在模块合并父模块中，使得该判定处于较高层次 将受判定影响的模块下移到该模块的控制范围内 将判定上移到层次中较高的位置。 风险控制 风险控制的基本方法： 回避 转移 减轻 接受并控制 UML建模 ","date":"2024-05-19","objectID":"/posts/831975a/:3:0","tags":["软考"],"title":"软考-笔记","uri":"/posts/831975a/"},{"categories":["面向对象"],"content":"事物 结构事物: 通常是模型中的静态部分，描述概念或者物理元素。结构事物包括类，接口，协作，用例，主动类，构件和节点 行为事物： 是UML中的动态部分，是模型中的动词，描述了跨越时间和空间的行为。共有两类主要的行为事物: 交互和状态机 分组事物： 是UML建模中的组织部分。在所有分组事物中，最主要的是包 注释事物：是UML中的解释部分，这些注释事物用来描述，说明和标注模型的任何元素。注解是一个注释事物。注解是一个依附于元素或者一组元素之上，对它进行约束或者解释的简单符号。 ","date":"2024-05-19","objectID":"/posts/831975a/:4:0","tags":["软考"],"title":"软考-笔记","uri":"/posts/831975a/"},{"categories":["面向对象"],"content":"关系 依赖，关联，泛化和实现 依赖：两个事物之间的语义关系，其中一个事物发生变化会影响另一个事物的语义 关联：是一种结构关系。描述了一组链，链是对象之间的连接。聚合是一种特殊类型的关联，描述了整体和部分间的结构关系。组合也是一种特殊类型的关联，同样体现了整体与部分之间的关系，但比聚合更强，因此也被称为强聚合。 泛化：是一种特殊/一般关系，特殊元素(子元素)的对象可替代一般元素(父元素)的对象。用这种方法，子元素共享了父元素的结构和行为。 实现：是 类元之间的语义关系，其中一个类元制定了由另一个类元保证执行的契约。在两种地方要遇到实现关系：一种是在接口和实现他们的类或者构件之间，另一种是在用例和实现它们的协作之间。 ","date":"2024-05-19","objectID":"/posts/831975a/:5:0","tags":["软考"],"title":"软考-笔记","uri":"/posts/831975a/"},{"categories":["面向对象"],"content":"视图 https://blog.csdn.net/TangZhongxin/article/details/4640248 注意用例图方向，\u003c\u003cinclude\u003e\u003e是包含了，\u003c\u003cextend\u003e\u003e是扩展于 ","date":"2024-05-19","objectID":"/posts/831975a/:6:0","tags":["软考"],"title":"软考-笔记","uri":"/posts/831975a/"},{"categories":["Go"],"content":"Go 网络编程 ","date":"2024-05-18","objectID":"/posts/fb7e90b/:0:0","tags":["Go","网络编程"],"title":"Go网络编程","uri":"/posts/fb7e90b/"},{"categories":["Go"],"content":"IP “net\"包定义了许多类型, 函数，方法用于 Go 网络编程。IPIPIPIP 类型被定义为一个字节数组。–\u003e type IP []byte 有几个函数来处理一个 IP 类型的变量, 但是在实践中你很可能只用到其中的一些。例如, ParseIP(String)函数将获取逗号分隔的 IPv4 或者冒号分隔的 IPv6 地址, 而 IP 类型的String()方法将返回一个字符串。 package main import ( \"fmt\" \"net\" \"os\" ) func main() { if len(os.Args) != 2 { fmt.Fprintf(os.Stderr, \"Usage: %s ipaddr\\n\", os.Args[0]) os.Exit(1) } ipAddress := os.Args[1] ip := net.ParseIP(ipAddress) if ip != nil { fmt.Println(ip) } else { fmt.Fprintf(os.Stderr, \"Error ip Address\") } } 上面的 fmt.Println 的时候，会自动调用 net.IP 的 String 方法 结果如下： ","date":"2024-05-18","objectID":"/posts/fb7e90b/:1:0","tags":["Go","网络编程"],"title":"Go网络编程","uri":"/posts/fb7e90b/"},{"categories":["Go"],"content":"IP 掩码 // An IPMask is a bitmask that can be used to manipulate // IP addresses for IP addressing and routing. // // See type [IPNet] and func [ParseCIDR] for details. type IPMask []byte package main import ( \"fmt\" \"net\" \"os\" ) func main() { if len(os.Args) != 2 { fmt.Fprintf(os.Stderr, \"Usage: %s ipaddr\\n\", os.Args[0]) os.Exit(1) } ipAddress := os.Args[1] ip := net.ParseIP(ipAddress) if ip != nil { if ip.To4() != nil { // IPv4 address defaultMask := ip.DefaultMask() res := ip.Mask(defaultMask) //通过ip.Mask方法获取这个网络的起始网络号 mask := net.IP(defaultMask).String() //将获取到的十六进制子网掩码转换为十进制的ipv4 ones, bits := defaultMask.Size() //ones：子网掩码中前导1的数量。 //bits：子网掩码的总位数。 // ip.DefaultMask()获取这个ip的子网掩码 fmt.Println(\"网络起始为:\", res) fmt.Println(\"mask:\", mask) fmt.Printf(\"网络号长度:%d,总位数:%d\", ones, bits) } else { // IPv6 address fmt.Println(\"IPv6 address does not have a mask like IPv4.\") } } else { fmt.Fprintf(os.Stderr, \"Error: Invalid IP Address\\n\") } } ","date":"2024-05-18","objectID":"/posts/fb7e90b/:2:0","tags":["Go","网络编程"],"title":"Go网络编程","uri":"/posts/fb7e90b/"},{"categories":["Go"],"content":"IPAddr // IPAddr represents the address of an IP end point. type IPAddr struct { IP IP Zone string // IPv6 scoped addressing zone } 使用ResolveIPAddr解析地址 package main import ( \"fmt\" \"net\" \"os\" ) func main() { if len(os.Args) \u003c 2 { fmt.Fprintf(os.Stderr, \"Usage: %s ip-address\\n\", os.Args[0]) os.Exit(1) } name := os.Args[1] res, err := net.ResolveIPAddr(\"ip4\", name) if err != nil { fmt.Fprintf(os.Stderr, \"error:%v\", err) } fmt.Printf(\"resolve domain name:%s,ip: %s\\n\", name, res) fmt.Println(\"mask:\", net.IP(res.IP.DefaultMask())) } 使用 LookupHost()查找域名的所有 ip（有 cdn） package main import ( \"fmt\" \"net\" \"os\" ) func main() { if len(os.Args) \u003c 2 { fmt.Fprintf(os.Stderr, \"Usage: %s ip-address\\n\", os.Args[0]) os.Exit(1) } name := os.Args[1] res, err := net.LookupHost(name) if err != nil { fmt.Println(\"error\", err) } fmt.Printf(\"resolve domain name:%s,ip: %s\\n\", name, res) } ","date":"2024-05-18","objectID":"/posts/fb7e90b/:3:0","tags":["Go","网络编程"],"title":"Go网络编程","uri":"/posts/fb7e90b/"},{"categories":["Go"],"content":"Port package main import ( \"fmt\" \"net\" \"os\" ) func main() { if len(os.Args) \u003c 3 { fmt.Fprintf(os.Stderr, \"Usage: %s network-type service \", os.Args[0]) os.Exit(1) } networkType := os.Args[1] service := os.Args[2] port, err := net.LookupPort(networkType, service) if err != nil { fmt.Fprintf(os.Stderr, err.Error()) os.Exit(1) } fmt.Println(\"Service port:\", port) os.Exit(0) } ","date":"2024-05-18","objectID":"/posts/fb7e90b/:4:0","tags":["Go","网络编程"],"title":"Go网络编程","uri":"/posts/fb7e90b/"},{"categories":["Go"],"content":"TCPAddr // TCPAddr represents the address of a TCP end point. type TCPAddr struct { IP IP Port int Zone string // IPv6 scoped addressing zone } package main import ( \"fmt\" \"net\" ) func main() { addr2, err := net.ResolveTCPAddr(\"tcp\", \"baidu.com:443\") if err != nil { fmt.Println(err) } fmt.Printf(\"addr domain:%s,port:%d\", addr2.IP, addr2.Port) // fmt.Println(addr) } ","date":"2024-05-18","objectID":"/posts/fb7e90b/:5:0","tags":["Go","网络编程"],"title":"Go网络编程","uri":"/posts/fb7e90b/"},{"categories":["Go"],"content":"编写一个 TCP 客户端 package main import ( \"fmt\" \"io\" \"net\" \"os\" ) func main() { if len(os.Args) \u003c 2 { fmt.Fprintf(os.Stderr, \"Usage: %s host:port\", os.Args[0]) os.Exit(1) } service := os.Args[1] tcpAddr, err := net.ResolveTCPAddr(\"tcp4\", service) if err != nil { fmt.Fprintf(os.Stderr, \"resolve input failed %v\", err) os.Exit(1) } conn, err := net.DialTCP(\"tcp\", nil, tcpAddr) if err != nil { fmt.Fprintf(os.Stderr, \"connection failed: %v\", err) os.Exit(1) } defer conn.Close() _, err = conn.Write([]byte(\"HEAD / HTTP/1.0\\r\\n\\r\\n\")) if err != nil { fmt.Fprintf(os.Stderr, \"Write failed:%v\", err) os.Exit(1) } result, err := io.ReadAll(conn) if err != nil { fmt.Fprintf(os.Stderr, \"Read from connection failed:%v\", err) os.Exit(1) } fmt.Println(string(result)) os.Exit(0) } ","date":"2024-05-18","objectID":"/posts/fb7e90b/:6:0","tags":["Go","网络编程"],"title":"Go网络编程","uri":"/posts/fb7e90b/"},{"categories":["Go"],"content":"编写时间服务器 package main import ( \"fmt\" \"net\" \"os\" \"time\" ) func main() { service := \":1200\" tcpAddr, err := net.ResolveTCPAddr(\"tcp4\", service) if err != nil { fmt.Fprintf(os.Stderr, \"resolve tcp addr failed:%v\", err) os.Exit(1) } listen, err := net.ListenTCP(\"tcp4\", tcpAddr) if err != nil { fmt.Fprintf(os.Stderr, \"listen to port failed:%v\", err) os.Exit(1) } else { fmt.Println(\"time server listening in localhost:1200\") } for { conn, err := listen.Accept() if err != nil { continue } daytime := time.Now().String() conn.Write([]byte(daytime)) fmt.Println(\"Write to client info:%s\", daytime) conn.Close() } } 编写对应客户端:` package main import ( \"fmt\" \"io\" \"net\" \"os\" ) func main() { if len(os.Args) != 2 { fmt.Fprintf(os.Stderr, \"Usage: %s host:port\\n\", os.Args[0]) os.Exit(1) } service := os.Args[1] tcpAddr, err := net.ResolveTCPAddr(\"tcp4\", service) if err != nil { fmt.Fprintf(os.Stderr, \"ResolveTCPAddr failed: %v\\n\", err) os.Exit(1) } conn, err := net.DialTCP(\"tcp\", nil, tcpAddr) if err != nil { fmt.Fprintf(os.Stderr, \"DialTCP failed: %v\\n\", err) os.Exit(1) } defer conn.Close() res, err := io.ReadAll(conn) if err != nil { fmt.Fprintf(os.Stderr, \"Read from connection failed:%v\", err) os.Exit(1) } fmt.Println(string(res)) } ","date":"2024-05-18","objectID":"/posts/fb7e90b/:7:0","tags":["Go","网络编程"],"title":"Go网络编程","uri":"/posts/fb7e90b/"},{"categories":["Go"],"content":"多线程服务器 在这个示例中，我们完成一个接受客户端信息，然后再把客户端信息返回给客户端的服务器,而且它允许客户端进行连接 package main import ( \"fmt\" \"io\" \"net\" \"os\" ) func main() { service := \":1202\" tcpAddr, err := net.ResolveTCPAddr(\"tcp4\", service) if err != nil { fmt.Fprintf(os.Stderr, \"Resolve Tcp addr failed: %s\", err) os.Exit(1) } listen, err := net.ListenTCP(\"tcp4\", tcpAddr) if err != nil { fmt.Fprintf(os.Stderr, \"listen to tcp failed: %s\", err) os.Exit(1) } for { conn, err := listen.Accept() if err != nil { fmt.Fprintf(os.Stderr, \"accept error:%s\", err) continue } go handleClient(conn) } } func handleClient(conn net.Conn) { defer conn.Close() var buf [512]byte for { n, err := conn.Read(buf[0:]) if err != nil { if err == io.EOF { // Connection was closed by the client fmt.Println(\"Client disconnected\") } else { fmt.Fprintf(os.Stderr, \"Read from connection failed: %s\", err) } return } fmt.Println(\"Read from the client\", string(buf[0:n])) _, err = conn.Write(buf[0:n]) fmt.Println(\"Send the same message to client\") if err != nil { fmt.Fprintf(os.Stderr, \"Write to connection failed: %s\", err) return } } } ","date":"2024-05-18","objectID":"/posts/fb7e90b/:8:0","tags":["Go","网络编程"],"title":"Go网络编程","uri":"/posts/fb7e90b/"},{"categories":["Go"],"content":"超时服务器 package main import ( \"fmt\" \"io\" \"net\" \"os\" \"time\" ) func main() { service := \":1203\" tcpAddr, err := net.ResolveTCPAddr(\"tcp4\", service) if err != nil { fmt.Fprintf(os.Stderr, \"Resolve Tcp addr failed: %s\", err) os.Exit(1) } listen, err := net.ListenTCP(\"tcp4\", tcpAddr) if err != nil { fmt.Fprintf(os.Stderr, \"listen to tcp failed: %s\", err) os.Exit(1) } for { conn, err := listen.Accept() if err != nil { fmt.Fprintf(os.Stderr, \"Error accepting tcp connection: %s\", err) os.Exit(1) } tcpConn, ok := conn.(*net.TCPConn) if !ok { fmt.Println(\"Failed to cast to TCPConn\") return } // 设置读取超时 tcpConn.SetReadDeadline(time.Now().Add(5 * time.Second)) // 设置写入超时 tcpConn.SetWriteDeadline(time.Now().Add(5 * time.Second)) // 设置读取和写入的统一超时 tcpConn.SetDeadline(time.Now().Add(5 * time.Second)) go handleClient(tcpConn) } } func handleClient(conn net.Conn) { defer conn.Close() var buf [512]byte for { n, err := conn.Read(buf[0:]) if err != nil { if err == io.EOF { // Connection was closed by the client fmt.Println(\"Client disconnected\") } else { fmt.Fprintf(os.Stderr, \"Read from connection failed: %s\", err) } return } fmt.Println(\"Read from the client\", string(buf[0:n])) _, err = conn.Write(buf[0:n]) fmt.Println(\"Send the same message to client\") if err != nil { fmt.Fprintf(os.Stderr, \"Write to connection failed: %s\", err) return } } } ","date":"2024-05-18","objectID":"/posts/fb7e90b/:9:0","tags":["Go","网络编程"],"title":"Go网络编程","uri":"/posts/fb7e90b/"},{"categories":["Go"],"content":"客户端保持连接 package main import ( \"fmt\" \"net\" \"time\" ) func main() { serverAddr := \"localhost:1203\" // 连接到服务器 conn, err := net.Dial(\"tcp\", serverAddr) if err != nil { fmt.Println(\"Error connecting to server:\", err) return } defer conn.Close() fmt.Println(\"Connected to server\") // 关闭超时控制，保持连接打开 conn.(*net.TCPConn).SetKeepAlive(true) conn.SetDeadline(time.Time{}) // 保持连接，不做任何操作 select {} } ","date":"2024-05-18","objectID":"/posts/fb7e90b/:10:0","tags":["Go","网络编程"],"title":"Go网络编程","uri":"/posts/fb7e90b/"},{"categories":["数据库"],"content":"数据库六种范式 ","date":"2024-05-18","objectID":"/posts/2c94a50/:0:0","tags":["数据库"],"title":"数据库六种范式","uri":"/posts/2c94a50/"},{"categories":["数据库"],"content":"一些基本概念 一些基本概念： 实体： 实体通常指代数据模型中的一个对象，常常对应数据库中的表 属性： 属性是关系数据库中的一个重要概念，对应于数据表中的列，描述了实体的特征或者特性 元组： 在关系数据库中，元组指的是数据表中的一行，包含了一组属性值 分量： 分量是元组中的某个具体的属性值 候选码和主码： 候选码是可以唯一确定一个元组的属性，主码是从候选码中选出的用来唯一标识一个元组的码 全码： 包含了所有属性的码，确保了其唯一性 主属性： 如果一个属性在任何一个候选码中出现过，那么它就是主属性，用来唯一标识一个元组 非主属性： 非主属性与主属性相反，没有在任何候选码中出现过，不能唯一标识一个元组 外码： 外码是一个属性(或者属性组)，它不是本表的主码或者候选码，但是却可以关联到其他表的主码，用于建立表与表之间的关联。 ","date":"2024-05-18","objectID":"/posts/2c94a50/:1:0","tags":["数据库"],"title":"数据库六种范式","uri":"/posts/2c94a50/"},{"categories":["数据库"],"content":"关系模型的形式化定义 R(U,D,DOM,F) R: 符号化的元组语义 U: 一组属性 D: 属性组U中的属性所来自的域 DOM: 属性到域的映射 F: 属性组U上的一组数据依赖 由于D，DOM与设计关系不大，因此这里把关系模式看作一个三元组R\u003cU,F\u003e ","date":"2024-05-18","objectID":"/posts/2c94a50/:2:0","tags":["数据库"],"title":"数据库六种范式","uri":"/posts/2c94a50/"},{"categories":["数据库"],"content":"函数依赖 注： 因为电脑不太方便打出打杠的箭头，所以就用--\u003e表示了 非平凡函数依赖：关系R(Sno,Cno,Grade)，依赖关系(Sno,Cno)–\u003eGrade是非平凡函数依赖 平凡函数依赖：关系R(Sno, Cno)，依赖关系(Sno, Cno)→Sno，(Sno, Cno)→Cno都是平凡函数依赖 完全函数依赖：关系R(Sno,Cno,Grade)，依赖关系(Sno,Cno)-\u003eGrade，但是Sno--\u003eGrade且Cno--\u003eGrade，因此这个依赖关系是完全函数依赖 $(Sno,Cno) \\overset{F}{\\longrightarrow} Grade$ 部分函数依赖:关系R(Sno,Sname,Ssex,Sclass,Sage),依赖关系中我们可以用Sno,Sname推出Ssex，也就是(Sno,Sname)-\u003eSsex，但是Sno-\u003eSsex，这样的话就是部分函数依赖了。 传递函数依赖：图里面写的很明白，这里就不多赘述 ","date":"2024-05-18","objectID":"/posts/2c94a50/:3:0","tags":["数据库"],"title":"数据库六种范式","uri":"/posts/2c94a50/"},{"categories":["数据库"],"content":"函数依赖和属性的关系 设R(U)是属性集U上的关系模式，X、Y是U的子集。 如果X和Y之间是一对一（1:1）关系，如学校和校长，则存在函数依赖X→Y和Y→X。 如果X和Y之间是一对多（1:n）关系，如年龄和姓名，则存在函数依赖Y→X。 如果X和Y之间是多对多（m:n）关系，如学生和课程，则X和Y之间不存在函数依赖。 范式 ","date":"2024-05-18","objectID":"/posts/2c94a50/:4:0","tags":["数据库"],"title":"数据库六种范式","uri":"/posts/2c94a50/"},{"categories":["数据库"],"content":"第一范式 1NF 属性不可分 ","date":"2024-05-18","objectID":"/posts/2c94a50/:5:0","tags":["数据库"],"title":"数据库六种范式","uri":"/posts/2c94a50/"},{"categories":["数据库"],"content":"第二范式 2NF https://www.geeksforgeeks.org/second-normal-form-2nf/ 第二范式要求一个表中的每个非主属性都完全函数依赖于候选码，即表中的每个非主属性都必须完全依赖于整个候选码，而不是部分依赖于候选码的某一部分。 我们来看这个表，很明显这个表不符合第二范式，其中STUD_NO和COURSE_NO是候选码(主属性)，而COURSE_FEE是非主属性，但是它并不依赖STUD_NO，而是只依赖COURSE_NO，因此是部分依赖于整个候选码。 由此可以得出，这个表不符合第二范式 ","date":"2024-05-18","objectID":"/posts/2c94a50/:6:0","tags":["数据库"],"title":"数据库六种范式","uri":"/posts/2c94a50/"},{"categories":["数据库"],"content":"第三范式 3NF ","date":"2024-05-18","objectID":"/posts/2c94a50/:7:0","tags":["数据库"],"title":"数据库六种范式","uri":"/posts/2c94a50/"},{"categories":["数据库"],"content":"BCNF ","date":"2024-05-18","objectID":"/posts/2c94a50/:8:0","tags":["数据库"],"title":"数据库六种范式","uri":"/posts/2c94a50/"},{"categories":["折腾"],"content":" https://openwrt.org/docs/guide-developer/procd-init-script-example cd /etc/init.d vim frpc #!/bin/sh /etc/rc.common START=99 STOP=90 SERVICE=frpc USE_PROCD=1 PROC=\"/usr/bin/frpc -c /root/frpc/frpc.toml\" start_service(){ procd_open_instance procd_set_param command $PROC procd_set_param respawn procd_close_instance } service_triggers() { procd_add_reload_trigger \"rpcd\" } /etc/init.d/frp enable \u0026\u0026 echo on ","date":"2024-05-18","objectID":"/posts/e31d395/:0:0","tags":["折腾","Linux"],"title":"Openwrt开机自启frpc","uri":"/posts/e31d395/"},{"categories":["Java - Spring - SpringMVC"],"content":"Spring MVC项目创建 把没用的文件删掉 添加依赖 \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e6.1.3\u003c/version\u003e \u003c/dependency\u003e \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003ecom.meowrain\u003c/groupId\u003e \u003cartifactId\u003espring_mvc\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003cname\u003espring_mvc\u003c/name\u003e \u003cpackaging\u003ewar\u003c/packaging\u003e \u003cproperties\u003e \u003cproject.build.sourceEncoding\u003eUTF-8\u003c/project.build.sourceEncoding\u003e \u003cmaven.compiler.target\u003e11\u003c/maven.compiler.target\u003e \u003cmaven.compiler.source\u003e11\u003c/maven.compiler.source\u003e \u003cjunit.version\u003e5.9.2\u003c/junit.version\u003e \u003c/properties\u003e \u003cdependencies\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e6.1.3\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ejakarta.servlet\u003c/groupId\u003e \u003cartifactId\u003ejakarta.servlet-api\u003c/artifactId\u003e \u003cversion\u003e5.0.0\u003c/version\u003e \u003cscope\u003eprovided\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-api\u003c/artifactId\u003e \u003cversion\u003e${junit.version}\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-engine\u003c/artifactId\u003e \u003cversion\u003e${junit.version}\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-war-plugin\u003c/artifactId\u003e \u003cversion\u003e3.3.2\u003c/version\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e \u003c/project\u003e 创建config包，里面放入配置类 package com.meowrain.config; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.EnableWebMvc; @Configuration @ComponentScan(\"com.meowrain\") @EnableWebMvc public class SpringMvcConfiguration { } package com.meowrain.config; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @Configuration @ComponentScan(\"com.meowrain\") public class SpringConfiguration { } package com.meowrain.config; import jakarta.servlet.Filter; import org.springframework.web.filter.CharacterEncodingFilter; import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer; public class MainInitializer extends AbstractAnnotationConfigDispatcherServletInitializer { @Override protected Class\u003c?\u003e[] getRootConfigClasses() { return new Class[]{SpringConfiguration.class}; } @Override protected Class\u003c?\u003e[] getServletConfigClasses() { return new Class[]{SpringMvcConfiguration.class}; } @Override protected String[] getServletMappings() { return new String[]{\"/\"}; } @Override protected Filter[] getServletFilters() { CharacterEncodingFilter filter = new CharacterEncodingFilter(); filter.setEncoding(\"utf-8\"); return new Filter[]{filter}; } } spring mvc https://www.baeldung.com/spring-mvc https://www.yuque.com/fcant/java/gq0yrlu8uw5tzxmp https://www.yuque.com/liujijiself/dn64yi/ah2o8t ","date":"2024-05-18","objectID":"/posts/731590c/:0:0","tags":["draft"],"title":"SpringMVC项目搭建","uri":"/posts/731590c/"},{"categories":["C++"],"content":"const与function 在c++中，const在function中有不一样的使用 #include \u003ciostream\u003e #include \u003cstring\u003e class Example { public: Example(const std::string \u0026name) : m_Name(name) {} const std::string\u0026 GetName() const {return m_Name;}; private: std::string m_Name; }; int main() { Example example(\"John\"); const std::string\u0026 name = example.GetName(); std::cout \u003c\u003c name \u003c\u003c std::endl;//输出 “John\" // name = \"Alice\"; //wrong } 这个函数的返回值是一个指向常量字符串的引用。const修饰的是返回值的类型，表示返回的字符串是一个常量，不能被修改。 函数签名中的第二个const修饰的是成员函数本身，表示这个函数是一个const成员函数，即在该函数内部不能修改类的成员变量。 因此，这个函数返回一个指向常量字符串的引用，并且在该函数内部不修改类的成员变量。 ","date":"2024-05-18","objectID":"/posts/2a356ef/:0:0","tags":["C++"],"title":"C++ Const与function","uri":"/posts/2a356ef/"},{"categories":["C++"],"content":"C++ STL ","date":"2024-05-18","objectID":"/posts/4b6605b/:0:0","tags":["C++","STL"],"title":"C++STL","uri":"/posts/4b6605b/"},{"categories":["C++"],"content":"vector ","date":"2024-05-18","objectID":"/posts/4b6605b/:1:0","tags":["C++","STL"],"title":"C++STL","uri":"/posts/4b6605b/"},{"categories":["C++"],"content":"vector构造器 #include \u003cvector\u003e #include \u003ciostream\u003e /* vector\u003cT\u003e v; // 采用模版类实现，默认构造函数 vector\u003cT\u003e v(T* v1.begin(), T* v1.end()); // 将v1[begin(), end())区间中的元素拷贝给本身 vector\u003cT\u003e v(int n, T elem); // 将n个elem拷贝给本身 vector\u003cT\u003e v(const vector\u003cT\u003e v1); // 拷贝构造函数 */ int main(void) { std::vector\u003cint\u003e v; // 默认构造函数 for(int i = 0;i\u003c10;i++) { v.push_back(i); } //----------------------------- std::vector\u003cint\u003e v2{v.begin(),v.end()};// 拷贝构造函数 for(int i = 0;i\u003c10;i++) { std::cout \u003c\u003c v2[i] \u003c\u003c \" \"; } std::cout \u003c\u003c std::endl; //----------------------------- //----------------------------- std::vector\u003cint\u003e v3(3,10); // 将3个10拷贝给本身 for(int i = 0;i\u003c3;i++) { std::cout \u003c\u003c v3[i] \u003c\u003c \" \"; } std::cout \u003c\u003c std::endl; //----------------------------- //----------------------------- std::vector\u003cint\u003e v4(v3); // 拷贝构造函数 for(int i = 0;i\u003c3;i++) { std::cout \u003c\u003c v4[i] \u003c\u003c \" \"; } //----------------------------- } ","date":"2024-05-18","objectID":"/posts/4b6605b/:1:1","tags":["C++","STL"],"title":"C++STL","uri":"/posts/4b6605b/"},{"categories":["C++"],"content":"vector 方法 assign方法 std::vector 的 assign() 是一个成员函数，用于将容器重置并赋予新的元素值。assign() 可以以不同的方式使用，这取决于传递给它的参数。以下是 assign() 的应用示例： 使用单一值初始化容器： #include \u003ciostream\u003e #include \u003cvector\u003e int main() { std::vector\u003cint\u003e myVector; // 使用 assign() 将容器重置为包含 5 个元素，每个元素的值都是 42 myVector.assign(5, 42); // 输出容器的元素 for (const auto\u0026 element : myVector) { std::cout \u003c\u003c element \u003c\u003c \" \"; } std::cout \u003c\u003c std::endl; return 0; } 42 42 42 42 42 使用范围内的值初始化容器： #include \u003ciostream\u003e #include \u003cvector\u003e int main(void) { std::vector\u003cint\u003e ve; int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; ve.assign(arr, arr + 10); for (auto \u0026ele : ve) { std::cout \u003c\u003c ele \u003c\u003c \" \"; } std::cout \u003c\u003c std::endl; return 0; } 1 2 3 4 5 6 7 8 9 10 swap方法 #include \u003ciostream\u003e #include \u003cvector\u003e int main() { std::vector\u003cint\u003e v1 = {1, 2, 3}; std::vector\u003cint\u003e v2 = {4, 5, 6}; std::cout \u003c\u003c \"Before swap: \" \u003c\u003c std::endl; std::cout \u003c\u003c \"v1: \"; for (int num : v1) { std::cout \u003c\u003c num \u003c\u003c \" \"; } std::cout \u003c\u003c std::endl; std::cout \u003c\u003c \"v2: \"; for (int num : v2) { std::cout \u003c\u003c num \u003c\u003c \" \"; } std::cout \u003c\u003c std::endl; v1.swap(v2); std::cout \u003c\u003c \"After swap: \" \u003c\u003c std::endl; std::cout \u003c\u003c \"v1: \"; for (int num : v1) { std::cout \u003c\u003c num \u003c\u003c \" \"; } std::cout \u003c\u003c std::endl; std::cout \u003c\u003c \"v2: \"; for (int num : v2) { std::cout \u003c\u003c num \u003c\u003c \" \"; } std::cout \u003c\u003c std::endl; return 0; } vector 大小操作 bool empty(); // 判断容器是否为空 void resize(int num); 重新指定容器的长度为num，若容器变长，则以默认值填充新位置。 若容器变短，则末尾超出容器长度的元素被删除 void resize(int num, T elem); 重新指定容器的长度为num，若容器变长，则以elem填充新位置。 若容器变短，则末尾超出容器长度的元素被删除 int capacity(); // 返回容器的容量 void reserve(int len); 容器预留len个元素长度，预留位置不初始化，元素不可访问 /* int size(); // 返回容器中的元素个数 bool empty(); // 判断容器是否为空 void resize(int num); 重新指定容器的长度为num，若容器变长，则以默认值填充新位置。 若容器变短，则末尾超出容器长度的元素被删除 void resize(int num, T elem); 重新指定容器的长度为num，若容器变长，则以elem填充新位置。 若容器变短，则末尾超出容器长度的元素被删除 int capacity(); // 返回容器的容量 void reserve(int len); 容器预留len个元素长度，预留位置不初始化，元素不可访问 */ #include \u003ciostream\u003e #include \u003cvector\u003e int main(void) { /* size empty */ std::vector\u003cint\u003e v; std::cout \u003c\u003c \"size: \" \u003c\u003c v.size() \u003c\u003c std::endl; //size: 0 std::cout \u003c\u003c \"is empty? \" \u003c\u003c std::boolalpha \u003c\u003c v.empty() \u003c\u003c std::endl; //true /* size: 0 is empty? true */ /* resize */ std::vector\u003cint\u003e v2; for(int i = 0;i\u003c10;i++) { v2.push_back(i); } for(int i = 0;i\u003c10;i++) { std::cout \u003c\u003c v2[i] \u003c\u003c \" \"; } std::cout \u003c\u003c std::endl; v2.resize(5); std::vector\u003cint\u003e::iterator it = v2.begin(); std::cout \u003c\u003c \"vector size:\" \u003c\u003c v2.size() \u003c\u003c std::endl; //5 std::cout \u003c\u003c \"v2 resize(5)\" \u003c\u003c std::endl; while(it != v2.end()) { std::cout \u003c\u003c *it \u003c\u003c \" \"; it++; } std::cout \u003c\u003c std::endl; std::cout \u003c\u003c \"v2 resize(15,1)\" \u003c\u003c std::endl; v2.resize(15,1); it = v2.begin(); while(it != v2.end()) { std::cout \u003c\u003c *it \u003c\u003c \" \"; it++; } std::cout \u003c\u003c std::endl; /* capacity */ std::vector\u003cint\u003e v3; for(int i = 0;i\u003c100;i++) { v3.push_back(i); } std::cout \u003c\u003c \"vector size:\" \u003c\u003c v3.size() \u003c\u003c std::endl; //100 std::cout \u003c\u003c \"vector capacity: \" \u003c\u003c v3.capacity() \u003c\u003c std::endl; //128 /* reverse */ std::vector\u003cchar\u003e v4; v4.reserve(1000); std::cout \u003c\u003c \"v4 capacity: \" \u003c\u003c v4.capacity() \u003c\u003c std::endl;//v4 capacity: 1000 return 0; } vector插入和删除操作 /* insert(const_iterator pos, T elem); // 在pos位置处插入元素elem insert(const_iterator pos, int n, T elem); // 在pos位置插入n个元素elem insert(pos, beg, end); // 将[beg, end)区间内的元素插到位置pos push_back(T elem); // 尾部插入元素elem pop_back(); // 删除最后一个元素 erase(const_iterator start, const_iterator end); // 删除区间[start, end)内的元素 erase(const_iterator pos); // 删除位置pos的元素 clear(); // 删除容器中的所有元素 */ #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003citerator\u003e int main(void) { std::vector\u003cint\u003e ve; for(int i = 0;i\u003c10;i++) { ve.push_back(i); } auto it = ve.begin(); //迭代器指针指向容器开头 std::advance(it,2); //迭代器指针向后移动两位 ve.insert(it,12); //使用insert把12插入到Index为2得地方 it = ve.begin(); while(it!=ve.end()){ std::cout \u003c\u003c *it \u003c\u003c \" \"; it++; }//0 1 12 2 3 4 5 6 7 8 9 std::cout \u003c\u003c std::endl; ve.pop_back(); //弹出尾部元素 it = ve.begin(); for(auto\u0026 ele : ve) { std::cout \u003c\u003c ele \u003c\u003c \" \"; }//0 1 12 2 3 4 5 6 7 8 std::cout \u003c\u003c std::endl; std::vector\u003cint\u003e ve2; for(int i = 1;i\u003c=10;i++) { ve2.push_back(i); } auto it1","date":"2024-05-18","objectID":"/posts/4b6605b/:1:2","tags":["C++","STL"],"title":"C++STL","uri":"/posts/4b6605b/"},{"categories":["C++"],"content":"vector的遍历 迭代器遍历 #include \u003ciostream\u003e #include \u003cvector\u003e int main() { std::vector\u003cint\u003e myVector = {1, 2, 3, 4, 5}; // 使用迭代器遍历 for (std::vector\u003cint\u003e::iterator it = myVector.begin(); it != myVector.end(); ++it) { std::cout \u003c\u003c *it \u003c\u003c \" \"; } std::cout \u003c\u003c std::endl; return 0; } for循环 #include \u003ciostream\u003e #include \u003cvector\u003e int main() { std::vector\u003cint\u003e myVector = {1, 2, 3, 4, 5}; // 使用范围-based for 循环遍历 for (const auto\u0026 element : myVector) { std::cout \u003c\u003c element \u003c\u003c \" \"; } std::cout \u003c\u003c std::endl; return 0; } ","date":"2024-05-18","objectID":"/posts/4b6605b/:1:3","tags":["C++","STL"],"title":"C++STL","uri":"/posts/4b6605b/"},{"categories":["数据库 - Mysql"],"content":" 第24章 零基础学MySQL 解决之道 文件、数据库 MySQL 数据库的安装和配置 使用命令行窗口连接MYSQL 数据库 操作示意图 数据库三层结构 数据在数据库中的存储方式 SQL 语句分类 创建数据库 查看、删除数据库 备份恢复数据库 备份恢复数据库的表 创建表 Mysql 常用数据类型(列类型) 数值型(整数)的基本使用 定义一个无符号的整数 数值型(bit)的使用 数值型(小数)的基本使用 字符串的基本使用 字符串使用细节 日期类型的基本使用 创建表练习 修改表-基本介绍 修改表-课堂练习 数据库C[create]R[read]U[update]D[delete]语句 Insert 语句 使用INSERT 语句向表中插入数据。 细节说明 update 语句 使用 update 语句修改表中数据 基本使用 使用细节 delete 语句 使用delete 语句删除表中数据 使用细节 select 语句 基本语法 注意事项(创建测试表学生表) 练习 使用表达式对查询的列进行运算 在select 语句中可使用as 语句 练习 在where 子句中经常使用的运算符 使用where 子句，进行过滤查询 使用order by 子句排序查询结果 合计/统计函数 count sum avg max/min 使用group by 子句对列进行分组 使用having 子句对分组后的结果进行过滤 字符串相关函数 数学相关函数 时间日期相关函数 加密和系统函数 流程控制函数 mysql 表查询–加强 介绍 分页查询 使用分组函数和分组子句 数据分组的总结 mysql 多表查询 多表查询练习 自连接 mysql 表子查询 什么是子查询 单行子查询 多行子查询 子查询当做临时表使用 在多行子查询中使用 all 操作符 在多行子查询中使用 any 操作符 多列子查询 在from 子句中使用子查询 表复制 自我复制数据(蠕虫复制) 合并查询 介绍 mysql 表外连接 外连接 mysql 约束 基本介绍 primary key(主键) not null(非空) unique(唯一) foreign key(外键) check 商店售货系统表设计案例 自增长 自增长基本介绍 自增长使用细节 mysql 索引 索引快速入门 索引的原理 索引的类 索引使用 哪些列上适合使用索引 mysql 事务 什么是事务 事务和锁 回退事务 提交事务 事务细节讨论 mysql 事务隔离级别 事务隔离级别介绍 查看事务隔离级别 事务隔离级别 mysql 的事务隔离级–案例 设置事务隔离级别 mysql 事务ACID 事务的acid 特性 mysql 表类型和存储引擎 基本介绍 主要的存储引擎/表类型特点 细节说明 三种存储引擎表使用案例 如何选择表的存储引擎 修改存储引擎 视图(view) 看一个需求 基本概念 视图的基本使用 视图细节讨论 视图最佳实践 视图课堂练习 Mysql 管理 Mysql 用户 创建用户 删除用户 用户修改密码 mysql 中的权限 给用户授权 回收用户授权 权限生效指令 课堂练习题 细节说明 本章作业 第24章 零基础学MySQL ","date":"2024-05-18","objectID":"/posts/f0ce569/:0:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"解决之道 ","date":"2024-05-18","objectID":"/posts/f0ce569/:1:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"文件、数据库 为了解决上述问题,使用更加利于管理数据的东东-数据库，它能更有效的管理数据。 举一个生活化的案例说明：如果说图书馆是保存书籍的,那么数据库就是保存数据的。 ","date":"2024-05-18","objectID":"/posts/f0ce569/:1:1","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"MySQL 数据库的安装和配置 mysql5.5 mysql5.6 mysqI5.7(稳定) mysql8 更高版本 ","date":"2024-05-18","objectID":"/posts/f0ce569/:1:2","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"使用命令行窗口连接MYSQL 数据库 mysql -h主机名-P端口-u用户名-p密码 登录前，保证服务启动 net stop mysql服务名 net start mysql服务名 ","date":"2024-05-18","objectID":"/posts/f0ce569/:1:3","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"操作示意图 Navicat 介绍: 图形化MySQL 管理软件 SQLyog ","date":"2024-05-18","objectID":"/posts/f0ce569/:1:4","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"数据库三层结构 所谓安装Mysql数据库，就是在主机安装一个数据库管理系统(DBMS)，这个管理程序可以管理多个数据库。DBMS(database manage system)。 一个数据库中可以创建多个表,以保存数据(信息)。 数据库管理系统(DBMS)、数据库和表的关系如图所示;示意图。 ","date":"2024-05-18","objectID":"/posts/f0ce569/:2:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"数据在数据库中的存储方式 ","date":"2024-05-18","objectID":"/posts/f0ce569/:3:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"SQL 语句分类 DDL:数据定义语句[create表，库…] DML:数据操作语句[增加insert，修改update，删除 delete] DQL:数据查询语句[select ] DCL:数据控制语句[管理数据库: 比如用户权限 grant revoke ] ","date":"2024-05-18","objectID":"/posts/f0ce569/:4:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"创建数据库 CHARACTER SET:指定数据库采用的字符集，如果不指定字符集，默认utf8 COLLATE:指定数据库字符集的校对规则(常用的utf8 bin[区分大小写] utf8_general_ci[不区分大小写] 注意默认是 utf8 general_ci ) # 演示数据库的操作 #创建一个名称为db01的数据库。[图形化和指令 演示] #使用指令创建数据库 CREATE DATABASE db01; #删除数据库指令 DROP DATABASE db01 #创建一个使用utf8字符集的hsp_db02数据库 CREATE DATABASE db02 CHARACTER SET utf8 #创建一个使用utf8字符集，并带校对规则的hsp_db03数据库 CREATE DATABASE db03 CHARACTER SET utf8 COLLATE utf8_bin #校对规则 utf8_bin 区分大小 默认utf8_general_ci 不区分大小写 #下面是一条查询的sql , select 查询 * 表示所有字段 FROM 从哪个表 #WHERE 从哪个字段 NAME = 'tom' 查询名字是tom SELECT * FROM t1 WHERE NAME = 'tom' ","date":"2024-05-18","objectID":"/posts/f0ce569/:5:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"查看、删除数据库 显示数据库语句: SHOW DATABASES 显示数据库创建语句: SHOW CREATE DATABASE db_name 数据库删除语句[一定要慎用]: DROP DATABASE [IF EXISTS] db_ name #演示删除和查询数据库 #查看当前数据库服务器中的所有数据库 SHOW DATABASES #查看前面创建的hsp_db01数据库的定义信息 SHOW CREATE DATABASE `hsp_db01` #在创建数据库,表的时候，为了规避关键字，可以使用反引号解决，比如有数据库的名称就叫做CREATE，那么就需要使用` `解决。 #删除前面创建的hsp_db01数据库 DROP DATABASE hsp_db01 ","date":"2024-05-18","objectID":"/posts/f0ce569/:6:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"备份恢复数据库 备份数据库(注意:在DOS执行)命令行 mysqldump -u 用户名 -p -B 数据库1 数据库2 数据库n \u003e文件名.sql 恢复数据库(注意:进入Mysql命令行再执行) Source 文件名.sql #练习 : database03.sql 备份db02 和 db03 库中的数据，并恢复 #备份, 要在Dos下执行mysqldump指令其实在mysql安装目录\\bin #这个备份的文件，就是对应的sql语句 mysqldump -u root -p -B db02 db03 \u003e d:\\\\bak.sql DROP DATABASE ecshop; #恢复数据库(注意：进入Mysql命令行再执行) source d:\\\\bak.sql #第二个恢复方法， 直接将bak.sql的内容放到查询编辑器中，执行，相当于重新执行了一遍 ","date":"2024-05-18","objectID":"/posts/f0ce569/:7:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"备份恢复数据库的表 备份库的表 mysqldump -u 用户名 -p密码 数据库 表1 表2 表n \u003e d:\\\\文件名.sql ","date":"2024-05-18","objectID":"/posts/f0ce569/:8:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"创建表 CREATE TABLE table_name ( field1 datatype, field2 datatype, field3 datatype )character set 字符集 collate 校对规则 engine 存储引擎 field:指定列名 datatype:指定列类型(字段类型) character set:如不指定则为所在数据库字符集 collate:如不指定则为所在数据库校对规则 engine:引擎(这个涉及内容较多) #指令创建表 #注意：db02创建表时，要根据需保存的数据创建相应的列，并根据数据的类型定义相应的列类型。例：user表 (快速入门案例 create_tab01.sql) #id 整形 [图形化，指令] #name 字符串 #password 字符串 #birthday 日期 CREATE TABLE `user` ( id INT, `name` VARCHAR(255), `password` VARCHAR(255), `birthday` DATE) CHARACTER SET utf8 COLLATE utf8_bin ENGINE INNODB; ","date":"2024-05-18","objectID":"/posts/f0ce569/:9:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"Mysql 常用数据类型(列类型) ","date":"2024-05-18","objectID":"/posts/f0ce569/:10:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"数值型(整数)的基本使用 #演示整型的是一个 #使用tinyint 来演示范围 有符号 -128 ~ 127 如果没有符号 0-255 #说明： 表的字符集，校验规则, 存储引擎，老师使用默认 #1. 如果没有指定 unsinged , 则TINYINT就是有符号 #2. 如果指定 unsinged , 则TINYINT就是无符号 0-255 CREATE TABLE t3 ( id TINYINT); CREATE TABLE t4 ( id TINYINT UNSIGNED); INSERT INTO t3 VALUES(127); #这是非常简单的添加语句 SELECT * FROM t3 INSERT INTO t4 VALUES(255); SELECT * FROM t4; ","date":"2024-05-18","objectID":"/posts/f0ce569/:10:1","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"定义一个无符号的整数 create table t10 (id tinyint );//默认是有符号的 create table t11 (id tinyint unsigned);//无符号的 （后加unsigned就行） ","date":"2024-05-18","objectID":"/posts/f0ce569/:10:2","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"数值型(bit)的使用 1.基本使用 mysql \u003e create table t05 (num bit(8)); mysql \u003e insert into t05 (1, 3); mysql \u003e insert into t05 values(2, 65); 2.细节说明bit.sql bit字段显示时，按照位的方式显示. 查询的时候仍然可以用使用添加的数值 如果一个值只有0，1可以考虑使用bit(1), 可以节约空间 位类型。M指定位数，默认值1，范围1-64 #演示bit类型使用 #说明 #1. bit(m) m 在 1-64 #2. 添加数据 范围 按照你给的位数来确定，比如 m = 8 表示一个字节 0~255 #3. 显示按照bit #4. 查询时，仍然可以按照数来查询 CREATE TABLE t05 (num BIT(8)); INSERT INTO t05 VALUES(255); # 按位显示 255 就是全1 （b'11111111'） SELECT * FROM t05; SELECT * FROM t05 WHERE num = 1; ","date":"2024-05-18","objectID":"/posts/f0ce569/:10:3","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"数值型(小数)的基本使用 FLOAT/DOUBLE [UNSIGNED] Float单精度精度，Double双精度. DECIMAL[M,D] [UNSIGNED] 可以支持更加精确的小数位。M是小数位数(精度)的总数，D是小数点(标度)后面的位数。 如果D是0，则值没有小数点或分数部分。M最大65。D最大是30。如果D被省略,默认是0。如果M被省略,默认是10。 建议:如果希望小数的精度高，推荐使用decimal #演示decimal类型、float、double使用 #创建表 CREATE TABLE t06 ( num1 FLOAT, num2 DOUBLE, num3 DECIMAL(30,20)); #添加数据 INSERT INTO t06 VALUES(88.12345678912345, 88.12345678912345,88.12345678912345); SELECT * FROM t06; #decimal可以存放很大的数 CREATE TABLE t07 ( num DECIMAL(65)); INSERT INTO t07 VALUES(8999999933338388388383838838383009338388383838383838383); SELECT * FROM t07; CREATE TABLE t08( num BIGINT UNSIGNED) INSERT INTO t08 VALUES(8999999933338388388383838838383009338388383838383838383); SELECT * FROM t08; ","date":"2024-05-18","objectID":"/posts/f0ce569/:10:4","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"字符串的基本使用 CHAR(size) 固定长度字符串最大255字符 VARCHAR(size)0~65535 可变长度字符串最大65532字节【utf8编码最大21844字符（（65535-3） / 3）其中1-3个字节用于记录大小】 #演示字符串类型使用char varchar #注释的快捷键 shift+ctrl+c , 注销注释 shift+ctrl+r -- CHAR(size) -- 固定长度字符串 最大255 字符 -- VARCHAR(size) 0~65535字节 -- 可变长度字符串 最大65532字节 【utf8编码最大21844字符 1-3个字节用于记录大小】 -- 如果表的编码是 utf8 varchar(size) size = (65535-3) / 3 = 21844 -- 如果表的编码是 gbk varchar(size) size = (65535-3) / 2 = 32766 CREATE TABLE t09 ( `name` CHAR(255)); CREATE TABLE t10 ( `name` VARCHAR(32766)) CHARSET gbk; DROP TABLE t10; ","date":"2024-05-18","objectID":"/posts/f0ce569/:10:5","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"字符串使用细节 1.细节1 char(4) //这个4表示字符数(最大255)，不是字节数,不管是中文还是字母都是放四个,按字符计算. varchar(4) //这个4表示字符数，不管是字母还是中文都以定义好的表的编码来存放数据 不管是中文还是英文字母，都是最多存放4个，是按照字符来存放的. 2.细节2 char(4)是定长(固定的大小)，就是说，即使你插入’aa’，也会占用分配的4个字符的空间. varchar(4)是变长(变化的大小)，就是说，如果你插入了’aa’,实际占用空间大小并不是4个字符，而是按照实际占用空间来分配(说明:varchar本身还需要占用1-3个字节来记录存放内容长度) L(实际数据大小)+(1-3)字节 3.细节3 什么时候使用char，什么时候使用varchar 如果数据是定长,推荐使用char,比如md5的密码,邮编,手机号,身份证号码等. char(32) 如果一个字段的长度是不确定,我们使用varchar ,比如留言,文章 查询速度: char \u003e varchar 4.细节4 在存放文本时，也可以使用Text数据类型。可以将TEXT列视为VARCHAR列，注意Text 不能有默认值。大小0-2^16字节。如果希望存放更多字符，可以选择 MEDIUMTEXT 0O-2^24 或者LONGTEXT 0~2^32 #演示字符串类型的使用细节 #char(4) 和 varchar(4) 这个4表示的是字符，而不是字节, 不区分字符是汉字还是字母 CREATE TABLE t11( `name` CHAR(4)); INSERT INTO t11 VALUES('你好你好'); SELECT * FROM t11; CREATE TABLE t12( `name` VARCHAR(4)); INSERT INTO t12 VALUES('你好你好'); INSERT INTO t12 VALUES('ab北京'); SELECT * FROM t12; #如果varchar 不够用，可以考试使用mediumtext 或者longtext, #如果想简单点，可以使用直接使用text CREATE TABLE t13( content TEXT, content2 MEDIUMTEXT , content3 LONGTEXT); INSERT INTO t13 VALUES('你好你教育', '你好你教育100', '你好你教育1000~~'); SELECT * FROM t13; ","date":"2024-05-18","objectID":"/posts/f0ce569/:10:6","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"日期类型的基本使用 CREATE TABLE birthday6( t1 DATE, t2 DATETIME, t3 TIMESTAMP NOT NULL DEFAULTCURRENT TIMESTAMP ON UPDATE CURRENT TIMESTAMP ); timestamp时间戳 # NOT NULL DEFAULTCURRENT TIMESTAMP ON UPDATE CURRENT TIMESTAMP 意思是没有默认值的话会根据当前时间自动更新 mysql\u003e INSERT INTO birthday (t1,t2) VALUES('2022-11-11',2022-11-11 10:10:10'); 日期类型的细节说明 TimeStamp在Insert和update时，自动更新。 #演示时间相关的类型 #创建一张表, date , datetime , timestamp CREATE TABLE t14 ( birthday DATE , -- 生日 job_time DATETIME, -- 记录年月日 时分秒 login_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP); -- 登录时间, 如果希望login_time列自动更新, 需要配置 SELECT * FROM t14; INSERT INTO t14(birthday, job_time) VALUES('2022-11-11','2022-11-11 10:10:10'); -- 如果我们更新 t14 表的某条记录，login_time列会自动的以当前时间进行更新 ","date":"2024-05-18","objectID":"/posts/f0ce569/:10:7","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"创建表练习 #创建表的课堂练习 -- 字段 属性 -- Id 整形 -- name 字符型 -- sex 字符型 -- brithday 日期型（date） -- entry_date 日期型 (date) -- job 字符型 -- Salary 小数型 -- resume 文本型 -- 自己一定要练习一把 CREATE TABLE `emp` ( id INT, `name` VARCHAR(32), sex CHAR(1), brithday DATE, entry_date DATETIME, job VARCHAR(32), salary DOUBLE, `resume` TEXT) CHARSET utf8 COLLATE utf8_bin ENGINE INNODB; -- 添加一条 INSERT INTO `emp` VALUES(100, '小妖怪', '男', '2000-11-11', '2010-11-10 11:11:11', '巡山的', 3000, '大王叫我来巡山'); SELECT * FROM `emp`; ","date":"2024-05-18","objectID":"/posts/f0ce569/:11:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"修改表-基本介绍 ","date":"2024-05-18","objectID":"/posts/f0ce569/:12:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"修改表-课堂练习 NOT NULL DEFAULT '' 不允许为空NULL，默认是一个空的’ ‘字符。 #修改表的操作练习 -- 员工表emp的上增加一个image列，varchar类型(要求在resume后面)。 ALTER TABLE emp ADD image VARCHAR(32) NOT NULL DEFAULT '' AFTER RESUME DESC employee -- 显示表结构，可以查看表的所有列 -- 修改job列，使其长度为60。 ALTER TABLE emp MODIFY job VARCHAR(60) NOT NULL DEFAULT '' -- 删除sex列。 ALTER TABLE emp DROP sex -- 表名改为employee。 RENAME TABLE emp TO employee -- 修改表的字符集为utf8 ALTER TABLE employee CHARACTER SET utf8 -- 列名name修改为us er_name ALTER TABLE employee CHANGE `name` `user_name` VARCHAR(64) NOT NULL DEFAULT '' DESC employee ","date":"2024-05-18","objectID":"/posts/f0ce569/:13:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"数据库C[create]R[read]U[update]D[delete]语句 Insert语句 (添加数据) Update语句 (更新数据） Delete语句 (删除数据) Select语句 (查找数据) ","date":"2024-05-18","objectID":"/posts/f0ce569/:14:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"Insert 语句 ","date":"2024-05-18","objectID":"/posts/f0ce569/:15:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"使用INSERT 语句向表中插入数据。 #练习insert 语句 -- 创建一张商品表goods (id int , goods_name varchar(10), price double ); -- 添加2条记录 CREATE TABLE `goods` ( id INT , goods_name VARCHAR(10), -- 长度10 price DOUBLE NOT NULL DEFAULT 100 ); -- 添加数据 INSERT INTO `goods` (id, goods_name, price) VALUES(10, '华为手机', 2000); INSERT INTO `goods` (id, goods_name, price) VALUES(20, '苹果手机', 3000); SELECT * FROM goods; CREATE TABLE `goods2` ( id INT , goods_name VARCHAR(10), -- 长度10 price DOUBLE NOT NULL DEFAULT 100 ); ","date":"2024-05-18","objectID":"/posts/f0ce569/:15:1","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"细节说明 #说明insert 语句的细节 -- 1.插入的数据应与字段的数据类型相同。 -- 比如 把 'abc' 添加到 int 类型会错误 INSERT INTO `goods` (id, goods_name, price) VALUES('abc', '小米手机', 2000); -- 2. 数据的长度应在列的规定范围内，例如：不能将一个长度为80的字符串加入到长度为40的列中。 INSERT INTO `goods` (id, goods_name, price) VALUES(40, 'vovo手机vovo手机vovo手机vovo手机vovo手机', 3000); -- 3. 在values中列出的数据位置必须与被加入的列的排列位置相对应。 INSERT INTO `goods` (id, goods_name, price) -- 不对 VALUES('vovo手机',40, 2000); -- 4. 字符和日期型数据应包含在单引号中。 INSERT INTO `goods` (id, goods_name, price) VALUES(40, vovo手机, 3000); -- 错误的 vovo手机 应该 'vovo手机' -- 5. 列可以插入空值[前提是该字段允许为空（如果指定 not null 则不可以）]，insert into table value(null) INSERT INTO `goods` (id, goods_name, price) VALUES(40, 'vovo手机', NULL); -- 6. insert into tab_name (列名..) values (),(),() 形式添加多条记录 INSERT INTO `goods` (id, goods_name, price) VALUES(50, '三星手机', 2300),(60, '海尔手机', 1800); -- 7. 如果是给表中的所有字段添加数据，可以不写前面的字段名称 INSERT INTO `goods` VALUES(70, 'IBM手机', 5000); -- 8. 默认值的使用，当不给某个字段值时，如果有默认值就会添加默认值，否则报错 -- 如果某个列 没有指定 not null ,那么当添加数据时，没有给定值，则会默认给null -- 如果我们希望指定某个列的默认值，可以在创建表时指定 INSERT INTO `goods` (id, goods_name) VALUES(80, '格力手机'); SELECT * FROM goods; INSERT INTO `goods2` (id, goods_name) VALUES(10, '顺平手机'); SELECT * FROM goods2; ","date":"2024-05-18","objectID":"/posts/f0ce569/:15:2","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"update 语句 ","date":"2024-05-18","objectID":"/posts/f0ce569/:16:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"使用 update 语句修改表中数据 ","date":"2024-05-18","objectID":"/posts/f0ce569/:16:1","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"基本使用 -- 演示update语句 -- 要求: 在上面创建的employee表中修改表中的纪录 -- 1. 将所有员工薪水修改为5000元。[如果没有带where 条件，会修改所有的记录，因此要小心] UPDATE employee SET salary = 5000 -- 2. 将姓名为 小妖怪 的员工薪水修改为3000元。 UPDATE employee SET salary = 3000 WHERE user_name = '小妖怪' -- 3. 将 老妖怪 的薪水在原有基础上增加1000元 INSERT INTO employee VALUES(200, '老妖怪', '1990-11-11', '2000-11-11 10:10:10', '捶背的', 5000, '给大王捶背', 'd:\\\\a.jpg'); UPDATE employee SET salary = salary + 1000 WHERE user_name = '老妖怪' -- 可以修改多个列的值 UPDATE employee SET salary = salary + 1000 , job = '出主意的' WHERE user_name = '老妖怪' SELECT * FROM employee; ","date":"2024-05-18","objectID":"/posts/f0ce569/:16:2","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"使用细节 WHERE子句指定应更新哪些行。如没有WHERE子句，则更新所有的行(记录)。 如果需要修改多个字段，可以通过 set 字段1=值1,字段2=值2... ","date":"2024-05-18","objectID":"/posts/f0ce569/:16:3","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"delete 语句 ","date":"2024-05-18","objectID":"/posts/f0ce569/:17:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"使用delete 语句删除表中数据 删除只能按照行删除，不能按照列删除。 -- delete 语句演示 -- 删除表中名称为’老妖怪’的记录。 DELETE FROM employee WHERE user_name = '老妖怪'; -- 删除表中所有记录, 老师提醒，一定要小心 DELETE FROM employee; -- Delete语句不能删除某一列的值（可使用update 设为 null 或者 ''） UPDATE employee SET job = '' WHERE user_name = '老妖怪'; SELECT * FROM employee -- 要删除这个表 DROP TABLE employee; ","date":"2024-05-18","objectID":"/posts/f0ce569/:17:1","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"使用细节 如果不使用where子句，将删除表中所有数据。 Delete语句不能删除某一列的值(可使用update设为null 或者\"\") 使用delete语句删除记录,不删除表本身。如要删除表，使用droptable语句。drop table 表名; ","date":"2024-05-18","objectID":"/posts/f0ce569/:17:2","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"select 语句 ","date":"2024-05-18","objectID":"/posts/f0ce569/:18:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"基本语法 ","date":"2024-05-18","objectID":"/posts/f0ce569/:18:1","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"注意事项(创建测试表学生表) Select 指定查询哪些列的数据。 column指定列名。 *号代表查询所有列。 From指定查询哪张表。 DISTINCT可选, 指显示结果时，是否去掉重复数据。 ","date":"2024-05-18","objectID":"/posts/f0ce569/:18:2","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"练习 -- select 语句【重点 难点】 CREATE TABLE student( id INT NOT NULL DEFAULT 1, NAME VARCHAR(20) NOT NULL DEFAULT '', chinese FLOAT NOT NULL DEFAULT 0.0, english FLOAT NOT NULL DEFAULT 0.0, math FLOAT NOT NULL DEFAULT 0.0 ); INSERT INTO student(id,NAME,chinese,english,math) VALUES(1,'韩顺平',89,78,90); INSERT INTO student(id,NAME,chinese,english,math) VALUES(2,'张飞',67,98,56); INSERT INTO student(id,NAME,chinese,english,math) VALUES(3,'宋江',87,78,77); INSERT INTO student(id,NAME,chinese,english,math) VALUES(4,'关羽',88,98,90); INSERT INTO student(id,NAME,chinese,english,math) VALUES(5,'赵云',82,84,67); INSERT INTO student(id,NAME,chinese,english,math) VALUES(6,'欧阳锋',55,85,45); INSERT INTO student(id,NAME,chinese,english,math) VALUES(7,'黄蓉',75,65,30); INSERT INTO student(id,NAME,chinese,english,math) VALUES(8,'韩信',45,65,99); SELECT * FROM student; -- 查询表中所有学生的信息。 SELECT * FROM student; -- 查询表中所有学生的姓名和对应的英语成绩。 SELECT `name`,english FROM student; -- 过滤表中重复数据 distinct 。 SELECT DISTINCT english FROM student; -- 要查询的记录，每个字段都相同，才会去重 SELECT DISTINCT `name`, english FROM student; ","date":"2024-05-18","objectID":"/posts/f0ce569/:18:3","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"使用表达式对查询的列进行运算 ","date":"2024-05-18","objectID":"/posts/f0ce569/:18:4","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"在select 语句中可使用as 语句 ","date":"2024-05-18","objectID":"/posts/f0ce569/:18:5","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"练习 -- select 语句的使用 -- 统计每个学生的总分 SELECT `name`, (chinese+english+math) FROM student; -- 在所有学生总分加10分的情况 SELECT `name`, (chinese + english + math + 10) FROM student; -- 使用别名表示学生分数。 SELECT `name` AS '名字', (chinese + english + math + 10) AS total_score FROM student; ","date":"2024-05-18","objectID":"/posts/f0ce569/:18:6","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"在where 子句中经常使用的运算符 其中的BETWEEN … AND 是闭区间。 ","date":"2024-05-18","objectID":"/posts/f0ce569/:18:7","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"使用where 子句，进行过滤查询 _：匹配任意一个字符； %：匹配0个或多个字符； [ ]：匹配[ ]中的任意一个字符(若要比较的字符是连续的，则可以用连字符“-”表 达 )； [^ ]：不匹配[ ]中的任意一个字符。 -- select 语句 -- 查询姓名为赵云的学生成绩 SELECT * FROM student WHERE `name` = '赵云' -- 查询英语成绩大于90分的同学 SELECT * FROM student WHERE english \u003e 90 -- 查询总分大于200分的所有同学 SELECT * FROM student WHERE (chinese + english + math) \u003e 200 -- 查询math大于60 并且(and) id大于4的学生成绩 SELECT * FROM student WHERE math \u003e60 AND id \u003e 4 -- 查询英语成绩大于语文成绩的同学 SELECT * FROM student WHERE english \u003e chinese -- 查询总分大于200分 并且 数学成绩小于语文成绩,的姓赵的学生. -- 赵% 表示 名字以赵开头的就可以 SELECT * FROM student WHERE (chinese + english + math) \u003e 200 AND math \u003c chinese AND `name` LIKE '赵%' -- 查询英语分数在 80－90之间的同学。 SELECT * FROM student WHERE english \u003e= 80 AND english \u003c= 90; SELECT * FROM student WHERE english BETWEEN 80 AND 90; -- between .. and .. 是 闭区间 -- 查询数学分数为89,90,91的同学。 SELECT * FROM student WHERE math = 89 OR math = 90 OR math = 91; SELECT * FROM student WHERE math IN (89, 90, 91); -- 查询所有姓李的学生成绩。 SELECT * FROM student WHERE `name` LIKE '韩%' -- 查询数学分\u003e80，语文分\u003e80的同学 ","date":"2024-05-18","objectID":"/posts/f0ce569/:18:8","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"使用order by 子句排序查询结果 Order by 指定排序的列，排序的列既可以是表中的列名，也可以是select 语句后指定的列名。 Asc升序[默认]、Desc降序 ORDER BY子句应位于SELECT语句的结尾。 -- 演示order by使用 -- 对数学成绩排序后输出【升序】。 SELECT * FROM student ORDER BY math; -- 对总分按从高到低的顺序输出 [降序] -- 使用别名排序 SELECT `name` , (chinese + english + math) AS total_score FROM student ORDER BY total_score DESC; -- 对姓韩的学生成绩[总分]排序输出(升序) where + order by SELECT `name`, (chinese + english + math) AS total_score FROM student WHERE `name` LIKE '韩%' ORDER BY total_score; ","date":"2024-05-18","objectID":"/posts/f0ce569/:18:9","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"合计/统计函数 ","date":"2024-05-18","objectID":"/posts/f0ce569/:19:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"count -- 演示mysql的统计函数的使用 -- 统计一个班级共有多少学生？ SELECT COUNT(*) FROM student; -- 统计数学成绩大于90的学生有多少个？ SELECT COUNT(*) FROM student WHERE math \u003e 90 -- 统计总分大于250的人数有多少？ SELECT COUNT(*) FROM student WHERE (math + english + chinese) \u003e 250 -- count(*) 和 count(列) 的区别 -- 解释 :count(*) 返回满足条件的记录的行数 -- count(列): 统计满足条件的某列有多少个，但是会排除 为null的情况 CREATE TABLE t15 ( `name` VARCHAR(20)); INSERT INTO t15 VALUES('tom'); INSERT INTO t15 VALUES('jack'); INSERT INTO t15 VALUES('mary'); INSERT INTO t15 VALUES(NULL); SELECT * FROM t15; SELECT COUNT(*) FROM t15; -- 4 SELECT COUNT(`name`) FROM t15;-- 3 -- 演示sum函数的使用 -- 统计一个班级数学总成绩？ SELECT SUM(math) FROM student; -- 统计一个班级语文、英语、数学各科的总成绩 SELECT SUM(math) AS math_total_score,SUM(english),SUM(chinese) FROM student; -- 统计一个班级语文、英语、数学的成绩总和 SELECT SUM(math + english + chinese) FROM student; -- 统计一个班级语文成绩平均分 SELECT SUM(chinese)/ COUNT(*) FROM student; SELECT SUM(`name`) FROM student; -- 演示avg的使用 -- 练习： -- 求一个班级数学平均分？ SELECT AVG(math) FROM student; -- 求一个班级总分平均分 SELECT AVG(math + english + chinese) FROM student; -- 演示max 和 min的使用 -- 求班级最高分和最低分（数值范围在统计中特别有用） SELECT MAX(math + english + chinese), MIN(math + english + chinese) FROM student; -- 求出班级数学最高分和最低分 SELECT MAX(math) AS math_high_socre, MIN(math) AS math_low_socre FROM student; ","date":"2024-05-18","objectID":"/posts/f0ce569/:19:1","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"sum Sum函数返回满足where条件的行的和 一般使用在数值列。 ","date":"2024-05-18","objectID":"/posts/f0ce569/:19:2","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"avg AVG函数返回满足where条件的一列的平均值 ","date":"2024-05-18","objectID":"/posts/f0ce569/:19:3","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"max/min Max/min函数返回满足where条件的一列的最大/最小值 ","date":"2024-05-18","objectID":"/posts/f0ce569/:19:4","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"使用group by 子句对列进行分组 ","date":"2024-05-18","objectID":"/posts/f0ce569/:19:5","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"使用having 子句对分组后的结果进行过滤 group by 用于对查询的结果分组统计,(示意图) having 子句用于限制分组显示结果 CREATE TABLE dept( /*部门表*/ deptno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0, dname VARCHAR(20) NOT NULL DEFAULT \"\", loc VARCHAR(13) NOT NULL DEFAULT \"\" ); INSERT INTO dept VALUES(10, 'ACCOUNTING', 'NEW YORK'), (20, 'RESEARCH', 'DALLAS'), (30, 'SALES', 'CHICAGO'), (40, 'OPERATIONS', 'BOSTON'); SELECT * FROM dept; -- 员工表 CREATE TABLE emp (empno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0, /*编号*/ ename VARCHAR(20) NOT NULL DEFAULT \"\", /*名字*/ job VARCHAR(9) NOT NULL DEFAULT \"\",/*工作*/ mgr MEDIUMINT UNSIGNED ,/*上级编号*/ hiredate DATE NOT NULL,/*入职时间*/ sal DECIMAL(7,2) NOT NULL,/*薪水*/ comm DECIMAL(7,2) ,/*红利 奖金*/ deptno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0 /*部门编号*/ ); -- 添加测试数据 INSERT INTO emp VALUES(7369, 'SMITH', 'CLERK', 7902, '1990-12-17', 800.00,NULL , 20), (7499, 'ALLEN', 'SALESMAN', 7698, '1991-2-20', 1600.00, 300.00, 30), (7521, 'WARD', 'SALESMAN', 7698, '1991-2-22', 1250.00, 500.00, 30), (7566, 'JONES', 'MANAGER', 7839, '1991-4-2', 2975.00,NULL,20), (7654, 'MARTIN', 'SALESMAN', 7698, '1991-9-28',1250.00,1400.00,30), (7698, 'BLAKE','MANAGER', 7839,'1991-5-1', 2850.00,NULL,30), (7782, 'CLARK','MANAGER', 7839, '1991-6-9',2450.00,NULL,10), (7788, 'SCOTT','ANALYST',7566, '1997-4-19',3000.00,NULL,20), (7839, 'KING','PRESIDENT',NULL,'1991-11-17',5000.00,NULL,10), (7844, 'TURNER', 'SALESMAN',7698, '1991-9-8', 1500.00, NULL,30), (7900, 'JAMES','CLERK',7698, '1991-12-3',950.00,NULL,30), (7902, 'FORD', 'ANALYST',7566,'1991-12-3',3000.00, NULL,20), (7934,'MILLER','CLERK',7782,'1992-1-23', 1300.00, NULL,10); SELECT * FROM emp; -- 工资级别 #工资级别表 CREATE TABLE salgrade ( grade MEDIUMINT UNSIGNED NOT NULL DEFAULT 0, /*工资级别*/ losal DECIMAL(17,2) NOT NULL, /* 该级别的最低工资 */ hisal DECIMAL(17,2) NOT NULL /* 该级别的最高工资*/ ); INSERT INTO salgrade VALUES (1,700,1200); INSERT INTO salgrade VALUES (2,1201,1400); INSERT INTO salgrade VALUES (3,1401,2000); INSERT INTO salgrade VALUES (4,2001,3000); INSERT INTO salgrade VALUES (5,3001,9999); SELECT * FROM salgrade; SELECT * FROM dept; SELECT * FROM emp; # 演示group by + having GROUP by用于对查询的结果分组统计, (示意图) -- having子句用于限制分组显示结果. -- ?如何显示每个部门的平均工资和最高工资 -- 老韩分析: avg(sal) max(sal) -- 按照部分来分组查询 SELECT AVG(sal), MAX(sal) , deptno FROM emp GROUP BY deptno; -- 使用数学方法，对小数点进行处理 SELECT FORMAT(AVG(sal),2), MAX(sal) , deptno FROM emp GROUP BY deptno; -- ?显示每个部门的每种岗位的平均工资和最低工资 -- 老师分析 1. 显示每个部门的平均工资和最低工资 -- 2. 显示每个部门的每种岗位的平均工资和最低工资 SELECT AVG(sal), MIN(sal) , deptno, job FROM emp GROUP BY deptno, job; -- ?显示平均工资低于2000的部门号和它的平均工资 // 别名 -- 老师分析 [写sql语句的思路是化繁为简,各个击破] -- 1. 显示各个部门的平均工资和部门号 -- 2. 在1的结果基础上，进行过滤，保留 AVG(sal) \u003c 2000 -- 3. 使用别名进行过滤 SELECT AVG(sal), deptno FROM emp GROUP BY deptno HAVING AVG(sal) \u003c 2000; -- 使用别名 SELECT AVG(sal) AS avg_sal, deptno FROM emp GROUP BY deptno HAVING avg_sal \u003c 2000; ","date":"2024-05-18","objectID":"/posts/f0ce569/:19:6","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"字符串相关函数 -- 演示字符串相关函数的使用 ， 使用emp表来演示 -- CHARSET(str) 返回字串字符集 SELECT CHARSET(ename) FROM emp; -- CONCAT (string2 [,... ]) 连接字串, 将多个列拼接成一列 SELECT CONCAT(ename, ' 工作是 ', job) FROM emp; -- INSTR (string ,substring ) 返回substring在string中出现的位置,没有返回0 -- dual 亚元表, 系统表 可以作为测试表使用 SELECT INSTR('hanshunping', 'ping') FROM DUAL; -- UCASE (string2 ) 转换成大写 SELECT UCASE(ename) FROM emp; -- LCASE (string2 ) 转换成小写 SELECT LCASE(ename) FROM emp; -- LEFT (string2 ,length ) 从string2中的左边起取length个字符 -- RIGHT (string2 ,length ) 从string2中的右边起取length个字符 SELECT LEFT(ename, 2) FROM emp; -- LENGTH (string ) string长度[按照字节] SELECT LENGTH(ename) FROM emp; -- REPLACE (str ,search_str ,replace_str ) -- 在str中用 replace_str 替换 search_str -- 如果是 manager 就替换成 经理 SELECT ename, REPLACE(job,'MANAGER', '经理') FROM emp; -- STRCMP (string1 ,string2 ) 逐字符比较两字串大小 SELECT STRCMP('hsp', 'hsp') FROM DUAL; -- SUBSTRING (str , position [,length ]) -- 从str的position开始【从1开始计算】,取length个字符 -- 从ename 列的第一个位置开始取出2个字符 SELECT SUBSTRING(ename, 1, 2) FROM emp; -- LTRIM (string2 ) RTRIM (string2 ) TRIM(string) -- 去除前端空格或后端空格 SELECT LTRIM(' 韩顺平教育') FROM DUAL; SELECT RTRIM('韩顺平教育 ') FROM DUAL; SELECT TRIM(' 韩顺平教育 ') FROM DUAL; -- 练习: 以首字母小写的方式显示所有员工emp表的姓名 -- 方法1 -- 思路先取出ename 的第一个字符，转成小写的 -- 把他和后面的字符串进行拼接输出即可 SELECT CONCAT(LCASE(SUBSTRING(ename,1,1)), SUBSTRING(ename,2)) AS new_name FROM emp; SELECT CONCAT(LCASE(LEFT(ename,1)), SUBSTRING(ename,2)) AS new_name FROM emp; ","date":"2024-05-18","objectID":"/posts/f0ce569/:20:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"数学相关函数 rand() 返回一个随机浮点值v,范围在0到1之间(即,其范围为0\u003c=v\u003c=1.0)。若已指定一个整数参数N, 则它被用作种子值,用来产生重复序列。 -- 演示数学相关函数 -- ABS(num) 绝对值 SELECT ABS(-10) FROM DUAL; -- BIN (decimal_number )十进制转二进制 SELECT BIN(10) FROM DUAL; -- CEILING (number2 ) 向上取整, 得到比num2 大的最小整数 SELECT CEILING(-1.1) FROM DUAL; -- CONV(number2,from_base,to_base) 进制转换 -- 下面的含义是 8 是十进制的8, 转成 2进制输出 SELECT CONV(8, 10, 2) FROM DUAL; -- 下面的含义是 8 是16进制的8, 转成 2进制输出 SELECT CONV(16, 16, 10) FROM DUAL; -- FLOOR (number2) 向下取整,得到比 num2 小的最大整数 SELECT FLOOR(-1.1) FROM DUAL; -- FORMAT (number,decimal_places ) 保留小数位数(四舍五入) SELECT FORMAT(78.125458,2) FROM DUAL; -- HEX (DecimalNumber ) 转十六进制 -- LEAST (number , number2 [,..]) 求最小值 SELECT LEAST(0,1, -10, 4) FROM DUAL; -- MOD (numerator ,denominator ) 求余 SELECT MOD(10, 3) FROM DUAL; -- RAND([seed]) RAND([seed]) 返回随机数 其范围为 0 ≤ v ≤ 1.0 -- 1. 如果使用 rand() 每次返回不同的随机数 ，在 0 ≤ v ≤ 1.0 -- 2. 如果使用 rand(seed) 返回随机数, 范围 0 ≤ v ≤ 1.0, 如果seed不变，该随机数也不变了 SELECT RAND() FROM DUAL; SELECT CURRENT_TIMESTAMP() FROM DUAL; ","date":"2024-05-18","objectID":"/posts/f0ce569/:21:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"时间日期相关函数 -- 日期时间相关函数 -- CURRENT_DATE ( ) 当前日期 SELECT CURRENT_DATE() FROM DUAL; -- CURRENT_TIME ( ) 当前时间 SELECT CURRENT_TIME() FROM DUAL; -- CURRENT_TIMESTAMP ( ) 当前时间戳 SELECT CURRENT_TIMESTAMP() FROM DUAL; -- 创建测试表 信息表 CREATE TABLE mes( id INT , content VARCHAR(30), send_time DATETIME); -- 添加一条记录 INSERT INTO mes VALUES(1, '北京新闻', CURRENT_TIMESTAMP()); INSERT INTO mes VALUES(2, '上海新闻', NOW()); INSERT INTO mes VALUES(3, '广州新闻', NOW()); SELECT * FROM mes; SELECT NOW() FROM DUAL; -- 上应用实例 -- 显示所有新闻信息，发布日期只显示 日期，不用显示时间. SELECT id, content, DATE(send_time) FROM mes; -- 请查询在10分钟内发布的新闻, 思路一定要梳理一下. SELECT * FROM mes WHERE DATE_ADD(send_time, INTERVAL 10 MINUTE) \u003e= NOW() SELECT * FROM mes WHERE send_time \u003e= DATE_SUB(NOW(), INTERVAL 10 MINUTE) -- 请在mysql 的sql语句中求出 2011-11-11 和 1990-1-1 相差多少天 SELECT DATEDIFF('2011-11-11', '1990-01-01') FROM DUAL; -- 请用mysql 的sql语句求出你活了多少天? [练习] 1986-11-11 出生 SELECT DATEDIFF(NOW(), '1986-11-11') FROM DUAL; -- 如果你能活80岁，求出你还能活多少天.[练习] 1986-11-11 出生 -- 先求出活80岁 时, 是什么日期 X -- 然后在使用 datediff(x, now()); 1986-11-11-\u003edatetime -- INTERVAL 80 YEAR ： YEAR 可以是 年月日，时分秒 -- '1986-11-11' 可以date,datetime timestamp SELECT DATEDIFF(DATE_ADD('1986-11-11', INTERVAL 80 YEAR), NOW()) FROM DUAL; SELECT TIMEDIFF('10:11:11', '06:10:10') FROM DUAL; -- YEAR|Month|DAY|DATE (datetime) SELECT YEAR(NOW()) FROM DUAL; SELECT MONTH(NOW()) FROM DUAL; SELECT DAY(NOW()) FROM DUAL; SELECT MONTH('2013-11-10') FROM DUAL; -- unix_timestamp() : 返回的是1970-1-1 到现在的秒数 SELECT UNIX_TIMESTAMP() FROM DUAL; -- FROM_UNIXTIME() : 可以把一个unix_timestamp 秒数[时间戳]，转成指定格式的日期 -- %Y-%m-%d 格式是规定好的，表示年月日 -- 意义：在开发中，可以存放一个整数，然后表示时间，通过FROM_UNIXTIME转换 -- SELECT FROM_UNIXTIME(1618483484, '%Y-%m-%d') FROM DUAL; SELECT FROM_UNIXTIME(1618483100, '%Y-%m-%d %H:%i:%s') FROM DUAL; SELECT * FROM mysql.user \\G ","date":"2024-05-18","objectID":"/posts/f0ce569/:22:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"加密和系统函数 -- 演示加密函数和系统函数 -- USER() 查询用户 -- 可以查看登录到mysql的有哪些用户，以及登录的IP SELECT USER() FROM DUAL; -- 返回 用户@IP地址 -- DATABASE() 查询当前使用数据库名称 SELECT DATABASE(); -- MD5(str) 为字符串算出一个 MD5 32的字符串，常用(用户密码)加密 -- root 密码是 timerring -\u003e 加密md5 -\u003e 在数据库中存放的是加密后的密码 SELECT MD5('timerring') FROM DUAL; SELECT LENGTH(MD5('timerring')) FROM DUAL; -- 演示用户表，存放密码时，是md5 CREATE TABLE timerring_user (id INT , `name` VARCHAR(32) NOT NULL DEFAULT '', pwd CHAR(32) NOT NULL DEFAULT ''); INSERT INTO timerring_user VALUES(100, '谈莫瑞', MD5('timerring')); SELECT * FROM timerring_user; SELECT * FROM timerring_user -- SQL注入问题 WHERE `name`='谈莫瑞' AND pwd = MD5('timerring') -- PASSWORD(str) -- 加密函数, MySQL数据库的用户密码就是 PASSWORD函数加密 SELECT PASSWORD('timerring') FROM DUAL; -- 数据库的 *81220D972A52D4C51BB1C37518A2613706220DAC -- select * from mysql.user \\G 从原文密码str 计算并返回密码字符串 -- 通常用于对mysql数据库的用户密码加密 -- mysql.user 表示 数据库.表 SELECT * FROM mysql.user ","date":"2024-05-18","objectID":"/posts/f0ce569/:23:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"流程控制函数 # 演示流程控制语句 # IF(expr1,expr2,expr3) 如果expr1为True ,则返回 expr2 否则返回 expr3 SELECT IF(TRUE, '北京', '上海') FROM DUAL; # IFNULL(expr1,expr2) 如果expr1不为空NULL,则返回expr1,否则返回expr2 SELECT IFNULL( NULL, '教育') FROM DUAL; # SELECT CASE WHEN expr1 THEN expr2 WHEN expr3 THEN expr4 ELSE expr5 END; [类似多重分支.] # 如果expr1 为TRUE,则返回expr2,如果expr2 为t, 返回 expr4, 否则返回 expr5 SELECT CASE WHEN TRUE THEN 'jack' -- jack WHEN FALSE THEN 'tom' ELSE 'mary' END -- 1. 查询emp 表, 如果 comm 是null , 则显示0.0 -- 老师说明，判断是否为null 要使用 is null, 判断不为空 使用 is not SELECT ename, IF(comm IS NULL , 0.0, comm) FROM emp; SELECT ename, IFNULL(comm, 0.0) FROM emp; -- 2. 如果emp 表的 job 是 CLERK 则显示 职员， 如果是 MANAGER 则显示经理 -- 如果是 SALESMAN 则显示 销售人员，其它正常显示 SELECT ename, (SELECT CASE WHEN job = 'CLERK' THEN '职员' WHEN job = 'MANAGER' THEN '经理' WHEN job = 'SALESMAN' THEN '销售人员' ELSE job END) AS 'job' FROM emp; SELECT * FROM emp; SELECT * FROM dept; SELECT * FROM salgrade; ","date":"2024-05-18","objectID":"/posts/f0ce569/:24:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"mysql 表查询–加强 ","date":"2024-05-18","objectID":"/posts/f0ce569/:25:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"介绍 -- 查询加强 -- ■ 使用where子句 -- ?如何查找1992.1.1后入职的员工 -- 老师说明： 在mysql中,日期类型可以直接比较, 需要注意格式 SELECT * FROM emp WHERE hiredate \u003e '1992-01-01' -- ■ 如何使用like操作符(模糊) -- %: 表示0到多个任意字符 _: 表示单个任意字符 -- ?如何显示首字符为S的员工姓名和工资 SELECT ename, sal FROM emp WHERE ename LIKE 'S%' -- ?如何显示第三个字符为大写O的所有员工的姓名和工资 SELECT ename, sal FROM emp WHERE ename LIKE '__O%' -- ■ 如何显示没有上级的雇员的情况 SELECT * FROM emp WHERE mgr IS NULL; -- ■ 查询表结构 DESC emp -- 使用order by子句 -- ?如何按照工资的从低到高的顺序[升序]，显示雇员的信息 SELECT * FROM emp ORDER BY sal -- ?按照部门号升序而雇员的工资降序排列 , 显示雇员信息 SELECT * FROM emp ORDER BY deptno ASC , sal DESC; ","date":"2024-05-18","objectID":"/posts/f0ce569/:25:1","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"分页查询 基本语法: select.... limit start, rows 表示从start+1行开始取,取出rows行, start 从0开始计算 -- 分页查询 -- 按雇员的id号升序取出， 每页显示3条记录，请分别显示 第1页，第2页，第3页 -- 第1页 SELECT * FROM emp ORDER BY empno LIMIT 0, 3; -- 第2页 SELECT * FROM emp ORDER BY empno LIMIT 3, 3; -- 第3页 SELECT * FROM emp ORDER BY empno LIMIT 6, 3; -- 推导一个公式 SELECT * FROM emp ORDER BY empno LIMIT 每页显示记录数 * (第几页-1) , 每页显示记录数 -- 测试 SELECT job, COUNT(*) FROM emp GROUP BY job; -- 显示雇员总数，以及获得补助的雇员数 SELECT COUNT(*) FROM emp WHERE mgr IS NOT NULL; SELECT MAX(sal) - MIN(sal) FROM emp; ","date":"2024-05-18","objectID":"/posts/f0ce569/:25:2","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"使用分组函数和分组子句 -- 增强group by 的使用 -- (1) 显示每种岗位的雇员总数、平均工资。 SELECT COUNT(*), AVG(sal), job FROM emp GROUP BY job; -- (2) 显示雇员总数，以及获得补助的雇员数。 -- 思路: 获得补助的雇员数 就是 comm 列为非null, 就是count(列)，如果该列的值为null, 是不会统计 , SQL 非常灵活，需要我们动脑筋. SELECT COUNT(*), COUNT(comm) FROM emp -- 老师的扩展要求：统计没有获得补助的雇员数 SELECT COUNT(*), COUNT(IF(comm IS NULL, 1, NULL)) FROM emp SELECT COUNT(*), COUNT(*) - COUNT(comm) FROM emp -- (3) 显示管理者的总人数。小技巧:尝试写-\u003e修改-\u003e尝试[正确的] SELECT COUNT(DISTINCT mgr) FROM emp; -- (4) 显示雇员工资的最大差额。 -- 思路： max(sal) - min(sal) SELECT MAX(sal) - MIN(sal) FROM emp; SELECT * FROM e mp; select * from dept; -- 应用案例：请统计各个部门group by 的平均工资 avg， -- 并且是大于1000的 having，并且按照平均工资从高到低排序， order by -- 取出前两行记录 limit 0, 2 SELECT deptno, AVG(sal) AS avg_sal FROM emp GROUP BY deptno HAVING avg_sal \u003e 1000 ORDER BY avg_sal DESC LIMIT 0,2 ","date":"2024-05-18","objectID":"/posts/f0ce569/:25:3","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"数据分组的总结 如果select语句同时包含有group by ,having , limitorder by那么他们的顺序是group by , having , orderby, limit ","date":"2024-05-18","objectID":"/posts/f0ce569/:25:4","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"mysql 多表查询 ","date":"2024-05-18","objectID":"/posts/f0ce569/:26:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"多表查询练习 在默认情况下:当两个表查询时，规则 从第一张表中，取出一行和第二张表的每一行进行组合,返回结果[含有两张表的所有列]. 一共返回的记录数第一张表行数*第二张表的行数（笛卡尔积） -- 多表查询 -- ?显示雇员名,雇员工资及所在部门的名字 【笛卡尔集】 /* 1. 雇员名,雇员工资 来自 emp表 2. 部门的名字 来自 dept表 3. 需求对 emp 和 dept查询 ename,sal,dname,deptno 4. 当我们需要指定显示某个表的列是，需要 表.列表 */ SELECT ename,sal,dname,emp.deptno FROM emp, dept WHERE emp.deptno = dept.deptno select * from emp; select * from dept; select * from salgrade; -- 小技巧：多表查询的条件不能少于 表的个数-1, 否则会出现笛卡尔集 -- ?如何显示部门号为10的部门名、员工名和工资 -- 重复的deptno要标清是哪个表的 SELECT ename,sal,dname,emp.deptno FROM emp, dept WHERE emp.deptno = dept.deptno and emp.deptno = 10 -- ?显示各个员工的姓名，工资，及其工资的级别 -- 思路 姓名，工资 来自 emp 13 -- 工资级别 salgrade 5 -- 写sql , 先写一个简单，然后加入过滤条件... select ename, sal, grade from emp , salgrade where sal between losal and hisal; ","date":"2024-05-18","objectID":"/posts/f0ce569/:26:1","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"自连接 自连接是指在同一张表的连接查询[将同一张表看做两张表]。 -- 多表查询的 自连接 -- 思考题: 显示公司员工名字和他的上级的名字 -- 老韩分析： 员工名字 在emp, 上级的名字的名字 emp -- 员工和上级是通过 emp 表的 mgr 列关联 -- 这里老师小结： -- 自连接的特点 1. 把同一张表当做两张表使用 -- 2. 需要给表取别名 表名 表别名 -- 3. 列名不明确，可以指定列的别名 列名 as 列的别名 SELECT worker.ename AS '职员名' , boss.ename AS '上级名' FROM emp worker, emp boss -- 同一张表用不同的别名 WHERE worker.mgr = boss.empno; SELECT * FROM emp; ","date":"2024-05-18","objectID":"/posts/f0ce569/:26:2","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"mysql 表子查询 ","date":"2024-05-18","objectID":"/posts/f0ce569/:27:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"什么是子查询 子查询是指嵌入在其它 sql 语句中的select 语句,也叫嵌套查询 ","date":"2024-05-18","objectID":"/posts/f0ce569/:27:1","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"单行子查询 单行子查询是指只返回一行数据的子查询语句 ","date":"2024-05-18","objectID":"/posts/f0ce569/:27:2","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"多行子查询 多行子查询指返回多行数据的子查询 使用关键字in -- 子查询的演示 -- 请思考：如何显示与SMITH同一部门的所有员工? /* 1. 先查询到 SMITH的部门号得到 2. 把上面的select 语句当做一个子查询来使用 */ SELECT deptno FROM emp WHERE ename = 'SMITH' -- 下面的答案. SELECT * FROM emp WHERE deptno = ( SELECT deptno FROM emp WHERE ename = 'SMITH' ) -- 课堂练习:如何查询和部门10的工作相同的雇员的 -- 名字、岗位、工资、部门号, 但是不含10号部门自己的雇员. /* 1. 查询到10号部门有哪些工作 2. 把上面查询的结果当做子查询使用 */ select distinct job from emp where deptno = 10; -- 下面语句完整 select ename, job, sal, deptno from emp where job in ( SELECT DISTINCT job FROM emp WHERE deptno = 10 ) and deptno \u003c\u003e 10 ","date":"2024-05-18","objectID":"/posts/f0ce569/:27:3","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"子查询当做临时表使用 可以将子查询当做一张临时表使用 -- 子查询练习 -- 请思考：查找每个部门工资高于本部门平均工资的人的资料 -- 这里要用到数据查询的小技巧，把一个子查询当作一个临时表使用 -- 1. 先得到每个部门的 部门号和 对应的平均工资 SELECT deptno, AVG(sal) AS avg_sal FROM emp GROUP BY deptno -- 2. 把上面的结果当做子查询，作为temp表, 和 emp 进行多表查询 SELECT ename, sal, temp.avg_sal, emp.deptno FROM emp, ( SELECT deptno, AVG(sal) AS avg_sal FROM emp GROUP BY deptno ) temp where emp.deptno = temp.deptno and emp.sal \u003e temp.avg_sal -- 查找每个部门工资最高的人的详细资料 SELECT ename, sal, temp.max_sal, emp.deptno FROM emp, ( SELECT deptno, max(sal) AS max_sal FROM emp GROUP BY deptno ) temp WHERE emp.deptno = temp.deptno AND emp.sal = temp.max_sal -- 查询每个部门的信息(包括：部门名,编号,地址)和人员数量,我们一起完成。 -- 1. 部门名,编号,地址 来自 dept表 -- 2. 各个部门的人员数量 -》 构建一个临时表 select count(*), deptno from emp group by deptno; select dname, dept.deptno, loc , tmp.per_num as '人数' from dept, ( SELECT COUNT(*) as per_num, deptno FROM emp GROUP BY deptno ) tmp where tmp.deptno = dept.deptno -- 还有一种写法 表.* 表示将该表所有列都显示出来, 可以简化sql语句 -- 在多表查询中，当多个表的列不重复时，才可以直接写列名 SELECT tmp.* , dname, loc FROM dept, ( SELECT COUNT(*) AS per_num, deptno FROM emp GROUP BY deptno ) tmp WHERE tmp.deptno = dept.deptno ","date":"2024-05-18","objectID":"/posts/f0ce569/:27:4","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"在多行子查询中使用 all 操作符 ","date":"2024-05-18","objectID":"/posts/f0ce569/:27:5","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"在多行子查询中使用 any 操作符 -- all 和 any的使用 -- 请思考:显示工资比部门30的所有员工的工资高的员工的姓名、工资和部门号 SELECT ename, sal, deptno FROM emp WHERE sal \u003e ALL( SELECT sal FROM emp WHERE deptno = 30 ) -- 可以这样写 SELECT ename, sal, deptno FROM emp WHERE sal \u003e ( SELECT MAX(sal) FROM emp WHERE deptno = 30 ) -- 请思考:如何显示工资比部门30的其中一个员工的工资高的员工的姓名、工资和部门号 SELECT ename, sal, deptno FROM emp WHERE sal \u003e any( SELECT sal FROM emp WHERE deptno = 30 ) SELECT ename, sal, deptno FROM emp WHERE sal \u003e ( SELECT min(sal) FROM emp WHERE deptno = 30 ) -- 查询ecshop中各个类别中，价格最高的商品 -- 查询 商品表 -- 先得到 各个类别中，价格最高的商品 max + group by cat_id, 当做临时表 -- 把子查询当做一张临时表可以解决很多很多复杂的查询 select cat_id , max(shop_price) from ecs_goods group by cat_id -- 这个最后答案 select goods_id, ecs_goods.cat_id, goods_name, shop_price from ( SELECT cat_id , MAX(shop_price) as max_price FROM ecs_goods GROUP BY cat_id ) temp , ecs_goods where temp.cat_id = ecs_goods.cat_id and temp.max_price = ecs_goods.shop_price ","date":"2024-05-18","objectID":"/posts/f0ce569/:27:6","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"多列子查询 多列子查序则是指查询返回多个列数据的子查询语句 -- 多列子查询 -- 请思考如何查询与allen的部门和岗位完全相同的所有雇员(并且不含allen本人) -- (字段1， 字段2 ...) = (select 字段 1，字段2 from 。。。。) -- 分析: 1. 得到smith的部门和岗位 SELECT deptno , job FROM emp WHERE ename = 'ALLEN' -- 分析: 2 把上面的查询当做子查询来使用，并且使用多列子查询的语法进行匹配 SELECT * FROM emp WHERE (deptno , job) = ( SELECT deptno , job FROM emp WHERE ename = 'ALLEN' ) AND ename != 'ALLEN' -- 请查询 和宋江数学，英语，语文 -- 成绩 完全相同的学生 SELECT * FROM student WHERE (math, english, chinese) = ( SELECT math, english, chinese FROM student WHERE `name` = '宋江' ) SELECT * FROM student; ","date":"2024-05-18","objectID":"/posts/f0ce569/:27:7","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"在from 子句中使用子查询 -- 子查询练习 -- 请思考：查找每个部门工资高于本部门平均工资的人的资料 -- 这里要用到数据查询的小技巧，把一个子查询当作一个临时表使用 -- 1. 先得到每个部门的 部门号和 对应的平均工资 SELECT deptno, AVG(sal) AS avg_sal FROM emp GROUP BY deptno -- 2. 把上面的结果当做子查询, 和 emp 进行多表查询 -- SELECT ename, sal, temp.avg_sal, emp.deptno FROM emp, ( SELECT deptno, AVG(sal) AS avg_sal FROM emp GROUP BY deptno ) temp where emp.deptno = temp.deptno and emp.sal \u003e temp.avg_sal -- 查找每个部门工资最高的人的详细资料 SELECT ename, sal, temp.max_sal, emp.deptno FROM emp, ( SELECT deptno, max(sal) AS max_sal FROM emp GROUP BY deptno ) temp WHERE emp.deptno = temp.deptno AND emp.sal = temp.max_sal -- 查询每个部门的信息(包括：部门名,编号,地址)和人员数量,我们一起完成。 -- 1. 部门名,编号,地址 来自 dept表 -- 2. 各个部门的人员数量 -》 构建一个临时表 select count(*), deptno from emp group by deptno; select dname, dept.deptno, loc , tmp.per_num as '人数' from dept, ( SELECT COUNT(*) as per_num, deptno FROM emp GROUP BY deptno ) tmp where tmp.deptno = dept.deptno -- 还有一种写法 表.* 表示将该表所有列都显示出来, 可以简化sql语句 -- 在多表查询中，当多个表的列不重复时，才可以直接写列名 SELECT tmp.* , dname, loc FROM dept, ( SELECT COUNT(*) AS per_num, deptno FROM emp GROUP BY deptno ) tmp WHERE tmp.deptno = dept.deptno ","date":"2024-05-18","objectID":"/posts/f0ce569/:27:8","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"表复制 ","date":"2024-05-18","objectID":"/posts/f0ce569/:28:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"自我复制数据(蠕虫复制) 有时，为了对某个sql语句进行效率测试，我们需要海量数据时，可以使用此法为表创建海量数据。 -- 表的复制 -- 为了对某个sql语句进行效率测试，我们需要海量数据时，可以使用此法为表创建海量数据 CREATE TABLE my_tab01 ( id INT, `name` VARCHAR(32), sal DOUBLE, job VARCHAR(32), deptno INT); DESC my_tab01 SELECT * FROM my_tab01; -- 演示如何自我复制 -- 1. 先把emp 表的记录复制到 my_tab01 INSERT INTO my_tab01 (id, `name`, sal, job,deptno) SELECT empno, ename, sal, job, deptno FROM emp; -- 2. 自我复制 INSERT INTO my_tab01 SELECT * FROM my_tab01; SELECT COUNT(*) FROM my_tab01; -- 如何删除掉一张表重复记录 -- 1. 先创建一张表 my_tab02, -- 2. 让 my_tab02 有重复的记录 CREATE TABLE my_tab02 LIKE emp; -- 这个语句 把emp表的结构(列)，复制到my_tab02 desc my_tab02; insert into my_tab02 select * from emp; select * from my_tab02; -- 3. 考虑去重 my_tab02的记录 /* 思路 (1) 先创建一张临时表 my_tmp , 该表的结构和 my_tab02一样 (2) 把my_tmp 的记录 通过 distinct 关键字 处理后 把记录复制到 my_tmp (3) 清除掉 my_tab02 记录 (4) 把 my_tmp 表的记录复制到 my_tab02 (5) drop 掉 临时表my_tmp */ -- (1) 先创建一张临时表 my_tmp , 该表的结构和 my_tab02一样 create table my_tmp like my_tab02 -- (2) 把my_tmp 的记录 通过 distinct 关键字 处理后 把记录复制到 my_tmp insert into my_tmp select distinct * from my_tab02; -- (3) 清除掉 my_tab02 记录 delete from my_tab02; -- (4) 把 my_tmp 表的记录复制到 my_tab02 insert into my_tab02 select * from my_tmp; -- (5) drop 掉 临时表my_tmp drop table my_tmp; select * from my_tab02; ","date":"2024-05-18","objectID":"/posts/f0ce569/:28:1","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"合并查询 ","date":"2024-05-18","objectID":"/posts/f0ce569/:29:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"介绍 有时在实际应用中，为了合并多个 select 语句的结果，可以使用集合操作符号 union , union all。 union all：该操作符用于取得两个结果集的并集。当使用该操作符时，不会取消重复行。 union：该操作赋与union all相似,但是会自动去掉结果集中重复行 -- 合并查询 SELECT ename,sal,job FROM emp WHERE sal\u003e2500 -- 5 SELECT ename,sal,job FROM emp WHERE job='MANAGER' -- 3 -- union all 就是将两个查询结果合并，不会去重 SELECT ename,sal,job FROM emp WHERE sal\u003e2500 -- 5 UNION ALL SELECT ename,sal,job FROM emp WHERE job='MANAGER' -- 3 -- union 就是将两个查询结果合并，会去重 SELECT ename,sal,job FROM emp WHERE sal\u003e2500 -- 5 UNION SELECT ename,sal,job FROM emp WHERE job='MANAGER' -- 3 ","date":"2024-05-18","objectID":"/posts/f0ce569/:29:1","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"mysql 表外连接 前面我们学习的查询，是利用where子句对两张表或者多张表，形成的笛卡尔积进行筛选,根据关联条件，显示所有匹配的记录，匹配不上的，不显示。比如:列出部门名称和这些部门的员工名称和工作，同时要求显示出那些没有员工的部门。 ","date":"2024-05-18","objectID":"/posts/f0ce569/:30:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"外连接 左外连接(如果左侧的表完全显示我们就说是左外连接) 右外连接(如果右侧的表完全显示我们就说是右外连接) 使用左连接(显示所有人的成绩，如果没有成绩，也要显示该人的姓名和id号,成绩显示为空)select .. from表1 left join表2 on条件[表1:就是左表表2:就是右表]。 使用右外连接(显示所有成绩,如果没有名字匹配,显示空) select .. from 表1 right join表2 on条件[表1:就是左表表2:就是右表] -- 外连接 -- 比如：列出部门名称和这些部门的员工名称和工作， -- 同时要求 显示出那些没有员工的部门。 -- 使用我们学习过的多表查询的SQL， 看看效果如何? SELECT dname, ename, job FROM emp, dept WHERE emp.deptno = dept.deptno ORDER BY dname SELECT * FROM dept; SELECT * FROM emp; -- 创建 stu /* id name 1 Jack 2 Tom 3 Kity 4 nono */ CREATE TABLE stu ( id INT, `name` VARCHAR(32)); INSERT INTO stu VALUES(1, 'jack'),(2,'tom'),(3, 'kity'),(4, 'nono'); SELECT * FROM stu; -- 创建 exam /* id grade 1 56 2 76 11 8 */ CREATE TABLE exam( id INT, grade INT); INSERT INTO exam VALUES(1, 56),(2,76),(11, 8); SELECT * FROM exam; -- 使用左连接 -- （显示所有人的成绩，如果没有成绩，也要显示该人的姓名和id号,成绩显示为空） SELECT `name`, stu.id, grade FROM stu, exam WHERE stu.id = exam.id; -- 改成左外连接 SELECT `name`, stu.id, grade FROM stu LEFT JOIN exam ON stu.id = exam.id; -- 使用右外连接（显示所有成绩，如果没有名字匹配，显示空) -- 即：右边的表(exam) 和左表没有匹配的记录，也会把右表的记录显示出来 SELECT `name`, stu.id, grade FROM stu RIGHT JOIN exam ON stu.id = exam.id; -- 列出部门名称和这些部门的员工信息(名字和工作)， -- 同时列出那些没有员工的部门名。5min -- 使用左外连接实现 SELECT dname, ename, job FROM dept LEFT JOIN emp ON dept.deptno = emp.deptno -- 使用右外连接实现 SELECT dname, ename, job FROM emp RIGHT JOIN dept ON dept.deptno = emp.deptno ","date":"2024-05-18","objectID":"/posts/f0ce569/:30:1","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"mysql 约束 ","date":"2024-05-18","objectID":"/posts/f0ce569/:31:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"基本介绍 约束用于确保数据库的数据满足特定的商业规则。在mysql中，约束包括: not null、unique, primary key, foreign key, 和 check 五种. ","date":"2024-05-18","objectID":"/posts/f0ce569/:31:1","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"primary key(主键) 字段名 字段类型 primary key （表示该字段为主键） 用于唯一的标示表行的数据,当定义主键约束后，该列不能重复 primary key不能重复而且不能为null. 一张表最多只能有一个主键,但可以是复合主键 主键的指定方式有两种 直接在字段名后指定:字段名primakry key 在表定义最后写primary key(列名); 使用 desc 表名，可以看到primary key的情况。 在实际开发中，每个表往往都会设计一个主键。 -- 主键使用 -- id name email CREATE TABLE t17 (id INT PRIMARY KEY, -- 表示id列是主键 `name` VARCHAR(32), email VARCHAR(32)); -- 主键列的值是不可以重复 INSERT INTO t17 VALUES(1, 'jack', 'jack@sohu.com'); INSERT INTO t17 VALUES(2, 'tom', 'tom@sohu.com'); INSERT INTO t17 VALUES(1, 'hsp', 'hsp@sohu.com'); -- 报错 SELECT * FROM t17; -- 主键使用的细节讨论 -- primary key不能重复而且不能为 null。 INSERT INTO t17 VALUES(NULL, 'hsp', 'hsp@sohu.com'); -- 一张表最多只能有一个主键, 但可以是复合主键(比如 id+name) CREATE TABLE t18 (id INT PRIMARY KEY, -- 表示id列是主键 `name` VARCHAR(32), PRIMARY KEY -- 错误的 email VARCHAR(32)); -- 演示复合主键 (id 和 name 做成复合主键) CREATE TABLE t18 (id INT , `name` VARCHAR(32), email VARCHAR(32), PRIMARY KEY (id, `name`) -- 这里就是复合主键 ); INSERT INTO t18 VALUES(1, 'tom', 'tom@sohu.com'); INSERT INTO t18 VALUES(1, 'jack', 'jack@sohu.com'); INSERT INTO t18 VALUES(1, 'tom', 'xx@sohu.com'); -- 这里就违反了复合主键 SELECT * FROM t18; -- 主键的指定方式 有两种 -- 1. 直接在字段名后指定：字段名 primakry key -- 2. 在表定义最后写 primary key(列名); CREATE TABLE t19 (id INT , `name` VARCHAR(32) PRIMARY KEY, email VARCHAR(32) ); CREATE TABLE t20 (id INT , `name` VARCHAR(32) , email VARCHAR(32), PRIMARY KEY(`name`) -- 在表定义最后写 primary key(列名) ); -- 使用desc 表名，可以看到primary key的情况 DESC t20 -- 查看 t20表的结果，显示约束的情况 DESC t18 ","date":"2024-05-18","objectID":"/posts/f0ce569/:31:2","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"not null(非空) 如果在列上定义了not null, 那么当插入数据时，必须为列提供数据。 字段名 字段类型 not null ","date":"2024-05-18","objectID":"/posts/f0ce569/:31:3","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"unique(唯一) 当定义了唯一约束后，该列值是不能重复的。 字段名 字段类型 unique 如果没有指定not null，则unique字段可以有多个null 一张表可以有多个unique字段 -- unique的使用 CREATE TABLE t21 (id INT UNIQUE , -- 表示 id 列是不可以重复的. `name` VARCHAR(32) , email VARCHAR(32) ); INSERT INTO t21 VALUES(1, 'jack', 'jack@sohu.com'); INSERT INTO t21 VALUES(1, 'tom', 'tom@sohu.com'); -- unqiue使用细节 -- 1. 如果没有指定 not null , 则 unique 字段可以有多个null -- 如果一个列(字段)， 是 unique not null 使用效果类似 primary key INSERT INTO t21 VALUES(NULL, 'tom', 'tom@sohu.com'); SELECT * FROM t21; -- 2. 一张表可以有多个unique字段 CREATE TABLE t22 (id INT UNIQUE , -- 表示 id 列是不可以重复的. `name` VARCHAR(32) UNIQUE , -- 表示name不可以重复 email VARCHAR(32) ); DESC t22 ","date":"2024-05-18","objectID":"/posts/f0ce569/:31:4","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"foreign key(外键) 用于定义主表和从表之间的关系: 外键约束要定义在从表上，主表则必须具有主键约束或是unique约束, 当定义外键约束后，要求外键列数据必须在主表的主键列存在或是为null(学生/班级图示)。 -- 外键演示 -- 创建 主表 my_class CREATE TABLE my_class ( id INT PRIMARY KEY , -- 班级编号 `name` VARCHAR(32) NOT NULL DEFAULT ''); -- 创建 从表 my_stu CREATE TABLE my_stu ( id INT PRIMARY KEY , -- 学生编号 `name` VARCHAR(32) NOT NULL DEFAULT '', class_id INT , -- 学生所在班级的编号 -- 下面指定外键关系 FOREIGN KEY (class_id) REFERENCES my_class(id)) -- 测试数据 INSERT INTO my_class VALUES(100, 'java'), (200, 'web'); INSERT INTO my_class VALUES(300, 'php'); SELECT * FROM my_class; INSERT INTO my_stu VALUES(1, 'tom', 100); INSERT INTO my_stu VALUES(2, 'jack', 200); INSERT INTO my_stu VALUES(3, 'hsp', 300); INSERT INTO my_stu VALUES(4, 'mary', 400); -- 这里会失败...因为400班级不存在 INSERT INTO my_stu VALUES(5, 'king', NULL); -- 可以, 外键 没有写 not null SELECT * FROM my_class; -- 一旦建立主外键的关系，数据不能随意删除了 DELETE FROM my_class WHERE id = 100; ","date":"2024-05-18","objectID":"/posts/f0ce569/:31:5","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"check 用于强制行数据必须满足的条件,假定在sal列上定义了check约束,并要求sal列值在1000 ~2000之间，如果不在1000~2000之间就会提示出错。 提示:oracle和 sql server 均支持check ,但是mysql5.7目前还不支持check ,只做语法校验，但不会生效。 -- 演示check的使用 -- mysql5.7目前还不支持check ,只做语法校验，但不会生效 -- 了解 -- 学习 oracle, sql server, 这两个数据库是真的生效. -- 测试 CREATE TABLE t23 ( id INT PRIMARY KEY, `name` VARCHAR(32) , sex VARCHAR(6) CHECK (sex IN('man','woman')), sal DOUBLE CHECK ( sal \u003e 1000 AND sal \u003c 2000) ); -- 添加数据 INSERT INTO t23 VALUES(1, 'jack', 'mid', 1); SELECT * FROM t23; ","date":"2024-05-18","objectID":"/posts/f0ce569/:31:6","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"商店售货系统表设计案例 -- 使用约束的课堂练习 CREATE DATABASE shop_db; -- 现有一个商店的数据库shop_db，记录客户及其购物情况，由下面三个表组成： -- 商品goods（商品号goods_id，商品名goods_name，单价unitprice，商品类别category，供应商provider); -- 客户customer（客户号customer_id,姓名name,住址address,电邮email性别sex,身份证card_Id); -- 购买purchase（购买订单号order_id，客户号customer_id,商品号goods_id,购买数量nums); -- 1 建表，在定义中要求声明 [进行合理设计]： -- (1)每个表的主外键； -- (2)客户的姓名不能为空值； -- (3)电邮不能够重复; -- (4)客户的性别[男|女] check 枚举.. -- (5)单价unitprice 在 1.0 - 9999.99 之间 check -- 商品goods CREATE TABLE goods ( goods_id INT PRIMARY KEY, goods_name VARCHAR(64) NOT NULL DEFAULT '', unitprice DECIMAL(10,2) NOT NULL DEFAULT 0 CHECK (unitprice \u003e= 1.0 AND unitprice \u003c= 9999.99), category INT NOT NULL DEFAULT 0, provider VARCHAR(64) NOT NULL DEFAULT ''); -- 客户customer（客户号customer_id,姓名name,住址address,电邮email性别sex, -- 身份证card_Id); CREATE TABLE customer( customer_id CHAR(8) PRIMARY KEY, -- 程序员自己决定 `name` VARCHAR(64) NOT NULL DEFAULT '', address VARCHAR(64) NOT NULL DEFAULT '', email VARCHAR(64) UNIQUE NOT NULL, sex ENUM('男','女') NOT NULL , -- 这里老师使用的枚举类型, 是生效 card_Id CHAR(18)); -- 购买purchase（购买订单号order_id，客户号customer_id,商品号goods_id, -- 购买数量nums); CREATE TABLE purchase( order_id INT UNSIGNED PRIMARY KEY, customer_id CHAR(8) NOT NULL DEFAULT '', -- 外键约束在后 goods_id INT NOT NULL DEFAULT 0 , -- 外键约束在后 nums INT NOT NULL DEFAULT 0, FOREIGN KEY (customer_id) REFERENCES customer(customer_id), FOREIGN KEY (goods_id) REFERENCES goods(goods_id)); DESC goods; DESC customer; DESC purchase; ","date":"2024-05-18","objectID":"/posts/f0ce569/:31:7","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"自增长 ","date":"2024-05-18","objectID":"/posts/f0ce569/:32:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"自增长基本介绍 在某张表中，存在一个id列(整数),我们希望在添加记录的时候.该列从1开始,自动的增长，怎么处理? ","date":"2024-05-18","objectID":"/posts/f0ce569/:32:1","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"自增长使用细节 一般来说自增长是和primary key配合使用的 自增长也可以单独使用[但是需要配合一个unique] 自增长修饰的字段为整数型的(虽然小数也可以但是非常非常少这样使用) 自增长默认从1开始，你也可以通过如下命令修改alter table 表名auto_increment = 新的开始值; 如果你添加数据时，给自增长字段(列)指定的有值，则以指定的值为准,**如果指定了自增长，一般来说，就按照自增长的规则（从指定的值开始，再自增长）**来添加数据 -- 演示自增长的使用 -- 创建表 CREATE TABLE t24 (id INT PRIMARY KEY AUTO_INCREMENT, email VARCHAR(32)NOT NULL DEFAULT '', `name` VARCHAR(32)NOT NULL DEFAULT ''); DESC t24 -- 测试自增长的使用 INSERT INTO t24 VALUES(NULL, 'tom@qq.com', 'tom'); -- 没有给值，自动维护，id自增长 INSERT INTO t24 (email, `name`) VALUES('hsp@sohu.com', 'hsp'); SELECT * FROM t24; -- 修改默认的自增长开始值 ALTER TABLE t25 AUTO_INCREMENT = 100 CREATE TABLE t25 (id INT PRIMARY KEY AUTO_INCREMENT, email VARCHAR(32)NOT NULL DEFAULT '', `name` VARCHAR(32)NOT NULL DEFAULT ''); INSERT INTO t25 VALUES(NULL, 'mary@qq.com', 'mary'); INSERT INTO t25 VALUES(666, 'hsp@qq.com', 'hsp'); SELECT * FROM t25; CREATE DATABASE tmp; CREATE TABLE dept( /*部门表*/ deptno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0, dname VARCHAR(20) NOT NULL DEFAULT \"\", loc VARCHAR(13) NOT NULL DEFAULT \"\" ) ; #创建表EMP雇员 CREATE TABLE emp (empno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0, /*编号*/ ename VARCHAR(20) NOT NULL DEFAULT \"\", /*名字*/ job VARCHAR(9) NOT NULL DEFAULT \"\",/*工作*/ mgr MEDIUMINT UNSIGNED NOT NULL DEFAULT 0,/*上级编号*/ hiredate DATE NOT NULL,/*入职时间*/ sal DECIMAL(7,2) NOT NULL,/*薪水*/ comm DECIMAL(7,2) NOT NULL,/*红利*/ deptno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0 /*部门编号*/ ) ; #工资级别表 CREATE TABLE salgrade ( grade MEDIUMINT UNSIGNED NOT NULL DEFAULT 0, losal DECIMAL(17,2) NOT NULL, hisal DECIMAL(17,2) NOT NULL ); #测试数据 INSERT INTO salgrade VALUES (1,700,1200); INSERT INTO salgrade VALUES (2,1201,1400); INSERT INTO salgrade VALUES (3,1401,2000); INSERT INTO salgrade VALUES (4,2001,3000); INSERT INTO salgrade VALUES (5,3001,9999); ","date":"2024-05-18","objectID":"/posts/f0ce569/:32:2","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"mysql 索引 ","date":"2024-05-18","objectID":"/posts/f0ce569/:33:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"索引快速入门 提高数据库性能，索引是最物美价廉的东西了。不用加内存，不用改程序，不用调sql，查询速度就可能提高百倍干倍。 CREATE INDEX ename_index ON emp (ename) -- 在 ename 上创建索引 -- 创建测试数据库 tmp CREATE DATABASE tmp; CREATE TABLE dept( /*部门表*/ deptno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0, dname VARCHAR(20) NOT NULL DEFAULT \"\", loc VARCHAR(13) NOT NULL DEFAULT \"\" ) ; #创建表EMP雇员 CREATE TABLE emp (empno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0, /*编号*/ ename VARCHAR(20) NOT NULL DEFAULT \"\", /*名字*/ job VARCHAR(9) NOT NULL DEFAULT \"\",/*工作*/ mgr MEDIUMINT UNSIGNED NOT NULL DEFAULT 0,/*上级编号*/ hiredate DATE NOT NULL,/*入职时间*/ sal DECIMAL(7,2) NOT NULL,/*薪水*/ comm DECIMAL(7,2) NOT NULL,/*红利*/ deptno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0 /*部门编号*/ ) ; #工资级别表 CREATE TABLE salgrade ( grade MEDIUMINT UNSIGNED NOT NULL DEFAULT 0, losal DECIMAL(17,2) NOT NULL, hisal DECIMAL(17,2) NOT NULL ); #测试数据 INSERT INTO salgrade VALUES (1,700,1200); INSERT INTO salgrade VALUES (2,1201,1400); INSERT INTO salgrade VALUES (3,1401,2000); INSERT INTO salgrade VALUES (4,2001,3000); INSERT INTO salgrade VALUES (5,3001,9999); DELIMITER $$ #创建一个函数，名字 rand_string，可以随机返回我指定的个数字符串 CREATE FUNCTION rand_string(n INT) RETURNS VARCHAR(255) #该函数会返回一个字符串 BEGIN #定义了一个变量 chars_str， 类型 varchar(100) #默认给 chars_str 初始值 'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ' DECLARE chars_str VARCHAR(100) DEFAULT 'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ'; DECLARE return_str VARCHAR(255) DEFAULT ''; DECLARE i INT DEFAULT 0; WHILE i \u003c n DO # concat 函数 : 连接函数mysql函数 SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1)); SET i = i + 1; END WHILE; RETURN return_str; END $$ #这里我们又自定了一个函数,返回一个随机的部门号 CREATE FUNCTION rand_num( ) RETURNS INT(5) BEGIN DECLARE i INT DEFAULT 0; SET i = FLOOR(10+RAND()*500); RETURN i; END $$ #创建一个存储过程， 可以添加雇员 CREATE PROCEDURE insert_emp(IN START INT(10),IN max_num INT(10)) BEGIN DECLARE i INT DEFAULT 0; #set autocommit =0 把autocommit设置成0 #autocommit = 0 含义: 不要自动提交 SET autocommit = 0; #默认不提交sql语句 REPEAT SET i = i + 1; #通过前面写的函数随机产生字符串和部门编号，然后加入到emp表 INSERT INTO emp VALUES ((START+i) ,rand_string(6),'SALESMAN',0001,CURDATE(),2000,400,rand_num()); UNTIL i = max_num END REPEAT; #commit整体提交所有sql语句，提高效率 COMMIT; END $$ #添加8000000数据 CALL insert_emp(100001,8000000)$$ #命令结束符，再重新设置为; DELIMITER ; SELECT COUNT(*) FROM emp; -- 在没有创建索引时，我们的查询一条记录 SELECT * FROM emp WHERE empno = 1234567 -- 使用索引来优化一下， 体验索引的牛 -- 在没有创建索引前 , emp.ibd 文件大小 是 524m -- 创建索引后 emp.ibd 文件大小 是 655m [索引本身也会占用空间.] -- 创建ename列索引,emp.ibd 文件大小 是 827m -- empno_index 索引名称 -- ON emp (empno) : 表示在 emp表的 empno列创建索引 CREATE INDEX empno_index ON emp (empno) -- 创建索引后， 查询的速度如何 SELECT * FROM emp WHERE empno = 1234578 -- 0.003s 原来是4.5s -- 创建索引后，只对创建了索引的列有效 SELECT * FROM emp WHERE ename = 'PjDlwy' -- 没有在ename创建索引时，时间4.7s CREATE INDEX ename_index ON emp (ename) -- 在ename上创建索引 ","date":"2024-05-18","objectID":"/posts/f0ce569/:33:1","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"索引的原理 没有索引为什么会慢?因为全表扫描. 使用索引为什么会快?形成一个索引的数据结构，比如二叉树索引（有代价 如下） 磁盘占用 对dml(update delete insert)语句的效率影响 删除或者插入将会对数据结构造成影响，可能会重构。 ","date":"2024-05-18","objectID":"/posts/f0ce569/:33:2","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"索引的类 主键索引，主键自动的为主索引 (类型Primary key) 唯一索引(UNIQUE) 普通索引(INDEX) 全文索引(FULLTEXT)[适用于MyISAM] 一般开发，不使用mysql自带的全文索引,，而是使用: 全文搜索的框架：Solr 和 ElasticSearch ( ES ) create table t1( id int primary key, -- 主键，同时也是索引，称为主键索引. name varchar(32)); create table t2( id int unique, -- id是唯一的，同时也是索引，称为unique索引. ","date":"2024-05-18","objectID":"/posts/f0ce569/:33:3","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"索引使用 1.添加索引( 建小表测试id , name ) create [UNIQUE] index index_name on tbl_name (col_ name [(length)][ASC | DESC],......); alter table table_name ADD INDEX [index_namel (index_col_name,..) 2.添加主键(索引) ALTER TABLE 表名 ADD PRIMARY KEY(列名...); 3.删除索引 DROP INDEX index_name ON tbl_name, alter table table_name drop index index_name; 4.删除主键索引比较特别: alter table t_b drop primary key; 5.查询索引(三种方式) show index(es) from table_name; show keys from table_name; desc table_Name; -- 演示mysql的索引的使用 -- 创建索引 CREATE TABLE t25 ( id INT , `name` VARCHAR(32)); -- 查询表是否有索引 SHOW INDEXES FROM t25; -- 添加索引 -- 添加唯一索引 CREATE UNIQUE INDEX id_index ON t25 (id); -- 添加普通索引方式1 CREATE INDEX id_index ON t25 (id); -- 如何选择 -- 1. 如果某列的值，是不会重复的，则优先考虑使用unique索引, 否则使用普通索引 -- 添加普通索引方式2 ALTER TABLE t25 ADD INDEX id_index (id) -- 添加主键索引 CREATE TABLE t26 ( id INT , `name` VARCHAR(32)); ALTER TABLE t26 ADD PRIMARY KEY (id) SHOW INDEX FROM t25 -- 删除索引 DROP INDEX id_index ON t25 -- 删除主键索引 ALTER TABLE t26 DROP PRIMARY KEY -- 修改索引 ，先删除，在添加新的索引 -- 查询索引 -- 1. 方式 SHOW INDEX FROM t25 -- 2. 方式 SHOW INDEXES FROM t25 -- 3. 方式 SHOW KEYS FROM t25 -- 4 方式 DESC t25 ","date":"2024-05-18","objectID":"/posts/f0ce569/:33:4","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"哪些列上适合使用索引 较频繁的作为查询条件字段应该创建索引 select * from emp where empno = 1 唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件 select * from emp where sex =‘男‘ 更新非常频繁的字段不适合创建索引 select* from emp where logincount = 1 不会出现在WHERE子句中字段不该创建索引 ","date":"2024-05-18","objectID":"/posts/f0ce569/:33:5","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"mysql 事务 ","date":"2024-05-18","objectID":"/posts/f0ce569/:34:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"什么是事务 事务用于保证数据的一致性,它由一组相关的dml（数据操作语言 增删改）语句组成,该组的dml语句要么全部成功，要么全部失败。如: 转账就要用事务来处理,用以保证数据的一致性。 示意图： -- 事务的一个重要的概念和具体操作 -- 演示 -- 1. 创建一张测试表 CREATE TABLE t27 ( id INT, `name` VARCHAR(32)); -- 2. 开始事务 START TRANSACTION -- 3. 设置保存点 SAVEPOINT a -- 执行dml 操作 INSERT INTO t27 VALUES(100, 'tom'); SELECT * FROM t27; SAVEPOINT b -- 执行dml操作 INSERT INTO t27 VALUES(200, 'jack'); -- 回退到 b ROLLBACK TO b -- 继续回退 a ROLLBACK TO a -- 如果这样, 表示直接回退到事务开始的状态. ROLLBACK COMMIT ","date":"2024-05-18","objectID":"/posts/f0ce569/:34:1","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"事务和锁 当执行事务操作时(dml语句), mysql会在表上加锁, 防止其它用户改表的数据，这对用户来讲是非常重要的。 mysql数据厍控制台事务的几个重要操作 start transaction –开始一个事务 savepoint 保存点名–设置保存点 rollback to 保存点名–回退事务 rollback –回退全部事务 commit – 提交事务,所有的操作生效,不能回退 ","date":"2024-05-18","objectID":"/posts/f0ce569/:34:2","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"回退事务 在介绍回退事务前，先介绍一下保存点(savepoint)，保存点是事务中的点，用于取消部分事务，当结束事务时(commit)，会自动的删除该事务所定义的所有保存点当执行回退事务时，通过指定保存点可以回退到指定的点。 ","date":"2024-05-18","objectID":"/posts/f0ce569/:34:3","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"提交事务 使用commit语句可以提交事务.当执行了commit语句子后,会确认事务的变化、结束事务、删除保存点、释放锁，数据生效。当使用commit语句结束事务后,其它会话[其他连接]将可以查着到事务变化后的新数据[所有数据就正式生效.] ","date":"2024-05-18","objectID":"/posts/f0ce569/:34:4","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"事务细节讨论 如果不开始事务，默认情况下，dml操作是自动提交的，不能回滚。 如果开始一个事务，你没有创建保存点.你可以执行 rollback,默认就是回退到你事务开始的状态。 你也可以在这个事务中(还没有提交时),创建多个保存点.比如: savepoint aaa;执行dml , savepoint bbb; 你可以在事务没有提交前,选择回退到哪个保存点。 mysql的事务机制需要innodb的存储引擎才可以使用，myisam不好使。 开始一个事务start transaction 或者可以写 set autocommit=off; -- 讨论 事务细节 -- 1. 如果不开始事务，默认情况下，dml操作是自动提交的，不能回滚 INSERT INTO t27 VALUES(300, 'milan'); -- 自动提交 commit SELECT * FROM t27 -- 2. 如果开始一个事务，你没有创建保存点. 你可以执行 rollback， -- 默认就是回退到你事务开始的状态 START TRANSACTION INSERT INTO t27 VALUES(400, 'king'); INSERT INTO t27 VALUES(500, 'scott'); ROLLBACK -- 表示直接回退到事务开始的的状态 COMMIT; -- 3. 你也可以在这个事务中(还没有提交时), 创建多个保存点.比如: savepoint aaa; -- 执行 dml , savepoint bbb -- 4. 你可以在事务没有提交前，选择回退到哪个保存点 -- 5. InnoDB 存储引擎支持事务 , MyISAM 不支持 -- 6. 开始一个事务 start transaction 或者可以写 set autocommit=off; ","date":"2024-05-18","objectID":"/posts/f0ce569/:34:5","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"mysql 事务隔离级别 ","date":"2024-05-18","objectID":"/posts/f0ce569/:35:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"事务隔离级别介绍 多个连接开启各自事务操作数据库中数据时，数据库系统要负责隔离操作，以保证各个连接在获取数据时的准确性。(通俗解释：每一个事务看到同一张表的数据不一样) 如果不考虑隔离性,可能会引发如下问题: 脏读 不可重复读 幻读 ","date":"2024-05-18","objectID":"/posts/f0ce569/:35:1","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"查看事务隔离级别 脏读(dirty read):当一个事务读取另一个事务尚未提交的改变(update,insert,delete)时,产生脏读。（未commit） 不可重复读(nonrepeatable read):同一查询在同一事务中多次进行，由于其他提交事务所做的修改或删除,每次返回不同的结果集，此时发生不可重复读。（已commit） 幻读(phantom read):同一查询在同一事务中多次进行，由于其他提交事务所做的插入操作，每次返回不同的结果集，此时发生幻读。（已commit） ","date":"2024-05-18","objectID":"/posts/f0ce569/:35:2","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"事务隔离级别 概念: Mysql隔离级别定义了事务与事务之间的隔离程度。 加锁会在其他线程操作数据库时，不操作数据库，自己卡住，等待其他线程commit后才进入数据库。 ","date":"2024-05-18","objectID":"/posts/f0ce569/:35:3","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"mysql 的事务隔离级–案例 -- 演示mysql的事务隔离级别 -- 1. 开了两个mysql的控制台 -- 2. 查看当前mysql的隔离级别 SELECT @@tx_isolation; -- mysql\u003e SELECT @@tx_isolation; -- +-----------------+ -- | @@tx_isolation | -- +-----------------+ -- | REPEATABLE-READ | -- +-----------------+ -- 3.把其中一个控制台的隔离级别设置 Read uncommitted SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED -- 4. 创建表 CREATE TABLE `account`( id INT, `name` VARCHAR(32), money INT); -- 查看当前会话隔离级别 SELECT @@tx_isolation -- 查看系统当前隔离级别 SELECT @@global.tx_isolation -- 设置当前会话隔离级别 SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED -- 设置系统当前隔离级别 SET GLOBAL TRANSACTION ISOLATION LEVEL [你设置的级别] ","date":"2024-05-18","objectID":"/posts/f0ce569/:35:4","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"设置事务隔离级别 查看当前会话隔离级别 select @@tx_isolation; 查看系统当前隔离级别 select @@global.tx_isolation; 设置当前会话隔离级别 set session transaction isolation level repeatable read; 设置系统当前隔离级别 set global transaction isolation level repeatable read; mysql默认的事务隔离级别是 repeatable read，一般情况下，没有特殊 要求,没有必要修改(因为该级别可以满足绝大部分项目需求) 如果想要修改默认隔离级别，可以全局修改，修改my.ini配置文件，在最后加上 #可选参数有:READ-UNCOMMITTED, READ-COMMITTED, REPEATABLE-READ,SERIALIZABLE. [mysqld] transaction-isolation = REPEATABLE-READ ","date":"2024-05-18","objectID":"/posts/f0ce569/:35:5","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"mysql 事务ACID ","date":"2024-05-18","objectID":"/posts/f0ce569/:36:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"事务的acid 特性 原子性(Atomicity) 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性(Consistency) 事务必须使数据库从一个二致性状态变换到另外一个一致性状态 隔离性(lsolation) 事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。 持久性(Durability) 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。 ","date":"2024-05-18","objectID":"/posts/f0ce569/:36:1","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"mysql 表类型和存储引擎 ","date":"2024-05-18","objectID":"/posts/f0ce569/:37:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"基本介绍 MySQL的表类型由存储引擎(Storage Engines）决定，主要包括MylSAM、innoDB、Memory等。 MySQL 数据表主要支持六种类型，分别是: CSV.Memory、ARCHIVE. MRG MYISAM、MYISAM、InnoBDB。 这六种又分为两类 一类是”事务安全型”(transaction-safe) 支持事务，比如: InnoDB; 其余都属于第二类，称为”非事务安全型”(non-transaction-safe) 不支持事务 [mysiam和memory]. ","date":"2024-05-18","objectID":"/posts/f0ce569/:37:1","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"主要的存储引擎/表类型特点 ","date":"2024-05-18","objectID":"/posts/f0ce569/:37:2","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"细节说明 重点介绍三种: MyISAM、InnoDB、MEMORY MylSAM不支持事务、也不支持外键，但其访问速度快，对事务完整性没有要求 InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是比起 MylSAM存储引擎，InnoDB写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。 MEMORY存储引擎使用存在内存中的内容来创建表。每个MEMORY表只实际对应 个磁盘文件。MEMORY类型的表访问非常得快，因为它的数据是放在内存中的，并且默认使用HASH索引。但是一旦MySQL服务关闭，表中的数据就会丢失掉, 表的结构还在。 ","date":"2024-05-18","objectID":"/posts/f0ce569/:37:3","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"三种存储引擎表使用案例 -- 表类型和存储引擎 -- 查看所有的存储引擎 SHOW ENGINES -- innodb 存储引擎，是前面使用过. -- 1. 支持事务 2. 支持外键 3. 支持行级锁 -- myisam 存储引擎 CREATE TABLE t28 ( id INT, `name` VARCHAR(32)) ENGINE MYISAM -- 1. 添加速度快 2. 不支持外键和事务 3. 支持表级锁 START TRANSACTION; SAVEPOINT t1 INSERT INTO t28 VALUES(1, 'jack'); SELECT * FROM t28; ROLLBACK TO t1 -- memory 存储引擎 -- 1. 数据存储在内存中[关闭了Mysql服务，数据丢失, 但是表结构还在] -- 2. 执行速度很快(没有IO读写) 3. 默认支持索引(hash表) CREATE TABLE t29 ( id INT, `name` VARCHAR(32)) ENGINE MEMORY DESC t29 -- 表结构还在 INSERT INTO t29 VALUES(1,'tom'), (2,'jack'), (3, 'hsp'); SELECT * FROM t29 -- 指令修改存储引擎 ALTER TABLE `t29` ENGINE = INNODB ","date":"2024-05-18","objectID":"/posts/f0ce569/:37:4","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"如何选择表的存储引擎 如果你的应用不需要事务，处理的只是基本的CRUD操作，那么MylSAM 是不二选择,速度快 如果需要支持事务,选择lnnoDB。 Memory存储引擎就是将数据存储在内存中，由于没有磁盘I/O的等待, 速度极快。但由于是内存存储引擎，所做的任何修改在服务器重启后都将消失。(经典用法用户的在线状态() ","date":"2024-05-18","objectID":"/posts/f0ce569/:37:5","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"修改存储引擎 ALTER TABLE `表名` ENGINE = 储存引擎; ","date":"2024-05-18","objectID":"/posts/f0ce569/:37:6","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"视图(view) ","date":"2024-05-18","objectID":"/posts/f0ce569/:38:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"看一个需求 emp表的列信息很多，有些信息是个人重要信息(比如sal, comm,mgr, hiredate)，如果我们希望某个用户只能查询emp表的(empno,ename, job和deptno)信息，有什么办法?=\u003e视图 ","date":"2024-05-18","objectID":"/posts/f0ce569/:38:1","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"基本概念 视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含列，其数据来自对应的真实表(基表) 视图和基表关系的示意图： ","date":"2024-05-18","objectID":"/posts/f0ce569/:38:2","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"视图的基本使用 create view 视图名 as select语句 alter view 视图名 as select语句 –更新成新的视图 SHOW CREATE VIEW 视图名 drop view 视图名1,视图名2 -- 视图的使用 -- 创建一个视图emp_view01，只能查询emp表的(empno、ename, job 和 deptno ) 信息 -- 创建视图 CREATE VIEW emp_view01 AS SELECT empno, ename, job, deptno FROM emp; -- 查看视图 DESC emp_view01 SELECT * FROM emp_view01; SELECT empno, job FROM emp_view01; -- 查看创建视图的指令 SHOW CREATE VIEW emp_view01 -- 删除视图 DROP VIEW emp_view01; -- 视图的细节 -- 1. 创建视图后，到数据库去看，对应视图只有一个视图结构文件(形式: 视图名.frm) -- 2. 视图的数据变化会影响到基表，基表的数据变化也会影响到视图[insert update delete ] -- 修改视图 会影响到基表 UPDATE emp_view01 SET job = 'MANAGER' WHERE empno = 7369 SELECT * FROM emp; -- 查询基表 SELECT * FROM emp_view01 -- 修改基本表， 会影响到视图 UPDATE emp SET job = 'SALESMAN' WHERE empno = 7369 -- 3. 视图中可以再使用视图 , 比如从emp_view01 视图中，选出empno,和ename做出新视图 DESC emp_view01 CREATE VIEW emp_view02 AS SELECT empno, ename FROM emp_view01 SELECT * FROM emp_view02 ","date":"2024-05-18","objectID":"/posts/f0ce569/:38:3","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"视图细节讨论 创建视图后，到数据库去看，对应视图只有一个视图结构文件(形式:视图名.frm) 视图的数据变化会影响到基表，基表的数据变化也会影响到视图[insert update delete ] 视图中可以再使用视图，数据仍然来自基表. ","date":"2024-05-18","objectID":"/posts/f0ce569/:38:4","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"视图最佳实践 安全。一些数据表有着重要的信息。有些字段是保密的，不能让用户直接看到。这时就可以创建一个视图，在这张视图中只保留一部分字段。这样，用户就可以查询自己需要的字段,不能查看保密的字段。 性能。关系数据库的数据常常会分表存储，使用外键建立这些表的之间关系。这时,数据库查询通常会用到连接(JOIN)。这样做不但麻烦，效率相对也比较低。如果建立一个视图，将相关的表和字段组合在一起，就可以避免使用JOIN查询数据。 灵活。如果系统中有一张旧的表，这张表由于设计的问题，即将被废弃。然而，很多应用都是基于这张表，不易修改。这时就可以建立一张视图，视图中的数据直接映射到新建的表。这样，就可以少做很多改动，也达到了升级数据表的目的。 ","date":"2024-05-18","objectID":"/posts/f0ce569/:38:5","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"视图课堂练习 -- 视图的课堂练习 -- 针对 emp，dept , 和 salgrade 张三表.创建一个视图 emp_view03， -- 可以显示雇员编号，雇员名，雇员部门名称和 薪水级别[即使用三张表，构建一个视图] /* 分析: 使用三表联合查询，得到结果 将得到的结果，构建成视图 */ CREATE VIEW emp_view03 AS SELECT empno, ename, dname, grade FROM emp, dept, salgrade WHERE emp.deptno = dept.deptno AND (sal BETWEEN losal AND hisal) DESC emp_view03 SELECT * FROM emp_view03 ","date":"2024-05-18","objectID":"/posts/f0ce569/:38:6","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"Mysql 管理 ","date":"2024-05-18","objectID":"/posts/f0ce569/:39:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"Mysql 用户 mysql中的用户，都存储在系数据库mysql中user表中 其中user表的重要字段说明: host: 允许登录的“位置”，localhost表示该用户只允许本机登录，也可以指定ip地址，比如:192.168.1.100 user:用户名; authentication string:密码，是通过mysql的password()函数加密之后 的密码。 ","date":"2024-05-18","objectID":"/posts/f0ce569/:39:1","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"创建用户 create user '用户名'@'允许登录位置' identified by '密码' 说明:创建用户，同时指定密码 ","date":"2024-05-18","objectID":"/posts/f0ce569/:39:2","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"删除用户 drop user '用户名'@'允许登录位置'; ","date":"2024-05-18","objectID":"/posts/f0ce569/:39:3","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"用户修改密码 修改自己的密码: set password = password('密码'); 修改他人的密码(需要有修改用户密码权限): set password for '用户名'@'登录位置'=password('密码'); ","date":"2024-05-18","objectID":"/posts/f0ce569/:39:4","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"mysql 中的权限 ","date":"2024-05-18","objectID":"/posts/f0ce569/:39:5","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"给用户授权 基本语法: grant 权限列表 on 库.对象名 to '用户名'@'登录位置'【identified by '密码'】 说明: 权限列表，多个权限用逗号分开 grant select on ….. grant select,delete,create on …… grant all [privileges] on …. //表示赋予该用户在该对象上的所有权限 特别说明 *.*:代表本系统中的所有数据库的所有对象(表，视图，存储过程) 库.*:表示某个数据库中的所有数据对象(表，视图，存储过程等) identified by可以省略，也可以写出. (1)如果用户存在，就是同时修改该用户的密码。 (2)如果该用户不存在，就是创建该用户! ","date":"2024-05-18","objectID":"/posts/f0ce569/:39:6","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"回收用户授权 基本语法: revoke 权限列表 on 库.对象名 from '用户名'@'登录位置'; ","date":"2024-05-18","objectID":"/posts/f0ce569/:39:7","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"权限生效指令 如果权限没有生效，可以执行下面命令，基本语法: FLUSH PRIVILEGES; -- Mysql用户的管理 -- 原因：当我们做项目开发时，可以根据不同的开发人员，赋给他相应的Mysql操作权限 -- 所以，Mysql数据库管理人员(root), 根据需要创建不同的用户，赋给相应的权限，供人员使用 -- 1. 创建新的用户 -- 解读 (1) 'hsp_edu'@'localhost' 表示用户的完整信息 'hsp_edu' 用户名 'localhost' 登录的IP -- (2) 123456 密码, 但是注意 存放到 mysql.user表时，是password('123456') 加密后的密码 -- *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 CREATE USER 'hsp_edu'@'localhost' IDENTIFIED BY '123456' SELECT `host`, `user`, authentication_string FROM mysql.user -- 2. 删除用户 DROP USER 'hsp_edu'@'localhost' -- 3. 登录 -- root 用户修改 hsp_edu@localhost 密码, 是可以成功. SET PASSWORD FOR 'hsp_edu'@'localhost' = PASSWORD('123456') ","date":"2024-05-18","objectID":"/posts/f0ce569/:39:8","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"课堂练习题 用户管理练习题 创建一个用户(你的名字，拼音)，密码123，并且只可以从本地登录，不让远程登录mysql 创建库和表testdb下的news表,要求:使用root用户创建 给用户分配查看news表和添加数据的权限 测试看看用户是否只有这几个权限 修改密码为abc ,要求:使用root用户完成 重新登录 使用root 用户删除你的用户 -- 演示 用户权限的管理 -- 创建用户 shunping 密码 123 , 从本地登录 CREATE USER 'shunping'@'localhost' IDENTIFIED BY '123' -- 使用root 用户创建 testdb ,表 news CREATE DATABASE testdb CREATE TABLE news ( id INT , content VARCHAR(32)); -- 添加一条测试数据 INSERT INTO news VALUES(100, '北京新闻'); SELECT * FROM news; -- 给 shunping 分配查看 news 表和 添加news的权限 GRANT SELECT , INSERT ON testdb.news TO 'shunping'@'localhost' -- 可以增加update权限 GRANT UPDATE ON testdb.news TO 'shunping'@'localhost' -- 修改 shunping的密码为 abc SET PASSWORD FOR 'shunping'@'localhost' = PASSWORD('abc'); -- 回收 shunping 用户在 testdb.news 表的所有权限 REVOKE SELECT , UPDATE, INSERT ON testdb.news FROM 'shunping'@'localhost' REVOKE ALL ON testdb.news FROM 'shunping'@'localhost' -- 删除 shunping DROP USER 'shunping'@'localhost' ","date":"2024-05-18","objectID":"/posts/f0ce569/:39:9","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"细节说明 在创建用户的时候，如果不指定Host,则为%，%表示表示所有IP都有连接权限 create user XX; 你也可以这样指定 create user 'xxx'@'192.168.1.%' 表示xx用户在 192.168.1.* 的ip可以登录mysql 在删除用户的时候，如果 host 不是%, 需要明确指定‘用户’@‘host值’ -- 说明 用户管理的细节 -- 在创建用户的时候，如果不指定Host, 则为% , %表示表示所有IP都有连接权限 -- create user xxx; CREATE USER jack SELECT `host`, `user` FROM mysql.user -- 你也可以这样指定 -- create user 'xxx'@'192.168.1.%' 表示 xxx用户在 192.168.1.*的ip可以登录mysql CREATE USER 'smith'@'192.168.1.%' -- 在删除用户的时候，如果 host 不是 %, 需要明确指定 '用户'@'host值' DROP USER jack -- 默认就是 DROP USER 'jack'@'%' DROP USER 'smith'@'192.168.1.%' ","date":"2024-05-18","objectID":"/posts/f0ce569/:39:10","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["数据库 - Mysql"],"content":"本章作业 1.选择题 (1).以下哪条语句是错误的?[D] A.SELECT empno,ename name,sal salary FROM emp; B.SELECT empno,ename name,sal AS salary FROM emp; C.SELECT ename,sal*12 AS \"Annual Salary\" FROM emp; D.SELECT ename,sal*12 Annual Salary FROM emp; -- 有空格最好引起来 (2).某用户希望显示补助非空的所有雇员信息，应该使用哪条语句?[B] A.SELECT ename.sal,comm FROM emp WHERE comm\u003c\u003enull; B.SELECT ename,sal,comm FROM emp WHERE comm IS NOT null; C.SELECT ename,sal,comm FROM emp WHERE comm\u003c\u003e0; (3).以下哪条语句是错误的?[C] A.SELECT ename,sal salary FROM emp ORDER BY sal; B.SELECT ename,sal salary FROM emp ORDER BY salary； C. SELECT ename,sal salary FROM emp ORDER BY 3; 2.写础查看DEPT表和EMP表的结构的sql语句 -- 2. 写出 查看DEPT表和EMP表的结构 的sql语句 -- DESC dept DESC emp 3.使用简单查询语句完成: (1)显示所有部门名称。 (2)显示所有雇员名及其全年收入13月(工资+补助),并指定列别名\"年收入” -- 3. 使用简单查询语句完成: -- (1) 显示所有部门名称。 SELECT dname FROM dept; -- (2) 显示所有雇员名及其全年收入 13月(工资+补助),并指定列别名\"年收入\" SELECT ename, (sal + IFNULL(comm,0)) * 13 AS \"年收入\" FROM emp SELECT * FROM emp; 4.限制查询数据。 (1)显示工资超过2850的雇员姓名和工资。 (2)显示工资不在1500到2850之间的所有雇员名及工资。 (3)显示编号为7566的雇员姓名及所在部门编号。 (4)显示部门10和30中工资超过1500的雇员名及工资。 (5)显示无管理者的雇员名及岗位。 -- 4.限制查询数据。 -- (1) 显示工资超过2850的雇员姓名和工资。 SELECT ename, sal FROM emp WHERE sal \u003e 2850 -- (2) 显示工资不在1500到2850之间的所有雇员名及工资。 SELECT ename, sal FROM emp WHERE sal \u003c 1500 OR sal \u003e 2850 SELECT ename, sal FROM emp WHERE NOT (sal \u003e= 1500 AND sal \u003c= 2850) -- (3) 显示编号为7566的雇员姓名及所在部门编号。 SELECT ename, deptno FROM emp WHERE empno = 7566 -- (4) 显示部门10和30中工资超过1500的雇员名及工资。 SELECT ename, job FROM emp WHERE (deptno = 10 OR deptno = 30) AND sal \u003e 1500 -- (5) 显示无管理者的雇员名及岗位。 SELECT ename, job FROM emp WHERE mgr IS NULL; 5.排序数据。 1)显示在1991年2月1日到1991年5月1日之间雇用的雇员名,岗位及雇佣日期,并以雇佣日期进行排序[默认]。 2)显示获得补助的所有雇员名,工资及补助,并以工资降序排序 -- 5.排序数据。 -- (1) 显示在1991年2月1日到1991年5月1日之间雇用的雇员名,岗位及雇佣日期, -- 并以雇佣日期进行排序[默认]。 -- 思路 1. 先查询到对应结果 2. 考虑排序 SELECT ename, job, hiredate FROM emp WHERE hiredate \u003e= '1991-02-01' AND hiredate \u003c= '1991-05-01' ORDER BY hiredate -- (2) 显示获得补助的所有雇员名,工资及补助,并以工资降序排序 SELECT ename, sal, comm FROM emp ORDER BY sal DESC 6.根据:emp员工表写出正确SQL –1.选择部门30中的所有员工. –2.列出所有办事员(CLERK)的姓名，编号和部门编号 –3.找出佣金高于薪金的员工. –4.找出佣金高于薪金60%的员工. –5.找出部门10中所有经理(MANAGER)和部门20中所有办事员(CLERK)的详细资料. –6.找出部门10中所有经理(MANAGER),部门20中所有办事员(CLERK),还有既不是经理又不是办事员但其薪金大于或等于2000的所有员工的详细资料. –7.找出收取佣金的员工的不同工作. –8.找出不收取佣金或收取的佣金低于100的员工.–9.找出各月倒数第3天受雇的所有员工. –10.找出早于12年前受雇的员工. –11.以首字母小写的方式显示所有员工的姓名. –12.显示正好为5个字符的员工的姓名. –13.显示不带有\"R\"的员工的姓名. –14.显示所有员工姓名的前三个字符. –15.显示所有员工的姓名,用a替换所有\"A\" –16.显示满10年服务年限的员工的姓名和受雇日期. –17.显示员工的详细资料,按姓名排序. –18.显示员工的姓名和受雇日期,根据其服务年限,将最老的员工排在最前面. –19.显示所有员工的姓名、工作和薪金,按工作降序排序,若工作相同则按薪金排序. –20.显示所有员工的姓名、加入公司的年份和月份,按受雇日期所在月排序,若月份相同则将最早年份的员工排在最前面. –21.显示在一个月为30天的情况所有员工的日薪金,忽略余数. –22.找出在(任何年份的)2月受聘的所有员工。 –23.对于每个员工,显示其加入公司的天数. –24.显示姓名字段的任何位置包含\"A\"的所有员工的姓名. –25.以年月日的方式显示所有员工的服务年限.(大概) -- homework03 -- ------1.选择部门30中的所有员工. SELECT * FROM emp WHERE deptno = 30 -- ------2.列出所有办事员(CLERK)的姓名，编号和部门编号. SELECT ename, empno, deptno, job FROM emp WHERE job = 'CLERK' -- ------3.找出佣金高于薪金的员工. SELECT * FROM emp WHERE IFNULL(comm, 0) \u003e sal -- ------4.找出佣金高于薪金60%的员工. SELECT * FROM emp WHERE IFNULL(comm, 0) \u003e sal * 0.6 -- ------5.找出部门10中所有经理(MANAGER)和部门20中所有办事员(CLERK)的详细资料. -- SELECT * FROM emp WHERE (deptno = 10 AND job = 'MANAGER') OR (deptno = 20 AND job = 'CLERK') -- ------6.找出部门10中所有经理(MANAGER),部门20中所有办事员(CLERK), -- 还有既不是经理又不是办事员但其薪金大于或等于2000的所有员工的详细资料. SELECT * FROM emp WHERE (deptno = 10 AND job = 'MANAGER') OR (deptno = 20 AND job = 'CLERK') OR (job != 'MANAGER' AND job != 'CLERK' AND sal \u003e= 2000 ) -- ------7.找出收取佣金的员工的不同工作. SELECT DISTINCT job FROM emp WHERE comm IS NOT NULL -- ------8.找出不收取佣金或收取的佣金低于100的员工. SELECT * FROM emp WHERE comm IS NULL OR IFNULL(comm, 0) \u003c 100 -- ------9.找出各月倒数第3天受雇的所有员工. -- 提示: last_day(日期)， 可以返回该日期所在月份的最后一天 -- last_day(日期) - 2 得到日期所有月份的倒数第3天 SELECT * FROM emp WHERE LAST_DAY(hiredate) - 2 = hiredate -- ------10.找出早于12年前受雇的员工.（即 入职时间超过12年） SELECT * FROM emp WHERE DATE_ADD(hiredate, INTERVAL 12 YEAR) \u003c NOW() -- -- ------11.以首字母小写的方式显示所有员工的姓名. SELECT CONCAT(LCASE(SUBSTRING(ename,1,1)), SUBSTRING(ename,2)) FROM emp; -- ------12.显示正好为5个字符的员","date":"2024-05-18","objectID":"/posts/f0ce569/:40:0","tags":["mysql","数据库"],"title":"Mysql基础_韩顺平老师转载","uri":"/posts/f0ce569/"},{"categories":["Java"],"content":" 第25章 JDBC 和数据库连接池 JDBC 概述 基本介绍 模拟JDBC JDBC 带来的好处 JDBC 快速入门 JDBC 程序编写步骤 JDBC 第一个程序 获取数据库连接5种方式 方式1 方式2 方式3 方式4 方式5 ResultSet[结果集] 基本介绍 应用实例 Statement 基本介绍 PreparedStatement 基本介绍 预处理好处 应用案例 JDBC 的相关 API 小结 封装JDBCUtils 说明 代码实现 事务 基本介绍 应用实例 批处理 基本介绍 数据库连接池 5k 次连接数据库问题 传统获取Connection 问题分析 数据库连接池种类 C3P0 应用实例 Druid(德鲁伊)应用实例 将JDBCUtils 工具类改成Druid(德鲁伊)实现 Apache—DBUtils 先分析一个问题 自定义方法解决 基本介绍 应用实例 表 和 JavaBean 的类型映射关系 DAO 和增删改查通用方法-BasicDao 先分析一个问题 基本说明 BasicDAO 应用实例 第25章 JDBC 和数据库连接池 ","date":"2024-05-18","objectID":"/posts/2585519/:0:0","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"JDBC 概述 ","date":"2024-05-18","objectID":"/posts/2585519/:1:0","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"基本介绍 JDBC为访问不同的数据库提供了统一的接口，为使用者屏蔽了细节问题。 Java程序员使用JDBC,可以连接任何提供了JDBC驱动程序的数据库系统，从而完成对数据库的各种操作。 JDBC的基本原理图[重要!] ","date":"2024-05-18","objectID":"/posts/2585519/:1:1","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"模拟JDBC package com.hspedu.jdbc.myjdbc; /** * 我们规定的jdbc接口(方法) */ public interface JdbcInterface { //连接 public Object getConnection() ; //crud public void crud(); //关闭连接 public void close(); } package com.hspedu.jdbc.myjdbc; /** * mysql 数据库实现了jdbc接口 [模拟] 【mysql厂商开发】 */ public class MysqlJdbcImpl implements JdbcInterface{ @Override public Object getConnection() { System.out.println(\"得到 mysql 的连接\"); return null; } @Override public void crud() { System.out.println(\"完成 mysql 增删改查\"); } @Override public void close() { System.out.println(\"关闭 mysql 的连接\"); } } package com.hspedu.jdbc.myjdbc; /** * @author 韩顺平 * @version 1.0 * 模拟oracle数据库实现 jdbc */ public class OracleJdbcImpl implements JdbcInterface { @Override public Object getConnection() { System.out.println(\"得到 oracle的连接 升级\"); return null; } @Override public void crud() { System.out.println(\"完成 对oracle的增删改查\"); } @Override public void close() { System.out.println(\"关闭 oracle的连接\"); } } package com.hspedu.jdbc.myjdbc; import java.io.FileInputStream; import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.Statement; import java.util.Properties; import java.util.Scanner; public class TestJDBC { public static void main(String[] args) throws Exception { //完成对mysql的操作 JdbcInterface jdbcInterface = new MysqlJdbcImpl(); jdbcInterface.getConnection(); //通过接口来调用实现类[动态绑定] jdbcInterface.crud(); jdbcInterface.close(); //完成对oracle的操作 System.out.println(\"==============================\"); jdbcInterface = new OracleJdbcImpl(); jdbcInterface.getConnection(); //通过接口来调用实现类[动态绑定] jdbcInterface.crud(); jdbcInterface.close(); } } ","date":"2024-05-18","objectID":"/posts/2585519/:1:2","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"JDBC 带来的好处 如果Java直接访问数据库(示意图) JDBC带来的好处(示意图) 说明：JDBC是Java提供一套用于数据库操作的接口APl, Java程序员只需要面向这套接口编程即可。不同的数据库厂商,需要针对这套接口,提供不同实现。 JDBC API是一系列的接口，它统一和规范了应用程序与数据库的连接、执行SQL语句，并到得到返回结果等各类操作,相关类和接口在java.sql与javax.sql包中 ","date":"2024-05-18","objectID":"/posts/2585519/:1:3","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"JDBC 快速入门 ","date":"2024-05-18","objectID":"/posts/2585519/:2:0","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"JDBC 程序编写步骤 注册驱动–加载Driver类 获取连接–得到Connection（java程序和数据库之间的连接） 执行增删改查–发送SQL给mysql执行 释放资源–关闭相关连接 ","date":"2024-05-18","objectID":"/posts/2585519/:2:1","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"JDBC 第一个程序 通过jdbc对表actor 进行添加，删除和修改操作 package com.hspedu.jdbc; import com.mysql.jdbc.Driver; import java.sql.Connection; import java.sql.SQLException; import java.sql.Statement; import java.util.Properties; /** * 这是第一个Jdbc 程序，完成简单的操作 */ public class Jdbc01 { public static void main(String[] args) throws SQLException { //前置工作： 在项目下创建一个文件夹比如 libs // 将 mysql.jar 拷贝到该目录下，点击 add to project ..加入到项目中 //1. 注册驱动 Driver driver = new Driver(); //创建driver对象 //2. 得到连接 //(1) jdbc:mysql:// 规定好表示协议，通过jdbc的方式连接mysql //(2) localhost 主机，可以是ip地址 //(3) 3306 表示mysql监听的端口 //(4) hsp_db02 连接到mysql dbms 的哪个数据库 //(5) mysql的连接本质就是前面学过的socket连接 String url = \"jdbc:mysql://localhost:3306/hsp_db02\"; //将 用户名和密码放入到Properties 对象 Properties properties = new Properties(); //说明 user 和 password 是规定好，后面的值根据实际情况写 properties.setProperty(\"user\", \"root\");// 用户 properties.setProperty(\"password\", \"hsp\"); //密码 Connection connect = driver.connect(url, properties); //3. 执行sql //String sql = \"insert into actor values(null, '刘德华', '男', '1970-11-11', '110')\"; //String sql = \"update actor set name='周星驰' where id = 1\"; String sql = \"delete from actor where id = 1\"; //statement 用于执行静态SQL语句并返回其生成的结果的对象 Statement statement = connect.createStatement(); int rows = statement.executeUpdate(sql); // 如果是 dml 语句，返回的就是影响行数 System.out.println(rows \u003e 0 ? \"成功\" : \"失败\"); //4. 关闭连接资源 statement.close(); connect.close(); } } ","date":"2024-05-18","objectID":"/posts/2585519/:2:2","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"获取数据库连接5种方式 ","date":"2024-05-18","objectID":"/posts/2585519/:3:0","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"方式1 //方式1 @Test public void connect01() throws SQLException { Driver driver = new Driver(); //创建driver对象 String url = \"jdbc:mysql://localhost:3306/hsp_db02\"; //将 用户名和密码放入到Properties 对象 Properties properties = new Properties(); //说明 user 和 password 是规定好，后面的值根据实际情况写 properties.setProperty(\"user\", \"root\");// 用户 properties.setProperty(\"password\", \"hsp\"); //密码 Connection connect = driver.connect(url, properties); System.out.println(connect); } ","date":"2024-05-18","objectID":"/posts/2585519/:3:1","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"方式2 //方式2 @Test public void connect02() throws ClassNotFoundException, IllegalAccessException, InstantiationException, SQLException { //使用反射加载Driver类 , 动态加载，更加的灵活，减少依赖性（把forName后的信息放在配置文件上更加方便） Class\u003c?\u003e aClass = Class.forName(\"com.mysql.jdbc.Driver\"); Driver driver = (Driver)aClass.newInstance(); String url = \"jdbc:mysql://localhost:3306/hsp_db02\"; //将 用户名和密码放入到Properties 对象 Properties properties = new Properties(); //说明 user 和 password 是规定好，后面的值根据实际情况写 properties.setProperty(\"user\", \"root\");// 用户 properties.setProperty(\"password\", \"hsp\"); //密码 Connection connect = driver.connect(url, properties); System.out.println(\"方式2=\" + connect); } ","date":"2024-05-18","objectID":"/posts/2585519/:3:2","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"方式3 使用DriverManager 替代 driver 进行统一管理 //方式3 使用DriverManager 替代 driver 进行统一管理 @Test public void connect03() throws IllegalAccessException, InstantiationException, ClassNotFoundException, SQLException { //使用反射加载Driver Class\u003c?\u003e aClass = Class.forName(\"com.mysql.jdbc.Driver\"); Driver driver = (Driver) aClass.newInstance(); //创建url 和 user 和 password String url = \"jdbc:mysql://localhost:3306/hsp_db02\"; String user = \"root\"; String password = \"hsp\"; DriverManager.registerDriver(driver);//注册Driver驱动 Connection connection = DriverManager.getConnection(url, user, password); System.out.println(\"第三种方式=\" + connection); } ","date":"2024-05-18","objectID":"/posts/2585519/:3:3","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"方式4 //方式4: 使用Class.forName 自动完成注册驱动，简化代码 //这种方式获取连接是使用的最多，推荐使用 @Test public void connect04() throws ClassNotFoundException, SQLException { //使用反射加载了 Driver类 //在加载 Driver类时，完成注册 /* 源码: 1. 静态代码块，在类加载时，会执行一次. 2. DriverManager.registerDriver(new Driver()); 3. 因此注册driver的工作已经完成 static { try { DriverManager.registerDriver(new Driver()); } catch (SQLException var1) { throw new RuntimeException(\"Can't register driver!\"); } } */ Class.forName(\"com.mysql.jdbc.Driver\"); //创建url 和 user 和 password String url = \"jdbc:mysql://localhost:3306/hsp_db02\"; String user = \"root\"; String password = \"hsp\"; Connection connection = DriverManager.getConnection(url, user, password); System.out.println(\"第4种方式~ \" + connection); } mysqL驱动5.1.6 可以无需 CLass . forName(“com.mysql.jdbc.Driver”); 从jdk1.5以后使用了jdbc4,不再需要显示调用class.forName()注册驱动而是自动调用驱动jar包下META-INF\\servicesViava.sql.Driver文本中的类名称去注册 建议还是写上 CLass . forName(“com.mysql.jdbc.Driver”),更加明确 ","date":"2024-05-18","objectID":"/posts/2585519/:3:4","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"方式5 //方式5 , 在方式4的基础上改进，增加配置文件，让连接mysql更加灵活 @Test public void connect05() throws IOException, ClassNotFoundException, SQLException { //通过Properties对象获取配置文件的信息 Properties properties = new Properties(); properties.load(new FileInputStream(\"src\\\\mysql.properties\")); //获取相关的值 String user = properties.getProperty(\"user\"); String password = properties.getProperty(\"password\"); String driver = properties.getProperty(\"driver\"); String url = properties.getProperty(\"url\"); Class.forName(driver);//建议写上 Connection connection = DriverManager.getConnection(url, user, password); System.out.println(\"方式5 \" + connection); } ","date":"2024-05-18","objectID":"/posts/2585519/:3:5","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"ResultSet[结果集] ","date":"2024-05-18","objectID":"/posts/2585519/:4:0","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"基本介绍 表示数据库结果集的数据表,通常通过执行查询数据库的语句生成 ResultSet对象保持一个光标指向其当前的数据行。最初，光标位于第一行之前 next方法将光标移动到下一行，并且由于在ResultSet对象中没有更多行时返回false，因此可以在while循环中使用循环来遍历结果集 ","date":"2024-05-18","objectID":"/posts/2585519/:4:1","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"应用实例 package com.hspedu.jdbc.resultset_; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.sql.*; import java.util.Properties; /** * 演示select 语句返回 ResultSet ,并取出结果 */ @SuppressWarnings({\"all\"}) public class ResultSet_ { public static void main(String[] args) throws Exception { //通过Properties对象获取配置文件的信息 Properties properties = new Properties(); properties.load(new FileInputStream(\"src\\\\mysql.properties\")); //获取相关的值 String user = properties.getProperty(\"user\"); String password = properties.getProperty(\"password\"); String driver = properties.getProperty(\"driver\"); String url = properties.getProperty(\"url\"); //1. 注册驱动 Class.forName(driver);//建议写上 //2. 得到连接 Connection connection = DriverManager.getConnection(url, user, password); //3. 得到Statement Statement statement = connection.createStatement(); //4. 组织SqL String sql = \"select id, name , sex, borndate from actor\"; //执行给定的SQL语句，该语句返回单个 ResultSet对象 /* +----+-----------+-----+---------------------+ | id | name | sex | borndate | +----+-----------+-----+---------------------+-------+ | 4 | 刘德华 | 男 | 1970-12-12 00:00:00 | | 5 | jack | 男 | 1990-11-11 00:00:00 | +----+-----------+-----+---------------------+-------+ */ /* 阅读debug 代码 resultSet 对象的结构 */ ResultSet resultSet = statement.executeQuery(sql); // 初始时类似与指向表头 //5. 使用while取出数据 while (resultSet.next()) { // 让光标向后移动，如果没有更多行，则返回false int id = resultSet.getInt(1); //获取该行的第1列 //int id1 = resultSet.getInt(\"id\"); 通过列名来获取值, 推荐 String name = resultSet.getString(2);//获取该行的第2列 String sex = resultSet.getString(3); Date date = resultSet.getDate(4); System.out.println(id + \"\\t\" + name + \"\\t\" + sex + \"\\t\" + date); } //6. 关闭连接 resultSet.close(); statement.close(); connection.close(); } } ","date":"2024-05-18","objectID":"/posts/2585519/:4:2","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"Statement ","date":"2024-05-18","objectID":"/posts/2585519/:5:0","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"基本介绍 Statement对象用于执行静态SQL语句并返回其生成的结果的对象 在连接建立后,需要对数据库进行访问，执行命名或是SQL语句，可以通过 Statement[存在SQL注入] PreparedStatement[预处理] CallableStatement[存储过程] Statement对象执行SQL语句,存在SQL注入风险。 SQL注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的SQL语句段或命令,恶意攻击数据库。 要防范SQL注入，只要用 PreparedStatement(从Statement扩展而来)取代Statement就可以了。 package com.hspedu.jdbc.statement_; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.sql.*; import java.util.Properties; import java.util.Scanner; /** * 演示statement 的注入问题 */ @SuppressWarnings({\"all\"}) public class Statement_ { public static void main(String[] args) throws Exception { Scanner scanner = new Scanner(System.in); //让用户输入管理员名和密码 System.out.print(\"请输入管理员的名字: \"); //next(): 当接收到 空格或者 '就是表示结束 String admin_name = scanner.nextLine(); // 老师说明，如果希望看到SQL注入，这里需要用nextLine 直到回车才结束 System.out.print(\"请输入管理员的密码: \"); String admin_pwd = scanner.nextLine(); //通过Properties对象获取配置文件的信息 Properties properties = new Properties(); properties.load(new FileInputStream(\"src\\\\mysql.properties\")); //获取相关的值 String user = properties.getProperty(\"user\"); String password = properties.getProperty(\"password\"); String driver = properties.getProperty(\"driver\"); String url = properties.getProperty(\"url\"); //1. 注册驱动 Class.forName(driver);//建议写上 //2. 得到连接 Connection connection = DriverManager.getConnection(url, user, password); //3. 得到Statement Statement statement = connection.createStatement(); //4. 组织SqL String sql = \"select name , pwd from admin where name ='\" + admin_name + \"' and pwd = '\" + admin_pwd + \"'\"; ResultSet resultSet = statement.executeQuery(sql); if (resultSet.next()) { //如果查询到一条记录，则说明该管理存在 System.out.println(\"恭喜， 登录成功\"); } else { System.out.println(\"对不起，登录失败\"); } //关闭连接 resultSet.close(); statement.close(); connection.close(); } } ","date":"2024-05-18","objectID":"/posts/2585519/:5:1","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"PreparedStatement ","date":"2024-05-18","objectID":"/posts/2585519/:6:0","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"基本介绍 String sql =\"SELECT COUNT(*) FROM admin WHERE username =? AND PASSWORD=?\"; PreparedStatement 执行的SQL语句中的参数用问号(?)来表示，调用 PreparedStatement对象的setXxx()方法来设置这些参数. setXxx()方法有两个参数，第一个参数是要设置的SQL语句中的参数的索引(从1开始)，第二个是设置的SQL语句中的参数的值 调用executeQuery0)，返回ResultSet 对象 调用executeUpdate():执行更新，包括增、删、修改 ","date":"2024-05-18","objectID":"/posts/2585519/:6:1","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"预处理好处 不再使用+拼接sql语句，减少语法错误 有效的解决了sql注入问题! 大大减少了编译次数,效率较高 ","date":"2024-05-18","objectID":"/posts/2585519/:6:2","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"应用案例 package com.hspedu.jdbc.preparedstatement_; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.sql.*; import java.util.Properties; import java.util.Scanner; /** * 演示PreparedStatement使用 */ @SuppressWarnings({\"all\"}) public class PreparedStatement_ { public static void main(String[] args) throws Exception { //看 PreparedStatement类图 Scanner scanner = new Scanner(System.in); //让用户输入管理员名和密码 System.out.print(\"请输入管理员的名字: \"); //next(): 当接收到 空格或者 '就是表示结束 String admin_name = scanner.nextLine(); // 老师说明，如果希望看到SQL注入，这里需要用nextLine System.out.print(\"请输入管理员的密码: \"); String admin_pwd = scanner.nextLine(); //通过Properties对象获取配置文件的信息 Properties properties = new Properties(); properties.load(new FileInputStream(\"src\\\\mysql.properties\")); //获取相关的值 String user = properties.getProperty(\"user\"); String password = properties.getProperty(\"password\"); String driver = properties.getProperty(\"driver\"); String url = properties.getProperty(\"url\"); //1. 注册驱动 Class.forName(driver);//建议写上 //2. 得到连接 Connection connection = DriverManager.getConnection(url, user, password); //3. 得到PreparedStatement //3.1 组织SqL , Sql 语句的 ? 就相当于占位符 String sql = \"select name , pwd from admin where name =? and pwd = ?\"; //3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象 PreparedStatement preparedStatement = connection.prepareStatement(sql); //3.3 给 ? 赋值 preparedStatement.setString(1, admin_name); preparedStatement.setString(2, admin_pwd); //4. 执行 select 语句使用 executeQuery // 如果执行的是 dml(update, insert ,delete) executeUpdate() // 这里执行 executeQuery ,不要再写 sql ResultSet resultSet = preparedStatement.executeQuery(sql); if (resultSet.next()) { //如果查询到一条记录，则说明该管理存在 System.out.println(\"恭喜， 登录成功\"); } else { System.out.println(\"对不起，登录失败\"); } //关闭连接 resultSet.close(); preparedStatement.close(); connection.close(); } } 操作DML语句 package com.hspedu.jdbc.preparedstatement_; import java.io.FileInputStream; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.util.Properties; import java.util.Scanner; /** * 演示PreparedStatement使用 dml语句 */ @SuppressWarnings({\"all\"}) public class PreparedStatementDML_ { public static void main(String[] args) throws Exception { //看 PreparedStatement类图 Scanner scanner = new Scanner(System.in); //让用户输入管理员名和密码 System.out.print(\"请输删除管理员的名字: \"); //next(): 当接收到 空格或者 '就是表示结束 String admin_name = scanner.nextLine(); // 老师说明，如果希望看到SQL注入，这里需要用nextLine // System.out.print(\"请输入管理员的新密码: \"); // String admin_pwd = scanner.nextLine(); //通过Properties对象获取配置文件的信息 Properties properties = new Properties(); properties.load(new FileInputStream(\"src\\\\mysql.properties\")); //获取相关的值 String user = properties.getProperty(\"user\"); String password = properties.getProperty(\"password\"); String driver = properties.getProperty(\"driver\"); String url = properties.getProperty(\"url\"); //1. 注册驱动 Class.forName(driver);//建议写上 //2. 得到连接 Connection connection = DriverManager.getConnection(url, user, password); //3. 得到PreparedStatement //3.1 组织SqL , Sql 语句的 ? 就相当于占位符 //添加记录 //String sql = \"insert into admin values(?, ?)\"; //String sql = \"update admin set pwd = ? where name = ?\"; String sql = \"delete from admin where name = ?\"; //3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象 PreparedStatement preparedStatement = connection.prepareStatement(sql); //3.3 给 ? 赋值 preparedStatement.setString(1, admin_name); //preparedStatement.setString(2, admin_name); //4. 执行 dml 语句使用 executeUpdate int rows = preparedStatement.executeUpdate(); System.out.println(rows \u003e 0 ? \"执行成功\" : \"执行失败\"); //关闭连接 preparedStatement.close(); connection.close(); } } ","date":"2024-05-18","objectID":"/posts/2585519/:6:3","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"JDBC 的相关 API 小结 ","date":"2024-05-18","objectID":"/posts/2585519/:7:0","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"封装JDBCUtils ","date":"2024-05-18","objectID":"/posts/2585519/:8:0","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"说明 在jdbc操作中，获取连接和释放资源是经常使用到,可以将其封装DBC连接的工真类JDBCUtils。 ","date":"2024-05-18","objectID":"/posts/2585519/:8:1","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"代码实现 package com.hspedu.jdbc.utils; import java.io.FileInputStream; import java.io.IOException; import java.sql.*; import java.util.Properties; /** * 这是一个工具类，完成 mysql的连接和关闭资源 */ public class JDBCUtils { //定义相关的属性(4个), 因为只需要一份，因此，我们做成static private static String user; //用户名 private static String password; //密码 private static String url; //url private static String driver; //驱动名 //在static代码块去初始化 static { try { Properties properties = new Properties(); properties.load(new FileInputStream(\"src\\\\mysql.properties\")); //读取相关的属性值 user = properties.getProperty(\"user\"); password = properties.getProperty(\"password\"); url = properties.getProperty(\"url\"); driver = properties.getProperty(\"driver\"); } catch (IOException e) { //在实际开发中，我们可以这样处理 //1. 将编译异常转成 运行异常 //2. 调用者，可以选择捕获该异常，也可以选择默认处理该异常，比较方便. throw new RuntimeException(e); } } //连接数据库, 返回Connection public static Connection getConnection() { try { return DriverManager.getConnection(url, user, password); } catch (SQLException e) { //1. 将编译异常转成 运行异常 //2. 调用者，可以选择捕获该异常，也可以选择默认处理该异常，比较方便. throw new RuntimeException(e); } } //关闭相关资源 /* 1. ResultSet 结果集 2. Statement 或者 PreparedStatement 3. Connection 4. 如果需要关闭资源，就传入对象，否则传入 null */ public static void close(ResultSet set, Statement statement, Connection connection) { //判断是否为null try { if (set != null) { set.close(); } if (statement != null) { statement.close(); } if (connection != null) { connection.close(); } } catch (SQLException e) { //将编译异常转成运行异常抛出 throw new RuntimeException(e); } } } 测试 package com.hspedu.jdbc.utils; import org.junit.jupiter.api.Test; import java.sql.*; /** * 该类演示如何使用JDBCUtils工具类，完成dml 和 select */ public class JDBCUtils_Use { @Test public void testSelect() { //1. 得到连接 Connection connection = null; //2. 组织一个sql String sql = \"select * from actor where id = ?\"; PreparedStatement preparedStatement = null; ResultSet set = null; //3. 创建PreparedStatement 对象 try { connection = JDBCUtils.getConnection(); System.out.println(connection.getClass()); //com.mysql.jdbc.JDBC4Connection preparedStatement = connection.prepareStatement(sql); preparedStatement.setInt(1, 5);//给?号赋值 //执行, 得到结果集 set = preparedStatement.executeQuery(); //遍历该结果集 while (set.next()) { int id = set.getInt(\"id\"); String name = set.getString(\"name\"); String sex = set.getString(\"sex\"); Date borndate = set.getDate(\"borndate\"); String phone = set.getString(\"phone\"); System.out.println(id + \"\\t\" + name + \"\\t\" + sex + \"\\t\" + borndate + \"\\t\" + phone); } } catch (SQLException e) { e.printStackTrace(); } finally { //关闭资源 JDBCUtils.close(set, preparedStatement, connection); } } @Test public void testDML() {//insert , update, delete //1. 得到连接 Connection connection = null; //2. 组织一个sql String sql = \"update actor set name = ? where id = ?\"; // 测试 delete 和 insert ,自己玩. PreparedStatement preparedStatement = null; //3. 创建PreparedStatement 对象 try { connection = JDBCUtils.getConnection(); preparedStatement = connection.prepareStatement(sql); //给占位符赋值 preparedStatement.setString(1, \"周星驰\"); preparedStatement.setInt(2, 4); //执行 preparedStatement.executeUpdate(); } catch (SQLException e) { e.printStackTrace(); // 打印出错信息 } finally { //关闭资源 JDBCUtils.close(null, preparedStatement, connection); } } } ","date":"2024-05-18","objectID":"/posts/2585519/:8:2","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"事务 ","date":"2024-05-18","objectID":"/posts/2585519/:9:0","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"基本介绍 JDBC程序中当一个Connection对象创建时，默认情况下是自动提交事务:每次执行一个SQL语句时，如果执行成功，就会向数据库自动提交，而不能回滚。 JDBC程序中为了让多个SQL语句作为一个整体执行，需要使用事务 调用Connection的setAutoCommit(false)可以取消自动提交事务 在所有的SQL语句都成功执行后，调用Connection的commit();方法提交事务 在其中某个操作失败或出现异常时，调用Connection的rollback();方法回滚事务 ","date":"2024-05-18","objectID":"/posts/2585519/:9:1","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"应用实例 package com.hspedu.jdbc.transaction_; import com.hspedu.jdbc.utils.JDBCUtils; import org.junit.jupiter.api.Test; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.SQLException; /** * 演示jdbc 中如何使用事务 */ public class Transaction_ { //没有使用事务. @Test public void noTransaction() { //操作转账的业务 //1. 得到连接 Connection connection = null; //2. 组织一个sql String sql = \"update account set balance = balance - 100 where id = 1\"; String sql2 = \"update account set balance = balance + 100 where id = 2\"; PreparedStatement preparedStatement = null; //3. 创建PreparedStatement 对象 try { connection = JDBCUtils.getConnection(); // 在默认情况下，connection是默认自动提交 preparedStatement = connection.prepareStatement(sql); preparedStatement.executeUpdate(); // 执行第1条sql int i = 1 / 0; //抛出异常 preparedStatement = connection.prepareStatement(sql2); preparedStatement.executeUpdate(); // 执行第3条sql } catch (SQLException e) { e.printStackTrace(); } finally { //关闭资源 JDBCUtils.close(null, preparedStatement, connection); } } //事务来解决 @Test public void useTransaction() { //操作转账的业务 //1. 得到连接 Connection connection = null; //2. 组织一个sql String sql = \"update account set balance = balance - 100 where id = 1\"; String sql2 = \"update account set balance = balance + 100 where id = 2\"; PreparedStatement preparedStatement = null; //3. 创建PreparedStatement 对象 try { connection = JDBCUtils.getConnection(); // 在默认情况下，connection是默认自动提交 //将 connection 设置为不自动提交 connection.setAutoCommit(false); // 相当于开启了事务 preparedStatement = connection.prepareStatement(sql); preparedStatement.executeUpdate(); // 执行第1条sql int i = 1 / 0; //抛出异常 preparedStatement = connection.prepareStatement(sql2); preparedStatement.executeUpdate(); // 执行第3条sql //这里提交事务 connection.commit(); } catch (SQLException e) { //这里我们可以进行回滚，即撤销执行的SQL //默认回滚到事务开始的状态. System.out.println(\"执行发生了异常，撤销执行的sql\"); try { connection.rollback(); } catch (SQLException throwables) { throwables.printStackTrace(); } e.printStackTrace(); } finally { //关闭资源 JDBCUtils.close(null, preparedStatement, connection); } } } ","date":"2024-05-18","objectID":"/posts/2585519/:9:2","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"批处理 ","date":"2024-05-18","objectID":"/posts/2585519/:10:0","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"基本介绍 当需要成批插入或者更新记录时。可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率。 JDBC的批量处理语句包括下面方法: addBatch():添加需要批量处理的SQL语句或参数 executeBatch():执行批量处理语句; clearBatch():清空批处理包的语句 JDBC连接MySQL时，如果要使用批处理功能，请在url中加参数?rewriteBatchedStatements = true 批处理往往和PreparedStatement一起搭配使用，可以既减少编译次数，又减小运行次数，效率大大提高。 package com.hspedu.jdbc.batch_; import com.hspedu.jdbc.utils.JDBCUtils; import org.junit.jupiter.api.Test; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.SQLException; /** * 演示java的批处理 */ public class Batch_ { //传统方法，添加5000条数据到admin2 @Test public void noBatch() throws Exception { Connection connection = JDBCUtils.getConnection(); String sql = \"insert into admin2 values(null, ?, ?)\"; PreparedStatement preparedStatement = connection.prepareStatement(sql); System.out.println(\"开始执行\"); long start = System.currentTimeMillis();// 开始时间 for (int i = 0; i \u003c 5000; i++) {// 5000执行 preparedStatement.setString(1, \"jack\" + i); preparedStatement.setString(2, \"666\"); preparedStatement.executeUpdate(); } long end = System.currentTimeMillis(); System.out.println(\"传统的方式 耗时=\" + (end - start));//传统的方式 耗时=10702 //关闭连接 JDBCUtils.close(null, preparedStatement, connection); } //使用批量方式添加数据 @Test public void batch() throws Exception { Connection connection = JDBCUtils.getConnection(); String sql = \"insert into admin2 values(null, ?, ?)\"; PreparedStatement preparedStatement = connection.prepareStatement(sql); System.out.println(\"开始执行\"); long start = System.currentTimeMillis();//开始时间 for (int i = 0; i \u003c 5000; i++) {//5000执行 preparedStatement.setString(1, \"jack\" + i); preparedStatement.setString(2, \"666\"); //将sql 语句加入到批处理包中 -\u003e 看源码 /* //1. //第一就创建 ArrayList - elementData =\u003e Object[] //2. elementData =\u003e Object[] 就会存放我们预处理的sql语句 //3. 当elementData满后,就按照1.5扩容 //4. 当添加到指定的值后，就executeBatch //5. 批量处理会减少我们发送sql语句的网络开销，而且减少编译次数，因此效率提高 public void addBatch() throws SQLException { synchronized(this.checkClosed().getConnectionMutex()) { if (this.batchedArgs == null) { this.batchedArgs = new ArrayList(); } for(int i = 0; i \u003c this.parameterValues.length; ++i) { this.checkAllParametersSet(this.parameterValues[i], this.parameterStreams[i], i); } this.batchedArgs.add(new PreparedStatement.BatchParams(this.parameterValues, this.parameterStreams, this.isStream, this.streamLengths, this.isNull)); } } */ preparedStatement.addBatch(); //当有1000条记录时，在批量执行 if((i + 1) % 1000 == 0) {//满1000条sql preparedStatement.executeBatch(); //清空一把 preparedStatement.clearBatch(); } } long end = System.currentTimeMillis(); System.out.println(\"批量方式 耗时=\" + (end - start));//批量方式 耗时=108 //关闭连接 JDBCUtils.close(null, preparedStatement, connection); } } ","date":"2024-05-18","objectID":"/posts/2585519/:10:1","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"数据库连接池 ","date":"2024-05-18","objectID":"/posts/2585519/:11:0","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"5k 次连接数据库问题 package com.hspedu.jdbc.datasource; import com.hspedu.jdbc.utils.JDBCUtils; import org.junit.jupiter.api.Test; import java.sql.Connection; public class ConQuestion { //代码 连接mysql 5000次 @Test public void testCon() { //看看连接-关闭 connection 会耗用多久 long start = System.currentTimeMillis(); System.out.println(\"开始连接.....\"); for (int i = 0; i \u003c 5000; i++) { //使用传统的jdbc方式，得到连接 Connection connection = JDBCUtils.getConnection(); //做一些工作，比如得到PreparedStatement ，发送sql //.......... //关闭 JDBCUtils.close(null, null, connection); } long end = System.currentTimeMillis(); System.out.println(\"传统方式5000次 耗时=\" + (end - start));//传统方式5000次 耗时=7099 } } ","date":"2024-05-18","objectID":"/posts/2585519/:11:1","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"传统获取Connection 问题分析 传统的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证IP地址，用户名和密码(0.05s~1s时间)。需要数据库连接的时候,就向数据库要求一个,频繁的进行数据库连接操作将占用很多的系统资源，容易造成服务器崩溃。 每一次数据库连接，使用完后都得断开,如果程序出现异常而未能关闭，将导致数据库内存泄漏，最终将导致重启数据库。 传统获取连接的方式,不能控制创建的连接数量，如连接过多，也可能导致内存泄漏，MySQL崩溃。 解决传统开发中的数据库连接问题,可以采用数据库连接池技术 (connection pool)。 ","date":"2024-05-18","objectID":"/posts/2585519/:11:2","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"数据库连接池种类 JDBC 的数据库连接池使用javax.sqI.DataSource来表示，DataSource 只是一个接口,该接口通常由第三方提供实现[提供.jar] C3P0数据库连接池,速度相对较慢，稳定性不错(hibernate, spring) DBCP数据库连接池,速度相对c3p0较快,但不稳定 Proxool数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点 BoneCP数据库连接池,速度快 **Druid(德鲁伊)**是阿里提供的数据库连接池，集DBCP、C3P0、Proxool优点于一身的数据库连接池 ","date":"2024-05-18","objectID":"/posts/2585519/:11:3","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"C3P0 应用实例 两种连接方式： package com.hspedu.jdbc.datasource; import com.mchange.v2.c3p0.ComboPooledDataSource; import org.junit.jupiter.api.Test; import java.io.FileInputStream; import java.sql.Connection; import java.sql.SQLException; import java.util.Properties; /** * 演示c3p0的使用 */ public class C3P0_ { //方式1： 相关参数，在程序中指定user, url , password等 @Test public void testC3P0_01() throws Exception { //1. 创建一个数据源对象 ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(); //2. 通过配置文件mysql.properties 获取相关连接的信息 Properties properties = new Properties(); properties.load(new FileInputStream(\"src\\\\mysql.properties\")); //读取相关的属性值 String user = properties.getProperty(\"user\"); String password = properties.getProperty(\"password\"); String url = properties.getProperty(\"url\"); String driver = properties.getProperty(\"driver\"); //给数据源 comboPooledDataSource 设置相关的参数 //注意：连接管理是由 comboPooledDataSource 来管理 comboPooledDataSource.setDriverClass(driver); comboPooledDataSource.setJdbcUrl(url); comboPooledDataSource.setUser(user); comboPooledDataSource.setPassword(password); //设置初始化连接数 comboPooledDataSource.setInitialPoolSize(10); //最大连接数 comboPooledDataSource.setMaxPoolSize(50); //测试连接池的效率, 测试对mysql 5000次操作 long start = System.currentTimeMillis(); for (int i = 0; i \u003c 5000; i++) { Connection connection = comboPooledDataSource.getConnection(); //这个方法就是从 DataSource 接口实现的 //System.out.println(\"连接OK\"); connection.close(); } long end = System.currentTimeMillis(); //c3p0 5000连接mysql 耗时=391 System.out.println(\"c3p0 5000连接mysql 耗时=\" + (end - start)); } //第二种方式 使用配置文件模板来完成 //1. 将c3p0 提供的 c3p0.config.xml 拷贝到 src目录下（配置文件名字不能乱写，要按照规定） //2. 该文件指定了连接数据库和连接池的相关参数 @Test public void testC3P0_02() throws SQLException { ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(\"hsp_edu\"); //测试5000次连接mysql long start = System.currentTimeMillis(); System.out.println(\"开始执行....\"); for (int i = 0; i \u003c 500000; i++) { Connection connection = comboPooledDataSource.getConnection(); //System.out.println(\"连接OK~\"); connection.close(); } long end = System.currentTimeMillis(); //c3p0的第二种方式 耗时=413 System.out.println(\"c3p0的第二种方式(500000) 耗时=\" + (end - start));//1917 } } \u003cc3p0-config\u003e \u003c!-- 数据源名称代表连接池 --\u003e \u003cnamed-config name=\"hsp_edu\"\u003e \u003c!-- 驱动类 --\u003e \u003cproperty name=\"driverClass\"\u003ecom.mysql.jdbc.Driver\u003c/property\u003e \u003c!-- url--\u003e \u003cproperty name=\"jdbcUrl\"\u003ejdbc:mysql://127.0.0.1:3306/hsp_db02\u003c/property\u003e \u003c!-- 用户名 --\u003e \u003cproperty name=\"user\"\u003eroot\u003c/property\u003e \u003c!-- 密码 --\u003e \u003cproperty name=\"password\"\u003ehsp\u003c/property\u003e \u003c!-- 每次增长的连接数--\u003e \u003cproperty name=\"acquireIncrement\"\u003e5\u003c/property\u003e \u003c!-- 初始的连接数 --\u003e \u003cproperty name=\"initialPoolSize\"\u003e10\u003c/property\u003e \u003c!-- 最小连接数 --\u003e \u003cproperty name=\"minPoolSize\"\u003e5\u003c/property\u003e \u003c!-- 最大连接数 --\u003e \u003cproperty name=\"maxPoolSize\"\u003e50\u003c/property\u003e \u003c!-- 可连接的最多的命令对象数 --\u003e \u003cproperty name=\"maxStatements\"\u003e5\u003c/property\u003e \u003c!-- 每个连接对象可连接的最多的命令对象数 --\u003e \u003cproperty name=\"maxStatementsPerConnection\"\u003e2\u003c/property\u003e \u003c/named-config\u003e \u003c/c3p0-config\u003e ","date":"2024-05-18","objectID":"/posts/2585519/:11:4","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"Druid(德鲁伊)应用实例 #key=value driverClassName=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/hsp_db02?rewriteBatchedStatements=true username=root password=hsp #initial connection Size initialSize=10 #min idle connecton size minIdle=5 #max active connection size maxActive=50 #max wait time (5000 mil seconds) maxWait=5000 package com.hspedu.jdbc.datasource; import com.alibaba.druid.pool.DruidDataSourceFactory; import org.junit.jupiter.api.Test; import javax.sql.DataSource; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.sql.Connection; import java.util.Properties; /** * 测试druid的使用 */ public class Druid_ { @Test public void testDruid() throws Exception { //1. 加入 Druid jar包 //2. 加入 配置文件 druid.properties , 将该文件拷贝项目的src目录 //3. 创建Properties对象, 读取配置文件 Properties properties = new Properties(); properties.load(new FileInputStream(\"src\\\\druid.properties\")); //4. 创建一个指定参数的数据库连接池, Druid连接池 DataSource dataSource = DruidDataSourceFactory.createDataSource(properties); long start = System.currentTimeMillis(); for (int i = 0; i \u003c 500000; i++) { Connection connection = dataSource.getConnection(); System.out.println(connection.getClass()); //System.out.println(\"连接成功!\"); connection.close(); } long end = System.currentTimeMillis(); //druid连接池 操作5000 耗时=412 System.out.println(\"druid连接池 操作500000 耗时=\" + (end - start));//539 } } ","date":"2024-05-18","objectID":"/posts/2585519/:11:5","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"将JDBCUtils 工具类改成Druid(德鲁伊)实现 通过德鲁伊数据库连接池获取连接对象 package com.hspedu.jdbc.datasource; import com.alibaba.druid.pool.DruidDataSourceFactory; import javax.sql.DataSource; import java.io.FileInputStream; import java.io.IOException; import java.sql.Connection; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import java.util.Properties; /** * 基于druid数据库连接池的工具类 */ public class JDBCUtilsByDruid { private static DataSource ds; //在静态代码块完成 ds初始化 static { Properties properties = new Properties(); try { properties.load(new FileInputStream(\"src\\\\druid.properties\")); ds = DruidDataSourceFactory.createDataSource(properties); } catch (Exception e) { e.printStackTrace(); } } //编写getConnection方法 public static Connection getConnection() throws SQLException { return ds.getConnection(); } //关闭连接, 老师再次强调： 在数据库连接池技术中，close 不是真的断掉连接 //而是把使用的Connection对象放回连接池 public static void close(ResultSet resultSet, Statement statement, Connection connection) { try { if (resultSet != null) { resultSet.close(); } if (statement != null) { statement.close(); } if (connection != null) { // 特别注意：这里close方法与元生的close方法不一样，这里仅是放回连接池。 connection.close(); } } catch (SQLException e) { throw new RuntimeException(e); } } } package com.hspedu.jdbc.datasource; import org.junit.jupiter.api.Test; import java.sql.*; import java.util.ArrayList; @SuppressWarnings({\"all\"}) public class JDBCUtilsByDruid_USE { @Test public void testSelect() { System.out.println(\"使用 druid方式完成\"); //1. 得到连接 Connection connection = null; //2. 组织一个sql String sql = \"select * from actor where id \u003e= ?\"; PreparedStatement preparedStatement = null; ResultSet set = null; //3. 创建PreparedStatement 对象 try { connection = JDBCUtilsByDruid.getConnection(); System.out.println(connection.getClass());//运行类型 com.alibaba.druid.pool.DruidPooledConnection preparedStatement = connection.prepareStatement(sql); preparedStatement.setInt(1, 1);//给?号赋值 //执行, 得到结果集 set = preparedStatement.executeQuery(); //遍历该结果集 while (set.next()) { int id = set.getInt(\"id\"); String name = set.getString(\"name\");//getName() String sex = set.getString(\"sex\");//getSex() Date borndate = set.getDate(\"borndate\"); String phone = set.getString(\"phone\"); System.out.println(id + \"\\t\" + name + \"\\t\" + sex + \"\\t\" + borndate + \"\\t\" + phone); } } catch (SQLException e) { e.printStackTrace(); } finally { //关闭资源 JDBCUtilsByDruid.close(set, preparedStatement, connection); } } } ","date":"2024-05-18","objectID":"/posts/2585519/:11:6","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"Apache—DBUtils ","date":"2024-05-18","objectID":"/posts/2585519/:12:0","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"先分析一个问题 关闭connection后，resultSet结果集无法使用 resultSet不利于数据的管理 示意图 这种java类叫做JavaBean，PoJo或者Domain。 ","date":"2024-05-18","objectID":"/posts/2585519/:12:1","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"自定义方法解决 package com.hspedu.jdbc.datasource; import java.util.Date; /** * Actor 对象和 actor表的记录对应 */ public class Actor { //Javabean, POJO, Domain对象 private Integer id; private String name; private String sex; private Date borndate; private String phone; public Actor() { //一定要给一个无参构造器[反射需要] } public Actor(Integer id, String name, String sex, Date borndate, String phone) { this.id = id; this.name = name; this.sex = sex; this.borndate = borndate; this.phone = phone; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } public Date getBorndate() { return borndate; } public void setBorndate(Date borndate) { this.borndate = borndate; } public String getPhone() { return phone; } public void setPhone(String phone) { this.phone = phone; } @Override public String toString() { return \"\\nActor{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", sex='\" + sex + '\\'' + \", borndate=\" + borndate + \", phone='\" + phone + '\\'' + '}'; } } //使用老师的土方法来解决ResultSet =封装=\u003e Arraylist @Test public ArrayList\u003cActor\u003e testSelectToArrayList() { System.out.println(\"使用 druid方式完成\"); //1. 得到连接 Connection connection = null; //2. 组织一个sql String sql = \"select * from actor where id \u003e= ?\"; PreparedStatement preparedStatement = null; ResultSet set = null; ArrayList\u003cActor\u003e list = new ArrayList\u003c\u003e();//创建ArrayList对象,存放actor对象 //3. 创建PreparedStatement 对象 try { connection = JDBCUtilsByDruid.getConnection(); System.out.println(connection.getClass());//运行类型 com.alibaba.druid.pool.DruidPooledConnection preparedStatement = connection.prepareStatement(sql); preparedStatement.setInt(1, 1);//给?号赋值 //执行, 得到结果集 set = preparedStatement.executeQuery(); //遍历该结果集 while (set.next()) { int id = set.getInt(\"id\"); String name = set.getString(\"name\");//getName() String sex = set.getString(\"sex\");//getSex() Date borndate = set.getDate(\"borndate\"); String phone = set.getString(\"phone\"); //把得到的resultset 的记录，封装到 Actor对象，放入到list集合 list.add(new Actor(id, name, sex, borndate, phone)); } System.out.println(\"list集合数据=\" + list); for(Actor actor : list) { System.out.println(\"id=\" + actor.getId() + \"\\t\" + actor.getName()); } } catch (SQLException e) { e.printStackTrace(); } finally { //关闭资源 JDBCUtilsByDruid.close(set, preparedStatement, connection); } //因为ArrayList 和 connection 没有任何关联，所以该集合可以复用. return list; } ","date":"2024-05-18","objectID":"/posts/2585519/:12:2","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"基本介绍 commons-dbutils是 Apache组织提供的一个开源JDBC工具类库，它是对JDBC的封装，使用dbutils能极大简化jdbc编码的工作量。 DbUtils类： QueryRunner类:该类封装了SQL的执行，是线程安全的。可以实现增、删、改、查、批处理。 使用QueryRunner类实现查询。 ResultSetHandler接口：该接口用于处理java.sql.ResultSet，将数据按要求转换为另一种形式。 ArrayHandler:把结果集中的第一行数据转成对象数组。 ArrayListHandler:把结果集中的每一行数据都转成一个数组，再存放到List中。 BeanHandler:将结果集中的第一行数据封装到一个对应的JavaBean实例中。 BeanListHandler: 将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。 ColumnListHandler:将结果集中某一列的数据存放到List中。 KeyedHandler(name):将结果集中的每行数据都封装到Map里，再把这些map再存到一个map里，其key为指定的key。 MapHandler: 将结果集中的第一行数据封装到一个Map里，key是列名,value就是对应的值。 MapListHandler:将结果集中的每一行数据都封装到一个Map里，然后再存放到List。 ","date":"2024-05-18","objectID":"/posts/2585519/:12:3","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"应用实例 使用DBUtils+数据连接池(德鲁伊)方式，完成对表actor的crud package com.hspedu.jdbc.datasource; import org.apache.commons.dbutils.QueryRunner; import org.apache.commons.dbutils.handlers.BeanHandler; import org.apache.commons.dbutils.handlers.BeanListHandler; import org.apache.commons.dbutils.handlers.ScalarHandler; import org.junit.jupiter.api.Test; import java.sql.*; import java.util.ArrayList; import java.util.List; @SuppressWarnings({\"all\"}) public class DBUtils_USE { // 使用apache-DBUtils 工具类 + druid 完成对表的crud操作 @Test public void testQueryMany() throws SQLException { //返回结果是多行的情况 //1. 得到 连接 (druid) Connection connection = JDBCUtilsByDruid.getConnection(); //2. 使用 DBUtils 类和接口 , 先引入DBUtils 相关的jar , 加入到本Project //3. 创建 QueryRunner QueryRunner queryRunner = new QueryRunner(); //4. 就可以执行相关的方法，返回ArrayList 结果集 //String sql = \"select * from actor where id \u003e= ?\"; // 注意: sql 语句也可以查询部分列 String sql = \"select id, name from actor where id \u003e= ?\"; //(1) query 方法就是执行sql 语句，得到resultset ---封装到 --\u003e ArrayList 集合中 //(2) 返回集合 //(3) connection: 连接 //(4) sql : 执行的sql语句 //(5) new BeanListHandler\u003c\u003e(Actor.class): 在将resultset -\u003e Actor 对象 -\u003e 封装到 ArrayList // 底层使用反射机制 去获取Actor 类的属性，然后进行封装 //(6) 1 就是给 sql 语句中的? 赋值，可以有多个值，因为是可变参数Object... params //(7) 底层得到的resultset ,会在query 关闭, 并且关闭PreparedStatment，所以只需要传入connection就可以。 /** * 分析 queryRunner.query方法: * public \u003cT\u003e T query(Connection conn, String sql, ResultSetHandler\u003cT\u003e rsh, Object... params) throws SQLException { * PreparedStatement stmt = null;//定义PreparedStatement * ResultSet rs = null;//接收返回的 ResultSet * Object result = null;//返回ArrayList * * try { * stmt = this.prepareStatement(conn, sql);//创建PreparedStatement * this.fillStatement(stmt, params);//对sql 进行 ? 赋值 * rs = this.wrap(stmt.executeQuery());//执行sql,返回resultset * result = rsh.handle(rs);//返回的resultset --\u003e arrayList[result] [使用到反射，对传入class对象处理] * } catch (SQLException var33) { * this.rethrow(var33, sql, params); * } finally { * try { * this.close(rs);//关闭resultset * } finally { * this.close((Statement)stmt);//关闭preparedstatement对象 * } * } * * return result; * } */ List\u003cActor\u003e list = queryRunner.query(connection, sql, new BeanListHandler\u003c\u003e(Actor.class), 1); System.out.println(\"输出集合的信息\"); for (Actor actor : list) { System.out.print(actor); } //释放资源 JDBCUtilsByDruid.close(null, null, connection); } //演示 apache-dbutils + druid 完成 返回的结果是单行记录(单个对象) @Test public void testQuerySingle() throws SQLException { //1. 得到 连接 (druid) Connection connection = JDBCUtilsByDruid.getConnection(); //2. 使用 DBUtils 类和接口 , 先引入DBUtils 相关的jar , 加入到本Project //3. 创建 QueryRunner QueryRunner queryRunner = new QueryRunner(); //4. 就可以执行相关的方法，返回单个对象 String sql = \"select * from actor where id = ?\"; // 因为我们返回的单行记录\u003c---\u003e单个对象 , 使用的Hander 是 BeanHandler Actor actor = queryRunner.query(connection, sql, new BeanHandler\u003c\u003e(Actor.class), 10); System.out.println(actor); // 释放资源 JDBCUtilsByDruid.close(null, null, connection); } //演示apache-dbutils + druid 完成查询结果是单行单列-返回的就是object @Test public void testScalar() throws SQLException { //1. 得到 连接 (druid) Connection connection = JDBCUtilsByDruid.getConnection(); //2. 使用 DBUtils 类和接口 , 先引入DBUtils 相关的jar , 加入到本Project //3. 创建 QueryRunner QueryRunner queryRunner = new QueryRunner(); //4. 就可以执行相关的方法，返回单行单列 , 返回的就是Object String sql = \"select name from actor where id = ?\"; //老师解读： 因为返回的是一个对象, 使用的handler 就是 ScalarHandler Object obj = queryRunner.query(connection, sql, new ScalarHandler(), 4); System.out.println(obj); // 释放资源 JDBCUtilsByDruid.close(null, null, connection); } //演示apache-dbutils + druid 完成 dml (update, insert ,delete) @Test public void testDML() throws SQLException { //1. 得到 连接 (druid) Connection connection = JDBCUtilsByDruid.getConnection(); //2. 使用 DBUtils 类和接口 , 先引入DBUtils 相关的jar , 加入到本Project //3. 创建 QueryRunner QueryRunner queryRunner = new QueryRunner(); //4. 这里组织sql 完成 update, insert delete //String sql = \"update actor set name = ? where id = ?\"; //String sql = \"insert into actor values(null, ?, ?, ?, ?)\"; String sql = \"delete from actor where id = ?\"; //(","date":"2024-05-18","objectID":"/posts/2585519/:12:4","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"表 和 JavaBean 的类型映射关系 ","date":"2024-05-18","objectID":"/posts/2585519/:12:5","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"DAO 和增删改查通用方法-BasicDao ","date":"2024-05-18","objectID":"/posts/2585519/:13:0","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"先分析一个问题 apache-dbutils+ Druid简化了JDBC开发,但还有不足: SQL语句是固定，不能通过参数传入，通用性不好，需要进行改进，更方便执行增删改查 对于select 操作，如果有返回值，返回类型不能固定，需要使用泛型 将来的表很多，业务需求复杂,不可能只靠一个Java类完成 引出=》 BasicDAO画出示意图，看看在实际开发中，应该如何处理 ","date":"2024-05-18","objectID":"/posts/2585519/:13:1","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"基本说明 DAO : data access object数据访问对象 这样的通用类，称为 BasicDao，是专门和数据库交互的，即完成对数据库(表)的crud操作。 在BaiscDao的基础上，实现一张表对应一个Dao，更好的完成功能，比如 Customer表-Customer.java类(javabean)-CustomerDao.java ","date":"2024-05-18","objectID":"/posts/2585519/:13:2","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["Java"],"content":"BasicDAO 应用实例 完成一个简单设计com.hspedu.dao_ com.hspedu.dao _.utils //工具类 com.hspedu.dao_.domain // javabean com.hspedu.dao_.dao//存放XxxDAO和BasicDAO_ com.hspedu.dao_.test //写测试类 com/hspedu/dao_/domain/Actor.java package com.hspedu.dao_.domain; import java.util.Date; /** * Actor 对象和 actor表的记录对应 */ public class Actor { //Javabean, POJO, Domain对象 private Integer id; private String name; private String sex; private Date borndate; private String phone; public Actor() { //一定要给一个无参构造器[反射需要] } public Actor(Integer id, String name, String sex, Date borndate, String phone) { this.id = id; this.name = name; this.sex = sex; this.borndate = borndate; this.phone = phone; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } public Date getBorndate() { return borndate; } public void setBorndate(Date borndate) { this.borndate = borndate; } public String getPhone() { return phone; } public void setPhone(String phone) { this.phone = phone; } @Override public String toString() { return \"\\nActor{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", sex='\" + sex + '\\'' + \", borndate=\" + borndate + \", phone='\" + phone + '\\'' + '}'; } } com/hspedu/dao_/utils/JDBCUtilsByDruid.java package com.hspedu.dao_.domain; import java.util.Date; /** * Actor 对象和 actor表的记录对应 */ public class Actor { //Javabean, POJO, Domain对象 private Integer id; private String name; private String sex; private Date borndate; private String phone; public Actor() { //一定要给一个无参构造器[反射需要] } public Actor(Integer id, String name, String sex, Date borndate, String phone) { this.id = id; this.name = name; this.sex = sex; this.borndate = borndate; this.phone = phone; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } public Date getBorndate() { return borndate; } public void setBorndate(Date borndate) { this.borndate = borndate; } public String getPhone() { return phone; } public void setPhone(String phone) { this.phone = phone; } @Override public String toString() { return \"\\nActor{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", sex='\" + sex + '\\'' + \", borndate=\" + borndate + \", phone='\" + phone + '\\'' + '}'; } } com/hspedu/dao_/dao/BasicDAO.java package com.hspedu.dao_.dao; import com.hspedu.dao_.utils.JDBCUtilsByDruid; import org.apache.commons.dbutils.QueryRunner; import org.apache.commons.dbutils.handlers.BeanHandler; import org.apache.commons.dbutils.handlers.BeanListHandler; import org.apache.commons.dbutils.handlers.ScalarHandler; import java.sql.Connection; import java.sql.SQLException; import java.util.List; /** * 开发BasicDAO , 是其他DAO的父类 */ public class BasicDAO\u003cT\u003e { //泛型指定具体类型 private QueryRunner qr = new QueryRunner(); //开发通用的dml方法, 针对任意的表 public int update(String sql, Object... parameters) { Connection connection = null; try { connection = JDBCUtilsByDruid.getConnection(); int update = qr.update(connection, sql, parameters); return update; } catch (SQLException e) { throw new RuntimeException(e); //将编译异常-\u003e运行异常 ,抛出 } finally { JDBCUtilsByDruid.close(null, null, connection); } } //返回多个对象(即查询的结果是多行), 针对任意表 /** * * @param sql sql 语句，可以有 ? * @param clazz 传入一个类的Class对象 比如 Actor.class * @param parameters 传入 ? 的具体的值，可以是多个 * @return 根据Actor.class 返回对应的 ArrayList 集合 */ public List\u003cT\u003e queryMulti(String sql, Class\u003cT\u003e clazz, Object... parameters) { Connection connection = null; try { connection = JDBCUtilsByDruid.getConnection(); return qr.query(connection, sql, new BeanListHandler\u003cT\u003e(clazz), parameters); } catch (SQLException e) { throw new RuntimeException(e); //将编译异常-\u003e运行异常 ,抛出 } finally { JDBCUtilsByDruid.close(null, null, connection); } } //查询单行结果 的通用方法 public T queryS","date":"2024-05-18","objectID":"/posts/2585519/:13:3","tags":["Java","JDBC","数据库操作"],"title":"JDBC_韩顺平老师转载","uri":"/posts/2585519/"},{"categories":["前端 - React"],"content":"React Hooks 手动创建react项目 仓库地址 https://github.com/meowrain/Manually-React-Project https://dev.to/ivadyhabimana/how-to-create-a-react-app-without-using-create-react-app-a-step-by-step-guide-30nl npm init -y npm install react react-dom npm install --save-dev @babel/core babel-loader @babel/cli @babel/preset-env @babel/preset-react npm install --save-dev webpack webpack-cli webpack-dev-server npm install --save-dev html-webpack-plugin 创建src目录，index.js，public目录和index.html,.babelrc,webpack.config.js index.html \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"root\"\u003e\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e webpack：使我们能够在项目中使用 webpack 的实际包 webpack-cli：允许我们在命令行中运行 webpack 命令 webpack-dev-server：Webpack 服务器将在开发环境中充当我们的服务器。如果您熟悉更高级别的开发服务器 live-server 或 nodemon，那么它的工作方式是相同的。 // index.js import React from 'react' import { createRoot } from 'react-dom/client'; import App from './src/App.js' const container = document.getElementById('root'); const root = createRoot(container); root.render(\u003cApp/\u003e); // App.jsx import React from \"react\"; function App() { return ( \u003cdiv\u003e \u003ch1\u003eHello React\u003c/h1\u003e \u003c/div\u003e ) } export default App 创建webpack.config.js const HtmlWebpackPlugin = require(\"html-webpack-plugin\"); const path = require(\"path\"); module.exports = { entry: \"./index.js\", mode: \"development\", output: { path: path.resolve(__dirname, \"./dist\"), filename: \"index_bundle.js\", }, target: \"web\", devServer: { port: \"8080\", static: { directory: path.join(__dirname, \"public\"), }, open: true, hot: true, liveReload: true, }, resolve: { extensions: [\".js\", \".jsx\", \".json\"], }, module: { rules: [ { test: /\\.(js|jsx)$/, exclude: /node_modules/, use: \"babel-loader\", }, ], }, plugins: [ new HtmlWebpackPlugin({ template: path.join(__dirname, \"public\", \"index.html\"), }), ], }; { \"presets\": [\"@babel/preset-env\",\"@babel/preset-react\"] } 修改package.json \"scripts\": { \"start\": \"webpack-dev-server .\", \"build\": \"webpack .\" }, useState // App.js import React, { useState } from \"react\"; function App() { const [count,setCount] = useState(0); function add(){ setCount(count + 1) } function sub() { setCount(count - 1) } return ( \u003cdiv\u003e \u003ch1\u003eHello React\u003c/h1\u003e \u003ch3\u003e{count}\u003c/h3\u003e \u003cbutton onClick={add}\u003eAdd\u003c/button\u003e \u003cbutton onClick={sub}\u003eSub\u003c/button\u003e \u003c/div\u003e ) } export default App 那如果一次想加2呢？ import React, { useState } from \"react\"; function App() { const [count,setCount] = useState(0); function add(){ setCount(count + 1) setCount(count + 1) } function sub() { setCount(count - 1) } return ( \u003cdiv\u003e \u003ch1\u003eHello React\u003c/h1\u003e \u003ch3\u003e{count}\u003c/h3\u003e \u003cbutton onClick={add}\u003eAdd\u003c/button\u003e \u003cbutton onClick={sub}\u003eSub\u003c/button\u003e \u003c/div\u003e ) } export default App 我们这样写，点击Add发现还是每次只能加1，这是为什么呢？ 这是因为React的setState是一个批量更新的过程,而不是立即更新。当您连续多次调用setState时,React会将多个setState调用合并到一次更新中。这样做是为了提高性能,避免不必要的重复渲染。 如果想在单次更新中多次增加count的值,可以使用函数形式的setState,它可以接收之前的state作为参数,并根据之前的state计算新的state。 import React, { useState } from \"react\"; function App() { const [count,setCount] = useState(0); function add(){ setCount((prevCount)=\u003eprevCount + 1) setCount((prevCount)=\u003eprevCount + 1) } function sub() { setCount(count - 1) } return ( \u003cdiv\u003e \u003ch1\u003eHello React\u003c/h1\u003e \u003ch3\u003e{count}\u003c/h3\u003e \u003cbutton onClick={add}\u003eAdd\u003c/button\u003e \u003cbutton onClick={sub}\u003eSub\u003c/button\u003e \u003c/div\u003e ) } export default App 这样就正常了 ","date":"2024-05-18","objectID":"/posts/33f6951/:0:0","tags":["Web前端","React"],"title":"React Hooks","uri":"/posts/33f6951/"},{"categories":["前端 - React"],"content":"使用useState更新数组或者对象 如果直接修改原有的数组或对象,由于引用没有改变,React 将无法检测到状态的变化,从而导致组件无法正确更新。 React 倾向于函数式编程风格,这种风格强调不可变性和无副作用的纯函数。通过创建新的数组或对象,而不是直接修改它们,我们可以更好地遵循这种编程风格。 相反,使用不可变的方式来更新数组或对象,如使用 concat、slice、... 扩展运算符等,可以确保状态的不可变性,并且更易于推理和优化性能。这也是 React 官方文档中推荐的做法。 import React, { useState } from 'react'; function App() { const [items, setItems] = useState(['apple', 'banana', 'orange']); const addItem = () =\u003e { setItems([...items, 'grape']); }; const removeItem = (index) =\u003e { setItems(items.filter((item, i) =\u003e i !== index)); }; return ( \u003cdiv\u003e \u003ch1\u003eFruit List\u003c/h1\u003e \u003cul\u003e {items.map((item, index) =\u003e ( \u003cli key={index}\u003e {item} \u003cbutton onClick={() =\u003e removeItem(index)}\u003eRemove\u003c/button\u003e \u003c/li\u003e ))} \u003c/ul\u003e \u003cbutton onClick={addItem}\u003eAdd Grape\u003c/button\u003e \u003c/div\u003e ); } export default App; import React, { useState } from 'react'; function App() { const [user, setUser] = useState({ name: 'John', age: 30 }); const updateName = () =\u003e { setUser({ ...user, name: 'Jane' }); }; const incrementAge = () =\u003e { setUser({ ...user, age: user.age + 1 }); }; return ( \u003cdiv\u003e \u003ch1\u003eUser Details\u003c/h1\u003e \u003cp\u003eName: {user.name}\u003c/p\u003e \u003cp\u003eAge: {user.age}\u003c/p\u003e \u003cbutton onClick={updateName}\u003eUpdate Name\u003c/button\u003e \u003cbutton onClick={incrementAge}\u003eIncrement Age\u003c/button\u003e \u003c/div\u003e ); } export default App; useEffect useEffect 是 React 提供的一个钩子函数,用于在函数组件中执行副作用操作,例如数据获取、订阅、手动修改 DOM 等。它类似于 componentDidMount、componentDidUpdate 和 componentWillUnmount 这些生命周期方法在类组件中的作用。 useEffect 是 React 提供的一个钩子函数,用于在函数组件中执行副作用操作,例如数据获取、订阅、手动修改 DOM 等。它类似于 componentDidMount、componentDidUpdate 和 componentWillUnmount 这些生命周期方法在类组件中的作用。 useEffect 的语法 useEffect(effect, dependencies) effect 是一个函数,它描述了要执行的副作用操作。它可以返回一个清理函数,用于在组件卸载或下一次effect执行之前清理一些副作用。 dependencies 是一个可选的数组,用于指定 effect 依赖的状态或属性。只有当这些依赖项发生变化时,effect 函数才会被重新执行。如果不提供这个数组,effect 将在每次组件渲染后执行。 useEffect 的执行时机 初次渲染时,effect 函数会被执行一次。 在每次更新后,React 会先比较 effect 的依赖项是否发生变化。如果发生变化,effect 函数就会被重新执行。 如果 effect 函数返回了一个清理函数,那么在下一次effect执行之前或组件卸载之前,这个清理函数会被执行。 注意事项 不要在 effect 函数内部定义函数。这会导致每次渲染时都创建一个新的函数实例,从而影响依赖项的比较。相反,应该在组件函数作用域内定义并传递给 effect。 注意依赖项的顺序。依赖项数组中的值顺序发生变化也会导致 effect 重新执行。 避免在 effect 中执行昂贵的操作。如果需要执行昂贵的操作,可以考虑使用 useMemo 或 useCallback 等钩子进行性能优化。 使用示例 模拟组件生命周期 import React, { useEffect } from 'react'; function MyComponent() { useEffect(() =\u003e { // 这里是副作用代码，会在组件渲染后执行 console.log('组件已挂载或更新'); // 清理函数，用于在组件卸载或更新前执行清理工作 return () =\u003e { console.log('组件即将卸载或更新，执行清理'); }; }, []); // 空依赖数组表示这个副作用只在组件挂载时运行一次 return ( \u003cdiv\u003e \u003cp\u003e这里是组件内容\u003c/p\u003e \u003c/div\u003e ); } export default MyComponent; 例子： import React, { useEffect, useState } from \"react\"; export default function App() { const [count,setCount] = useState(0) useEffect(()=\u003e{ console.log('===================================='); console.log(\"Component Mounted or Updated\"); console.log('===================================='); },[count]) function add() { return setCount((prevCount)=\u003eprevCount + 1) } return ( \u003cdiv\u003e \u003ch1\u003eHelloWorld\u003c/h1\u003e \u003ch3\u003e{count}\u003c/h3\u003e \u003cbutton onClick={add}\u003eAdd\u003c/button\u003e \u003c/div\u003e ) } 我们在useEffect的第二个参数上写上我们要监控的值，当这个值发生变化的时候，传入useEffect的第一个回调函数就会被调用，然后再次打印 import React, { useEffect, useState } from \"react\"; export default function App() { const [formData, setFormData] = useState({ name: \"\", email: \"\", password: \"\", }); const [flag, setFlag] = useState(true); useEffect(() =\u003e { //第一次加载组件的时候，这里的内容会被执行 console.log(\"====================================\"); console.log(\"Component Mounted or Updated\"); console.log(\"====================================\"); return () =\u003e { //卸载组件的时候，这里的回调函数会被执行 console.log(\"组件即将卸载或更新，执行清理\"); }; }); function handleSubmit(e) { e.preventDefault(); console.log(\"====================================\"); console.log(\"表单数据\", formData); console.log(\"====================================\"); } function handleChange(e) { const { name, value } = e.target; setFormData((prevFormData) =\u003e ({ ...prevFormData, [name]: value, })); } return ( \u003cdiv\u003e {flag \u0026\u0026 ( \u003cform onSubmit={handleSubmit}\u003e \u003cdiv\u003e \u003clabel htmlFor=\"name\"\u003e姓名：\u003c/label\u003e \u003cinput type=\"text\" id=\"name\" value={formData.name} onChange={handleChange} \u003e\u003c/input\u003e \u003c/div\u003e \u003cdiv\u003e \u003clabel htmlFor=\"email\"\u003e邮箱：\u003c/la","date":"2024-05-18","objectID":"/posts/33f6951/:1:0","tags":["Web前端","React"],"title":"React Hooks","uri":"/posts/33f6951/"},{"categories":["前端 - React"],"content":"基本用法 import { useRef } from 'react'; function MyComponent() { const inputRef = useRef(null); function focusInput() { inputRef.current.focus(); } return ( \u003cinput ref={inputRef} type=\"text\" /\u003e \u003cbutton onClick={focusInput}\u003eFocus the input\u003c/button\u003e ); } 在这个例子中，我们创建了一个 inputRef 引用，并将其附加到 input 元素上。当用户点击按钮时，focusInput 函数会被调用，从而使焦点移动到输入框上。 ","date":"2024-05-18","objectID":"/posts/33f6951/:1:1","tags":["Web前端","React"],"title":"React Hooks","uri":"/posts/33f6951/"},{"categories":["前端 - React"],"content":"注意事项 不要在渲染期间写入或读取 ref.current：在组件的渲染逻辑中（即 JSX 部分），你应该避免直接修改 ref.current。这可能会导致不可预测的组件行为。相反，你应该在事件处理程序或 useEffect 钩子中进行这些操作。 初始化 useRef 时避免重复创建：如果你在 useRef 中创建一个对象，确保只在首次渲染时创建它，以避免不必要的重复创建。可以通过检查 current 是否为 null 来实现。 自定义组件的 ref 转发：如果你想将 ref 传递给一个自定义组件的内部 DOM 节点，你需要使用 React.forwardRef 来转发 ref。 ","date":"2024-05-18","objectID":"/posts/33f6951/:1:2","tags":["Web前端","React"],"title":"React Hooks","uri":"/posts/33f6951/"},{"categories":["前端 - React"],"content":"例子 操作 DOM import { useRef } from 'react'; function TextInputWithFocusButton() { const inputRef = useRef(); const focusTextInput = () =\u003e { inputRef.current.focus(); }; return ( \u003c\u003e \u003cinput ref={inputRef} type=\"text\" /\u003e \u003cbutton onClick={focusTextInput}\u003eFocus the input field\u003c/button\u003e \u003c/\u003e ); } 跨渲染周期保持状态 import { useRef, useEffect } from 'react'; function UseEffectExample() { const intervalRef = useRef(); useEffect(() =\u003e { intervalRef.current = setInterval(() =\u003e { console.log('tick'); }, 1000); return () =\u003e { clearInterval(intervalRef.current); }; }, []); return \u003cdiv\u003eExample of using useRef with useEffect\u003c/div\u003e; } 在这个例子中，我们使用 useRef 来保存定时器的 ID，以便在组件卸载时能够清除定时器。 自定义组件的 ref 转发 import React, { forwardRef, useImperativeHandle, useRef } from 'react'; const VideoPlayer = forwardRef((props, ref) =\u003e { const videoRef = useRef(); useImperativeHandle(ref, () =\u003e ({ play() { videoRef.current.play(); }, pause() { videoRef.current.pause(); }, })); return \u003cvideo ref={videoRef} src=\"video.mp4\" /\u003e; }); function App() { const videoRef = useRef(); useEffect(() =\u003e { videoRef.current.play(); return () =\u003e { videoRef.current.pause(); }; }, []); return \u003cVideoPlayer ref={videoRef} /\u003e; } 在这个例子中，我们使用 forwardRef 和 useImperativeHandle 来创建一个可引用的 VideoPlayer 组件，允许父组件控制视频的播放和暂停。 通过这些例子和注意事项，你应该能够更好地理解 useRef 的用法和在 React 函数组件中的实用场景。 useContext import { useContext,createContext } from \"react\"; import \"./App.css\"; const MyContext = createContext(); function App() { return ( \u003c\u003e \u003cMyContext.Provider value={{ someData: \"Hello World\" }}\u003e \u003cChildComponent /\u003e \u003c/MyContext.Provider\u003e \u003c/\u003e ); } function ChildComponent() { const context = useContext(MyContext); return \u003cdiv\u003e{context.someData}\u003c/div\u003e; } export default App; ","date":"2024-05-18","objectID":"/posts/33f6951/:1:3","tags":["Web前端","React"],"title":"React Hooks","uri":"/posts/33f6951/"},{"categories":["前端 - React"],"content":"为什么使用 useContext 简化跨层级的数据传递：当你需要在嵌套很深的组件树中传递数据时，使用上下文可以避免在每个层级手动传递 props。 与状态管理库结合：上下文可以与状态管理库（如 Redux 或 MobX）结合使用，以便在组件之间共享全局状态。 自定义钩子：你可以创建自定义钩子来使用上下文，使得在多个组件中访问上下文值更加方便。 ","date":"2024-05-18","objectID":"/posts/33f6951/:1:4","tags":["Web前端","React"],"title":"React Hooks","uri":"/posts/33f6951/"},{"categories":["前端 - React"],"content":"注意事项 避免过度使用：虽然上下文可以简化数据传递，但过度使用可能会导致难以追踪数据流和调试问题。在可能的情况下，尽量使用局部状态管理。 考虑性能：上下文的值变化会触发所有依赖于该上下文的组件的重新渲染。如果你的上下文值很大或者组件树很复杂，这可能会影响性能。 使用 React.memo 或 useMemo：如果你的组件依赖于上下文值，但本身不依赖于其他 props 或 state，可以使用 React.memo 或 useMemo 来避免不必要的重新渲染。 useMemo 是 React 中的一个钩子（Hook），它帮助你优化组件性能，通过缓存计算结果来避免不必要的重复计算。当你有一个函数组件中的值是根据其他值计算得出的，并且这个值的计算成本较高或者结果不经常变化时，使用 useMemo 可以提高性能。 useMemo ","date":"2024-05-18","objectID":"/posts/33f6951/:1:5","tags":["Web前端","React"],"title":"React Hooks","uri":"/posts/33f6951/"},{"categories":["前端 - React"],"content":"基本用法 useMemo 接受两个参数：一个函数和一个依赖数组。函数返回的值会被缓存，并且只有当依赖数组中的值发生变化时，函数才会重新执行。 import { useMemo } from 'react'; function ExpensiveComponent(props) { // 假设这是一个计算成本很高的函数 const result = doSomethingExpensive(props.input); // 将计算结果缓存起来 const memoizedResult = useMemo(() =\u003e result, [props.input]); return \u003cdiv\u003e{memoizedResult}\u003c/div\u003e; } 在这个例子中，doSomethingExpensive 函数的结果被 useMemo 缓存起来。只有当 props.input 发生变化时，doSomethingExpensive 才会重新执行。 ","date":"2024-05-18","objectID":"/posts/33f6951/:1:6","tags":["Web前端","React"],"title":"React Hooks","uri":"/posts/33f6951/"},{"categories":["前端 - React"],"content":"注意事项 只有当函数的输出依赖于其参数时，才应该使用 useMemo。如果你的函数不依赖于任何外部值，那么它可能不需要 useMemo。 不要将 useMemo 用于依赖于内部状态的值。如果你需要缓存基于组件内部状态的值，应该使用 useState。 useMemo 不是一个语义化的保证。React 可能会在内存不足等情况下丢弃缓存的值，所以 useMemo 并不能保证缓存的值一定会被复用。 useMemo 仅用于性能优化。如果你的代码在没有 useMemo 的情况下也能正常工作，那么不应该仅仅为了使用 useMemo 而使用它。 考虑使用 useCallback 来缓存函数。如果你需要缓存一个函数而不是值，那么 useCallback 可能是更合适的选择。 ","date":"2024-05-18","objectID":"/posts/33f6951/:1:7","tags":["Web前端","React"],"title":"React Hooks","uri":"/posts/33f6951/"},{"categories":["前端 - React"],"content":"示例 缓存复杂计算结果 function CalculationComponent({ initialData }) { // 一个复杂的计算函数 const calculateData = () =\u003e { // ...复杂的计算逻辑 return complexResult; }; // 使用 useMemo 缓存计算结果 const data = useMemo(calculateData, [initialData]); return \u003cdiv\u003eData: {data}\u003c/div\u003e; } 在这个例子中，calculateData 函数的结果被缓存，只有当 initialData 发生变化时，计算才会重新执行。 缓存函数 如果你需要缓存一个函数，而不是值，可以使用 useCallback。但是，如果你的函数返回一个值，并且这个值依赖于函数的参数，你可以使用 useMemo 来缓存这个值。 function Component({ dependencies }) { // 一个返回值的函数 const getValue = useCallback(() =\u003e { let sum = 0; for (const dep of dependencies) { sum += dep; } return sum; }, [dependencies]); // 使用 useMemo 缓存函数的返回值 const memoizedValue = useMemo(() =\u003e getValue(), [getValue]); return \u003cdiv\u003eValue: {memoizedValue}\u003c/div\u003e; } 在这个例子中，getValue 函数的返回值被 useMemo 缓存，以避免在每次渲染时都重新计算。 通过使用 useMemo，你可以有效地优化组件的性能，特别是在处理计算成本较高的值时。记住，只有在值的计算依赖于组件的 props 或 state 时，才应该使用 useMemo。 useReducer https://kothing.github.io/react-hook-useReducer/ ","date":"2024-05-18","objectID":"/posts/33f6951/:1:8","tags":["Web前端","React"],"title":"React Hooks","uri":"/posts/33f6951/"},{"categories":["前端 - Vue"],"content":" 官方文档： https://cn.vuejs.org/guide/built-ins/transition.html 使用v-if处理盒子显示和消失 🤓 看上去很生硬，不是吗？我们来用transition组件处理一下 \u003ctemplate\u003e \u003cdiv\u003e \u003cel-button color=\"#626aef\" @click=\"flag = !flag\"\u003e 切换组件\u003c/el-button\u003e \u003cTransition name=\"fade\"\u003e \u003cdiv class=\"box\" v-if=\"flag\"\u003ebox\u003c/div\u003e \u003c/Transition\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript setup lang=\"ts\"\u003e import { ref, Transition } from 'vue' let flag = ref\u003cboolean\u003e(true) \u003c/script\u003e \u003cstyle scoped\u003e .box { background-color: aqua; width: 200px; height: 200px; } .fade-enter-from, .fade-leave-to { width: 0; height: 0; } .fade-enter-active, .fade-leave-active { transition: all 0.5s ease; } .fade-enter-to, .faode-leave-from { background-color: aqua; width: 200px; height: 200px; } \u003c/style\u003e ","date":"2024-05-18","objectID":"/posts/d2d05db/:0:0","tags":["Vue","前端web"],"title":"Vue笔记13-Vue transition组件","uri":"/posts/d2d05db/"},{"categories":["前端 - Vue"],"content":"简单使用 TestView.vue \u003cscript setup lang=\"ts\"\u003e \u003c/script\u003e \u003ctemplate\u003e \u003cdiv class=\"parent\"\u003e \u003cslot\u003e \u003c/slot\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle scoped\u003e .parent { width: 100px; height: 100px; background-color: aquamarine; } \u003c/style\u003e HomeView.vue \u003cscript setup lang=\"ts\"\u003e import TestView from '../views/TestView.vue' \u003c/script\u003e \u003ctemplate\u003e \u003cdiv\u003e \u003cTestView\u003e \u003ctemplate v-slot\u003e \u003cp\u003eHelloWOrld\u003c/p\u003e \u003c/template\u003e \u003c/TestView\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle scoped\u003e \u003c/style\u003e 具名插槽 TestView.vue \u003cscript setup lang=\"ts\"\u003e\u003c/script\u003e \u003ctemplate\u003e \u003cdiv class=\"parent\"\u003e \u003cslot name=\"header\"\u003e\u003c/slot\u003e \u003cslot\u003e \u003c/slot\u003e \u003cslot name=\"footer\"\u003e\u003c/slot\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle scoped\u003e .parent { width: 100px; height: 100px; background-color: aquamarine; } \u003c/style\u003e HomeVIew \u003cscript setup lang=\"ts\"\u003e import TestView from '../views/TestView.vue' \u003c/script\u003e \u003ctemplate\u003e \u003cdiv\u003e \u003cTestView\u003e \u003ctemplate v-slot:header\u003e \u003cp\u003eheader\u003c/p\u003e \u003c/template\u003e \u003ctemplate v-slot\u003e \u003cp\u003ebody\u003c/p\u003e \u003c/template\u003e \u003ctemplate v-slot:footer\u003e \u003cp\u003efooter\u003c/p\u003e \u003c/template\u003e \u003c/TestView\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle scoped\u003e \u003c/style\u003e 作用域插槽 HomeView.vue \u003cscript setup lang=\"ts\"\u003e import TestView from '../views/TestView.vue' \u003c/script\u003e \u003ctemplate\u003e \u003cdiv\u003e \u003cTestView\u003e \u003ctemplate v-slot:header\u003e \u003cp\u003eheader\u003c/p\u003e \u003c/template\u003e \u003ctemplate v-slot=\"{data}\"\u003e \u003cp\u003ebody{{ data }}\u003c/p\u003e \u003c/template\u003e \u003ctemplate v-slot:footer\u003e \u003cp\u003efooter\u003c/p\u003e \u003c/template\u003e \u003c/TestView\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle scoped\u003e \u003c/style\u003e TestView.vue \u003cscript setup lang=\"ts\"\u003e import {ref} from 'vue'; let data = ref(\"meowrain\"); \u003c/script\u003e \u003ctemplate\u003e \u003cdiv class=\"parent\"\u003e \u003cslot name=\"header\"\u003e\u003c/slot\u003e \u003cslot :data=\"data\"\u003e \u003c/slot\u003e \u003cslot name=\"footer\"\u003e\u003c/slot\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle scoped\u003e .parent { width: 100px; height: 100px; background-color: aquamarine; } \u003c/style\u003e ","date":"2024-05-18","objectID":"/posts/56af5d5/:0:0","tags":["Vue","前端web"],"title":"Vue笔记12-Vue插槽使用","uri":"/posts/56af5d5/"},{"categories":["前端 - Vue"],"content":"keep-alive组件作用 我们的要组件能在被“切走”的时候保留它们的状态。要解决这个问题，我们可以用 内置组件将这些动态组件包装起来 \u003c!-- 非活跃的组件将会被缓存！ --\u003e \u003cKeepAlive\u003e \u003ccomponent :is=\"activeComponent\" /\u003e \u003c/KeepAlive\u003e 举例： HomeView.vue \u003ctemplate\u003e \u003cdiv\u003e \u003cel-button color=\"#626aef\" @click=\"flag = !flag\"\u003e 切换组件\u003c/el-button\u003e \u003cSonViewOne v-if=\"flag\"/\u003e \u003cSonViewTwo v-else/\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript setup lang=\"ts\"\u003e import {ref} from 'vue' import SonViewOne from './SonViewOne.vue'; import SonViewTwo from './SonViewTwo.vue'; let flag = ref\u003cboolean\u003e(false ); \u003c/script\u003e \u003cstyle scoped\u003e\u003c/style\u003e SonViewOne.vue \u003ctemplate\u003e \u003cdiv class=\"demo-date-picker\"\u003e \u003cdiv class=\"container\"\u003e \u003cdiv class=\"block\"\u003e \u003cspan class=\"demonstration\"\u003eWeek\u003c/span\u003e \u003cel-date-picker v-model=\"value1\" type=\"week\" format=\"[Week] ww\" placeholder=\"Pick a week\" /\u003e \u003c/div\u003e \u003cdiv class=\"block\"\u003e \u003cspan class=\"demonstration\"\u003eMonth\u003c/span\u003e \u003cel-date-picker v-model=\"value2\" type=\"month\" placeholder=\"Pick a month\" /\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"container\"\u003e \u003cdiv class=\"block\"\u003e \u003cspan class=\"demonstration\"\u003eYear\u003c/span\u003e \u003cel-date-picker v-model=\"value3\" type=\"year\" placeholder=\"Pick a year\" /\u003e \u003c/div\u003e \u003cdiv class=\"block\"\u003e \u003cspan class=\"demonstration\"\u003eDates\u003c/span\u003e \u003cel-date-picker v-model=\"value4\" type=\"dates\" placeholder=\"Pick one or more dates\" /\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript lang=\"ts\" setup\u003e import { ref } from 'vue' const value1 = ref('') const value2 = ref('') const value3 = ref('') const value4 = ref('') \u003c/script\u003e \u003cstyle scoped\u003e .demo-date-picker { display: flex; width: 100%; padding: 0; flex-wrap: wrap; } .demo-date-picker .block { padding: 30px 0; text-align: center; border-right: solid 1px var(--el-border-color); flex: 1; } .demo-date-picker .block:last-child { border-right: none; } .demo-date-picker .container { flex: 1; border-right: solid 1px var(--el-border-color); } .demo-date-picker .container .block { border-right: none; } .demo-date-picker .container .block:last-child { border-top: solid 1px var(--el-border-color); } .demo-date-picker .container:last-child { border-right: none; } .demo-date-picker .demonstration { display: block; color: var(--el-text-color-secondary); font-size: 14px; margin-bottom: 20px; } \u003c/style\u003e SonViewTwo.vue \u003ctemplate\u003e \u003cel-form :model=\"form\" label-width=\"120px\"\u003e \u003cel-form-item label=\"Activity name\"\u003e \u003cel-input v-model=\"form.name\" /\u003e \u003c/el-form-item\u003e \u003cel-form-item label=\"Activity zone\"\u003e \u003cel-select v-model=\"form.region\" placeholder=\"please select your zone\"\u003e \u003cel-option label=\"Zone one\" value=\"shanghai\" /\u003e \u003cel-option label=\"Zone two\" value=\"beijing\" /\u003e \u003c/el-select\u003e \u003c/el-form-item\u003e \u003cel-form-item label=\"Activity time\"\u003e \u003cel-col :span=\"11\"\u003e \u003cel-date-picker v-model=\"form.date1\" type=\"date\" placeholder=\"Pick a date\" style=\"width: 100%\" /\u003e \u003c/el-col\u003e \u003cel-col :span=\"2\" class=\"text-center\"\u003e \u003cspan class=\"text-gray-500\"\u003e-\u003c/span\u003e \u003c/el-col\u003e \u003cel-col :span=\"11\"\u003e \u003cel-time-picker v-model=\"form.date2\" placeholder=\"Pick a time\" style=\"width: 100%\" /\u003e \u003c/el-col\u003e \u003c/el-form-item\u003e \u003cel-form-item label=\"Instant delivery\"\u003e \u003cel-switch v-model=\"form.delivery\" /\u003e \u003c/el-form-item\u003e \u003cel-form-item label=\"Activity type\"\u003e \u003cel-checkbox-group v-model=\"form.type\"\u003e \u003cel-checkbox label=\"Online activities\" name=\"type\" /\u003e \u003cel-checkbox label=\"Promotion activities\" name=\"type\" /\u003e \u003cel-checkbox label=\"Offline activities\" name=\"type\" /\u003e \u003cel-checkbox label=\"Simple brand exposure\" name=\"type\" /\u003e \u003c/el-checkbox-group\u003e \u003c/el-form-item\u003e \u003cel-form-item label=\"Resources\"\u003e \u003cel-radio-group v-model=\"form.resource\"\u003e \u003cel-radio label=\"Sponsor\" /\u003e \u003cel-radio label=\"Venue\" /\u003e \u003c/el-radio-group\u003e \u003c/el-form-item\u003e \u003cel-form-item label=\"Activity form\"\u003e \u003cel-input v-model=\"form.desc\" type=\"textarea\" /\u003e \u003c/el-form-item\u003e \u003cel-form-item\u003e \u003cel-button type=\"primary\" @click=\"onSubmit\"\u003eCreate\u003c/el-button\u003e \u003cel-button\u003eCancel\u003c/el-button\u003e \u003c/el-form-item\u003e \u003c/el-form\u003e \u003c/template\u003e \u003cscript lang=\"ts\" setup\u003e import { reactive } from 'vue' // do not use same name with ref const form = reactive({ name: '', region: '', date1: '', date2: '', delivery: false, type: [], resource: '', desc: '' }) const onSubmit = () =\u003e { console.log","date":"2024-05-18","objectID":"/posts/0ad7053/:0:0","tags":["Vue","前端web"],"title":"Vue笔记11-Vue keep-alive组件使用","uri":"/posts/0ad7053/"},{"categories":["前端 - Vue"],"content":"父子组件传值 ","date":"2024-05-18","objectID":"/posts/7729ec4/:0:0","tags":["Vue","前端web"],"title":"Vue笔记10-Vue组件值传递","uri":"/posts/7729ec4/"},{"categories":["前端 - Vue"],"content":"父组件向子组件传值 defineProps 父组件 \u003cscript setup lang=\"ts\"\u003e import { onMounted, ref } from 'vue' import TestView from '../views/TestView.vue' let imgUrl = ref\u003cstring\u003e() onMounted(async ()=\u003e{ const response = await fetch('https://api.waifu.pics/sfw/waifu') const json = await response.json() imgUrl.value = json.url; }) \u003c/script\u003e \u003ctemplate\u003e \u003cdiv\u003e \u003cTestView :url=\"imgUrl\"/\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle\u003e\u003c/style\u003e 子组件 \u003cscript setup lang=\"ts\"\u003e import { defineProps, toRef, watch, watchEffect } from 'vue'; const props = defineProps({ url:String }) watch(()=\u003eprops.url,(newVal,oldVal)=\u003e{ console.log(newVal); },{ flush:'post' }) // watchEffect(()=\u003e{ // console.log(props.url); // }) \u003c/script\u003e \u003ctemplate\u003e \u003cimg :src=\"url\" width=\"100px\" height=\"100px\"/\u003e \u003cdiv\u003e{{ url }}\u003c/div\u003e \u003c/template\u003e \u003cstyle scoped \u003e\u003c/style\u003e 上面用watch函数就是因为刚开始还没获取数据，props是undefined的，这时候如果在子组件中直接输出props内容，会显示undefined.在数据获取到后，props才会有值 也就是说，props是会发生一次变化的，那就正好符合watch函数的特性了，我们利用watch函数就能获取到这个props的新值了 ","date":"2024-05-18","objectID":"/posts/7729ec4/:1:0","tags":["Vue","前端web"],"title":"Vue笔记10-Vue组件值传递","uri":"/posts/7729ec4/"},{"categories":["前端 - Vue"],"content":"子组件向父组件传值 defineEmits 子组件 \u003cscript setup lang=\"ts\"\u003e const emit = defineEmits(['even','change']) /** * //这里的数组里面写的字符串是事件名,如下，低一个按钮利用even事件传递对象数组数据，第二个按钮利用change事件传递 * // 字符串数据，父组件使用感@even和@change 接收 */ let send = () =\u003e { emit('even', [ { name: 'meow', age: 12 }, { name: 'sss', age: 20 }, { name: 'sfasdfasdf', age: 3434 } ]) } let sned2 = ()=\u003e{ emit('change',\"meowrian\") } \u003c/script\u003e \u003ctemplate\u003e \u003cdiv\u003e子集\u003c/div\u003e \u003cbutton @click=\"send\"\u003eSend\u003c/button\u003e \u003cbutton @click=\"sned2\"\u003eSend2\u003c/button\u003e \u003c/template\u003e \u003cstyle scoped\u003e\u003c/style\u003e 父组件 \u003cscript setup lang=\"ts\"\u003e import TestView from '../views/TestView.vue' const getName = (objsArray:Object[])=\u003e{ for(let obj of objsArray) { console.log(obj); } } const getName2 = (name:string)=\u003e{ console.log(name); } \u003c/script\u003e \u003ctemplate\u003e \u003cdiv\u003e \u003cTestView @even=\"getName\" @change=\"getName2\"/\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle\u003e\u003c/style\u003e ","date":"2024-05-18","objectID":"/posts/7729ec4/:2:0","tags":["Vue","前端web"],"title":"Vue笔记10-Vue组件值传递","uri":"/posts/7729ec4/"},{"categories":["前端 - Vue"],"content":"子组件向父组件暴露方法和属性 defineExpose 子组件 \u003cscript setup lang=\"ts\"\u003e defineExpose({name:\"meowrain\"}) \u003c/script\u003e \u003ctemplate\u003e \u003cdiv class=\"box\"\u003e \u003cp\u003e子组件\u003c/p\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle scoped\u003e .box { width:200px; height:200px; background-color: aquamarine; display: flex; align-items: center; justify-content: center; } \u003c/style\u003e 父组件 \u003cscript setup lang=\"ts\"\u003e import {onMounted, ref} from 'vue' import TestView from '../views/TestView.vue' const testView = ref\u003cInstanceType\u003ctypeof TestView\u003e\u003e(); onMounted(()=\u003e{ console.log(testView.value?.name); }) \u003c/script\u003e \u003ctemplate\u003e \u003cdiv class=\"parentBox\"\u003e \u003cTestView ref=\"testView\"/\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle\u003e .parentBox { width:400px; height:400px; background-color: tomato; display: flex; align-items: center; justify-content: center; } \u003c/style\u003e 使用onMounted函数是为了获取值，因为我们必须在子组件mounted之后，才能拿到值 ","date":"2024-05-18","objectID":"/posts/7729ec4/:3:0","tags":["Vue","前端web"],"title":"Vue笔记10-Vue组件值传递","uri":"/posts/7729ec4/"},{"categories":["前端 - Vue"],"content":" 一：主要分为渲染、更新、销毁三个部分 1：渲染顺序 （先父后子，完成顺序：先子后父） 子组件先挂载，然后到父组件 父 beforeCreate-\u003e父 created-\u003e父 beforeMount-\u003e子 beforeCreate-\u003e子 created-\u003e子 beforeMount-\u003e子 mounted-\u003e父 mounted 2：更新顺序 （父更新导致子更新，子更新完成后父） 子组件更新过程 父 beforeUpdate-\u003e子 beforeUpdate-\u003e子 updated-\u003e父 updated 父组件更新过程 父 beforeUpdate-\u003e父 updated 3：销毁顺序（ 先父后子，完成顺序：先子后父） 父 beforeDestroy-\u003e子 beforeDestroy-\u003e子 destroyed-\u003e父 destroyed ","date":"2024-05-18","objectID":"/posts/43d03f6/:0:0","tags":["Vue","前端web"],"title":"Vue笔记09-Vue生命周期","uri":"/posts/43d03f6/"},{"categories":["前端 - Vue"],"content":" \u003cscript setup lang=\"ts\"\u003e import {watch,ref} from 'vue' let source = ref(''); let length = ref(0); watch(source,(newVal,oldVal)=\u003e{ console.log(oldVal+\"发生变化\\n\"); console.log(\"新值为：\"+newVal); length.value = source.value.length; }) \u003c/script\u003e \u003ctemplate\u003e \u003cinput type=\"text\" v-model=\"source\" /\u003e \u003cspan\u003e{{ length }}\u003c/span\u003e \u003c/template\u003e \u003cstyle\u003e\u003c/style\u003e 也可以监听一个值，当发生变化时候进行异步请求，刷新数据 ","date":"2024-05-18","objectID":"/posts/72020db/:0:0","tags":["Vue","前端web"],"title":"Vue笔记07-Vue watch函数","uri":"/posts/72020db/"},{"categories":["前端 - Vue"],"content":"watch监听属性 ","date":"2024-05-18","objectID":"/posts/72020db/:1:0","tags":["Vue","前端web"],"title":"Vue笔记07-Vue watch函数","uri":"/posts/72020db/"},{"categories":["前端 - Vue"],"content":" \u003cscript setup lang=\"ts\"\u003e import { ref, computed, reactive } from 'vue' type Data = { name: string price: number num: number } const data = reactive\u003cData[]\u003e([ { name: 'banana', price: 12, num: 20 }, { name: 'apple', price: 20, num: 100 }, { name: 'orange', price: 10, num: 200 }, { name: 'watermelon', price: 40, num: 20 } ]) const del = (index: number) =\u003e { data.splice(index, 1) } let keyWord = ref\u003cstring\u003e('') let serachData = computed(() =\u003e { return data.filter((item:Data)=\u003e{ return item.name.includes(keyWord.value) }) }) let total = computed({ get: () =\u003e { return serachData.value.reduce((prev: number, next: Data) =\u003e { return prev + next.num * next.price }, 0) }, set: (val) =\u003e { console.log(val) } }) \u003c/script\u003e \u003ctemplate\u003e \u003cdiv style=\"display: flex; align-items: center; justify-content: center; flex-direction: column\"\u003e \u003cinput placeholder=\"搜索\" type=\"text\" v-model=\"keyWord\" /\u003e \u003ctable border cellpadding=\"0\" cellspacing=\"0\"\u003e \u003cthead\u003e \u003cth\u003e商品名称\u003c/th\u003e \u003cth\u003e商品单价\u003c/th\u003e \u003cth\u003e物品数量\u003c/th\u003e \u003cth\u003e物品总价\u003c/th\u003e \u003cth\u003e操作\u003c/th\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr v-for=\"(item, index) in serachData\" :key=\"index\"\u003e \u003ctd align=\"center\"\u003e{{ item.name }}\u003c/td\u003e \u003ctd align=\"center\"\u003e{{ item.price }}\u003c/td\u003e \u003ctd align=\"center\"\u003e \u003cbutton type=\"button\" @click=\"item.num \u003e= 1 ? item.num-- : null\"\u003e-\u003c/button\u003e{{ item.num }}\u003cbutton type=\"button\" @click=\"item.num++\"\u003e+\u003c/button\u003e \u003c/td\u003e \u003ctd align=\"center\"\u003e{{ item.num * item.price }}\u003c/td\u003e \u003ctd align=\"center\"\u003e \u003cbutton @click=\"del(index)\"\u003e删除\u003c/button\u003e \u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003ctfoot\u003e 总价：{{ total }} \u003c/tfoot\u003e \u003c/table\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle\u003e\u003c/style\u003e ","date":"2024-05-18","objectID":"/posts/3981eaf/:0:0","tags":["Vue","前端web"],"title":"Vue笔记08-Vue computed函数实战","uri":"/posts/3981eaf/"},{"categories":["前端 - Vue"],"content":" \u003cscript setup lang=\"ts\"\u003e import { reactive, toRaw } from 'vue' let obj = reactive({ name: 'meowrain', like: 'jk' }) let change = () =\u003e { console.log(obj) console.log(toRaw(obj)) //解除响应式 } \u003c/script\u003e \u003ctemplate\u003e \u003cdiv\u003e \u003cbutton @click=\"change\"\u003echange\u003c/button\u003e \u003cp\u003eobj-{{ obj }}\u003c/p\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle\u003e\u003c/style\u003e ","date":"2024-05-18","objectID":"/posts/a138da2/:0:0","tags":["Vue","前端web"],"title":"Vue笔记06-Vue toRaw函数使用","uri":"/posts/a138da2/"},{"categories":["前端 - Vue"],"content":"Vue toRef和toRefs妙用 当我们对reactive对象进行解构的时候，解构出来的数据是基本类型，不再具备响应式，没办法更改视图中的 按下按钮后，什么也没变 我们使用toRefs，就能把里面的数据一个个转换为响应式对象返回，再被解构，所有属性依然拥有响应式，还能修改 \u003cscript setup lang=\"ts\"\u003e import { reactive, toRef, toRefs } from 'vue' let obj = reactive({ name: 'meowrain', like: 'jk' }) let {name,like} = toRefs(obj); let change = () =\u003e { name.value = \"meows\"; like.value = \"luolita\" console.log(name,like); } \u003c/script\u003e \u003ctemplate\u003e \u003cdiv\u003e \u003cbutton @click=\"change\"\u003echange\u003c/button\u003e \u003cp\u003eobj-{{ obj }}\u003c/p\u003e \u003cp\u003eName-{{ name }}\u003c/p\u003e \u003cp\u003eLike-{{ like }}\u003c/p\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle\u003e\u003c/style\u003e 按下按钮，可以发现内容改变了 注意以下，obj内容也会被同时修改 toRef函数接受一个响应式对象，一个需要解构出来依然拥有响应式的属性值 举例： \u003cscript setup lang=\"ts\"\u003e import { reactive, toRef, toRefs } from 'vue' let obj = reactive({ name: 'meowrain', like: 'jk' }) let name = toRef(obj,'name'); let change = () =\u003e { name.value = \"meowraintttt\" console.log(name); } \u003c/script\u003e \u003ctemplate\u003e \u003cdiv\u003e \u003cbutton @click=\"change\"\u003echange\u003c/button\u003e \u003cp\u003eobj-{{ obj }}\u003c/p\u003e \u003cp\u003ename-{{ name }}\u003c/p\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle\u003e\u003c/style\u003e ","date":"2024-05-18","objectID":"/posts/3d3a1d4/:0:0","tags":["Vue","前端web"],"title":"Vue笔记05-Vue toRef和toRefs妙用","uri":"/posts/3d3a1d4/"},{"categories":["前端 - Vue"],"content":" \u003cscript setup lang=\"ts\"\u003e import { ref } from 'vue' const dom = ref\u003cHTMLDivElement\u003e() function change() { console.log(dom.value?.innerText) } \u003c/script\u003e \u003ctemplate\u003e \u003cdiv\u003e \u003cbutton @click=\"change\"\u003echange\u003c/button\u003e \u003cdiv ref=\"dom\"\u003eHello Meowrain\u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle\u003e\u003c/style\u003e 在元素上添加ref=\"变量名\",script中写const dom = ref\u003cHTMLDivElement\u003e()，因为采用了setup语法糖，如果直接写在script标签中，得到的结果就是undefined,只有在函数中才能调用. 问题：vue3中reactive对象赋值，不能响应式变化 在使用vue3中，使用reactive创建的对象或者数组进行赋值时，可以正常赋值，但是不会触发响应式变化。 例子： \u003cscript setup lang=\"ts\"\u003e import { ref,reactive } from 'vue' let list = reactive\u003cstring[]\u003e([]); let obj = reactive({}); function add(){ setTimeout(()=\u003e{ obj = { name:'meowrain', age:20 } console.log(obj); },2000) } \u003c/script\u003e \u003ctemplate\u003e \u003cdiv\u003e \u003cbutton @click=\"add\"\u003eadd\u003c/button\u003e \u003cdiv\u003e{{ obj }}\u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle\u003e\u003c/style\u003e 我们按下按钮，等待2秒 可以看到obj的值已经发生了变化，但是页面没有进行渲染,与此同时，obj的响应式对象被破坏(本来应该是Proxy(Object) {}类型的，现在成了纯粹的普通对象了 解决办法 ","date":"2024-05-18","objectID":"/posts/9677752/:0:0","tags":["Vue","前端web"],"title":"Vue笔记04-Vue3利用ref函数获取dom元素内容","uri":"/posts/9677752/"},{"categories":["前端 - Vue"],"content":"方法1 直接添加对象的属性 \u003cscript setup lang=\"ts\"\u003e import { ref,reactive } from 'vue' let list = reactive\u003cstring[]\u003e([]); let obj = reactive({}); console.log(obj); function add(){ setTimeout(()=\u003e{ obj.name = 'meowrain' obj.age = '120' console.log(obj); },2000) } \u003c/script\u003e \u003ctemplate\u003e \u003cdiv\u003e \u003cbutton @click=\"add\"\u003eadd\u003c/button\u003e \u003cdiv\u003e{{ obj }}\u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle\u003e\u003c/style\u003e 按下按钮 数组的话就是调用push,然后把异步获取的数据解构传入就行了 ","date":"2024-05-18","objectID":"/posts/9677752/:1:0","tags":["Vue","前端web"],"title":"Vue笔记04-Vue3利用ref函数获取dom元素内容","uri":"/posts/9677752/"},{"categories":["前端 - Vue"],"content":"方法2 使用ref 不必多说，直接ref包起来给xxx.value赋值就行 ","date":"2024-05-18","objectID":"/posts/9677752/:2:0","tags":["Vue","前端web"],"title":"Vue笔记04-Vue3利用ref函数获取dom元素内容","uri":"/posts/9677752/"},{"categories":["前端 - Vue"],"content":"声明响应式状态 ","date":"2024-05-18","objectID":"/posts/58ef168/:0:0","tags":["Vue","前端web"],"title":"Vue笔记03-声明响应式状态","uri":"/posts/58ef168/"},{"categories":["前端 - Vue"],"content":"ref()​ 在组合式 API 中，推荐使用 ref() 函数来声明响应式状态： import { ref } from 'vue' const count = ref(0) ref() 接收参数，并将其包裹在一个带有 .value 属性的 ref 对象中返回： const count = ref(0) console.log(count) // { value: 0 } console.log(count.value) // 0 count.value++ console.log(count.value) // 1 要在组件模板中访问 ref，请从组件的 setup() 函数中声明并返回它们： import { ref } from 'vue' export default { // `setup` 是一个特殊的钩子，专门用于组合式 API。 setup() { const count = ref(0) // 将 ref 暴露给模板 return { count } } } 注意，在模板中使用 ref 时，我们不需要附加 .value。为了方便起见，当在模板中使用时，ref 会自动解包 (有一些注意事项)。 \u003cscript setup\u003e import {ref} from 'vue'; const count = ref(0); function increment(){ count.value++; return count; } \u003c/script\u003e \u003ctemplate\u003e \u003cdiv\u003e \u003cbutton v-on:click=\"count++\"\u003e{{ count }}\u003c/button\u003e \u003chr\u003e \u003cbutton v-on:click=\"increment\"\u003e{{ count }}\u003c/button\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle scoped\u003e \u003c/style\u003e ","date":"2024-05-18","objectID":"/posts/58ef168/:1:0","tags":["Vue","前端web"],"title":"Vue笔记03-声明响应式状态","uri":"/posts/58ef168/"},{"categories":["前端 - Vue"],"content":"为什么要使用 ref？ 你可能会好奇：为什么我们需要使用带有 .value 的 ref，而不是普通的变量？为了解释这一点，我们需要简单地讨论一下 Vue 的响应式系统是如何工作的。 当你在模板中使用了一个 ref，然后改变了这个 ref 的值时，Vue 会自动检测到这个变化，并且相应地更新 DOM。这是通过一个基于依赖追踪的响应式系统实现的。当一个组件首次渲染时，Vue 会追踪在渲染过程中使用的每一个 ref。然后，当一个 ref 被修改时，它会触发追踪它的组件的一次重新渲染。 另一个 ref 的好处是，与普通变量不同，你可以将 ref 传递给函数，同时保留对最新值和响应式连接的访问。当将复杂的逻辑重构为可重用的代码时，这将非常有用。 ","date":"2024-05-18","objectID":"/posts/58ef168/:1:1","tags":["Vue","前端web"],"title":"Vue笔记03-声明响应式状态","uri":"/posts/58ef168/"},{"categories":["前端 - Vue"],"content":"深层响应性 Ref 可以持有任何类型的值，包括深层嵌套的对象、数组或者 JavaScript 内置的数据结构，比如 Map。 ","date":"2024-05-18","objectID":"/posts/58ef168/:2:0","tags":["Vue","前端web"],"title":"Vue笔记03-声明响应式状态","uri":"/posts/58ef168/"},{"categories":["前端 - Vue"],"content":"模板语法 ","date":"2024-05-18","objectID":"/posts/f3a212f/:0:0","tags":["Vue","前端web"],"title":"Vue笔记02-模板语法","uri":"/posts/f3a212f/"},{"categories":["前端 - Vue"],"content":"文本插值 最基本的数据绑定形式是文本插值，它使用的是“Mustache”语法 (即双大括号)： \u003cspan\u003eMessage: {{ msg }}\u003c/span\u003e 例子： App.vue \u003cscript setup\u003e const msg = 10; \u003c/script\u003e \u003ctemplate\u003e \u003cdiv\u003e \u003cp\u003eHelloWorld\u003c/p\u003e \u003cbr\u003e \u003cp\u003e{{ msg }}\u003c/p\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle scoped\u003e \u003c/style\u003e ","date":"2024-05-18","objectID":"/posts/f3a212f/:1:0","tags":["Vue","前端web"],"title":"Vue笔记02-模板语法","uri":"/posts/f3a212f/"},{"categories":["前端 - Vue"],"content":"原始 HTML 双大括号会将数据解释为纯文本，而不是 HTML。若想插入 HTML，你需要使用 v-html 指令： \u003cp\u003eUsing text interpolation: {{ rawHtml }}\u003c/p\u003e \u003cp\u003eUsing v-html directive: \u003cspan v-html=\"rawHtml\"\u003e\u003c/span\u003e\u003c/p\u003e 例子： \u003cscript setup\u003e const rawHtml = `\u003cspan style=\"color: red\"\u003eThis should be red.\u003c/span\u003e`; \u003c/script\u003e \u003ctemplate\u003e \u003cdiv\u003e \u003cp\u003eHelloWorld\u003c/p\u003e \u003cbr\u003e \u003cp\u003e{{ rawHtml }}\u003c/p\u003e \u003cp v-html=\"rawHtml\"\u003e\u003c/p\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle scoped\u003e \u003c/style\u003e 在网站上动态渲染任意 HTML 是非常危险的，因为这非常容易造成 XSS 漏洞。请仅在内容安全可信时再使用 v-html，并且永远不要使用用户提供的 HTML 内容。 ","date":"2024-05-18","objectID":"/posts/f3a212f/:2:0","tags":["Vue","前端web"],"title":"Vue笔记02-模板语法","uri":"/posts/f3a212f/"},{"categories":["前端 - Vue"],"content":"Attribute 绑定 双大括号不能在 HTML attributes 中使用。想要响应式地绑定一个 attribute，应该使用 v-bind 指令： \u003cdiv v-bind:id=\"dynamicId\"\u003e\u003c/div\u003e v-bind 指令指示 Vue 将元素的 id attribute 与组件的 dynamicId 属性保持一致。如果绑定的值是 null 或者 undefined，那么该 attribute 将会从渲染的元素上移除。 例子： \u003cscript setup\u003e const dynamicId = \"name\"; \u003c/script\u003e \u003ctemplate\u003e \u003cdiv\u003e \u003cp v-bind:id=\"dynamicId\"\u003eHelloWorld\u003c/p\u003e \u003cbr\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle scoped\u003e #name { color: red; font-size: 100px; } \u003c/style\u003e ","date":"2024-05-18","objectID":"/posts/f3a212f/:3:0","tags":["Vue","前端web"],"title":"Vue笔记02-模板语法","uri":"/posts/f3a212f/"},{"categories":["前端 - Vue"],"content":"简写​ 因为 v-bind 非常常用，我们提供了特定的简写语法： \u003cdiv :id=\"dynamicId\"\u003e\u003c/div\u003e 例子： \u003cscript setup\u003e const dynamicId = \"name\"; \u003c/script\u003e \u003ctemplate\u003e \u003cdiv\u003e \u003cp :id=\"dynamicId\"\u003eHelloWorld\u003c/p\u003e \u003cbr\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle scoped\u003e #name { color: red; font-size: 100px; } \u003c/style\u003e ","date":"2024-05-18","objectID":"/posts/f3a212f/:3:1","tags":["Vue","前端web"],"title":"Vue笔记02-模板语法","uri":"/posts/f3a212f/"},{"categories":["前端 - Vue"],"content":"布尔型 Attribute 布尔型 attribute 依据 true / false 值来决定 attribute 是否应该存在于该元素上。disabled 就是最常见的例子之一。 \u003cbutton :disabled=\"isButtonDisabled\"\u003eButton\u003c/button\u003e 例子： \u003cscript setup\u003e const isDisabled = false; \u003c/script\u003e \u003ctemplate\u003e \u003cdiv\u003e \u003cp\u003eHelloWorld\u003c/p\u003e \u003cbr\u003e \u003cbutton :disabled=\"isDisabled\"\u003eButton\u003c/button\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle scoped\u003e \u003c/style\u003e 如果设置isDisabled为false,这个按钮就在页面上消失了 当 isDisabled 为真值或一个空字符串 (即 ) 时，元素会包含这个 disabled attribute。而当其为其他假值时 attribute 将被忽略。 ","date":"2024-05-18","objectID":"/posts/f3a212f/:4:0","tags":["Vue","前端web"],"title":"Vue笔记02-模板语法","uri":"/posts/f3a212f/"},{"categories":["前端 - Vue"],"content":"动态绑定多个值 定义一个对象，其中为标签属性，例如 const attributes = { id: \"btn\", class: \"btn_fonts\" } 例子： \u003cscript setup\u003e const attributes = { id: \"btn\", class: \"btn_fonts\" }; \u003c/script\u003e \u003ctemplate\u003e \u003cdiv\u003e \u003cp\u003eHelloWorld\u003c/p\u003e \u003cbr\u003e \u003cbutton v-bind=\"attributes\"\u003eButton\u003c/button\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle scoped\u003e #btn { width: 100px; height: 200px; background-color: aquamarine; } .btn_fonts { color: red; font-size: 34px; } \u003c/style\u003e ","date":"2024-05-18","objectID":"/posts/f3a212f/:5:0","tags":["Vue","前端web"],"title":"Vue笔记02-模板语法","uri":"/posts/f3a212f/"},{"categories":["前端 - Vue"],"content":"使用 JavaScript 表达式 Vue 实际上在所有的数据绑定中都支持完整的 JavaScript 表达式： {{ number + 1 }} {{ ok ? 'YES' : 'NO' }} {{ message.split('').reverse().join('') }} \u003cdiv :id=\"`list-${id}`\"\u003e\u003c/div\u003e 在 Vue 模板内，JavaScript 表达式可以被使用在如下场景上： 在文本插值中 (双大括号) 在任何 Vue 指令 (以 v- 开头的特殊 attribute) attribute 的值中 例子： \u003cscript setup\u003e const useClass2 = false; const message = \"helloworld\"; \u003c/script\u003e \u003ctemplate\u003e \u003cdiv\u003e \u003cp :class=\"useClass2 ? 'class2':'class1'\"\u003e{{ message.split('').reverse().join('~') }}\u003c/p\u003e \u003cbr\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle scoped\u003e .class1 { color: aliceblue; font-size: 100px; font-weight: lighter; } .class2 { color: red; font-size: 40px; font-weight: bolder; } \u003c/style\u003e ","date":"2024-05-18","objectID":"/posts/f3a212f/:6:0","tags":["Vue","前端web"],"title":"Vue笔记02-模板语法","uri":"/posts/f3a212f/"},{"categories":["前端 - Vue"],"content":"仅支持表达式 每个绑定仅支持单一表达式，也就是一段能够被求值的 JavaScript 代码。一个简单的判断方法是是否可以合法地写在 return 后面。 \u003c!-- 这是一个语句，而非表达式 --\u003e {{ var a = 1 }} \u003c!-- 条件控制也不支持，请使用三元表达式 --\u003e {{ if (ok) { return message } }} ","date":"2024-05-18","objectID":"/posts/f3a212f/:7:0","tags":["Vue","前端web"],"title":"Vue笔记02-模板语法","uri":"/posts/f3a212f/"},{"categories":["前端 - Vue"],"content":"调用函数 可以在绑定的表达式中使用一个组件暴露的方法： \u003cp :title=\"toUp('meowrain')\"\u003e{{ toUp(\"meowrain\") }}\u003c/p\u003e 例子： \u003cscript setup\u003e function toUp(value){ return value.toUpperCase(); } \u003c/script\u003e \u003ctemplate\u003e \u003cdiv\u003e \u003cp :title=\"toUp('meowrain')\"\u003e{{ toUp(\"meowrain\") }}\u003c/p\u003e \u003cbr\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle scoped\u003e \u003c/style\u003e 绑定在表达式中的方法在组件每次更新时都会被重新调用，因此不应该产生任何副作用，比如改变数据或触发异步操作。 ","date":"2024-05-18","objectID":"/posts/f3a212f/:8:0","tags":["Vue","前端web"],"title":"Vue笔记02-模板语法","uri":"/posts/f3a212f/"},{"categories":["前端 - Vue"],"content":"指令 Directives https://cn.vuejs.org/api/built-in-directives.html 指令是带有 v- 前缀的特殊 attribute。Vue 提供了许多内置指令，包括上面我们所介绍的 v-bind 和 v-html。 指令 attribute 的期望值为一个 JavaScript 表达式 (除了少数几个例外，即之后要讨论到的 v-for、v-on 和 v-slot)。一个指令的任务是在其表达式的值变化时响应式地更新 DOM。以 v-if 为例： \u003cp v-if=\"seen\"\u003eNow you see me\u003c/p\u003e 这里，v-if 指令会基于表达式 seen 的值的真假来移除/插入该 元素。 https://cn.vuejs.org/api/built-in-directives.html#v-on … 还有几个具体的自己看文档吧，文档写的很详细 ","date":"2024-05-18","objectID":"/posts/f3a212f/:9:0","tags":["Vue","前端web"],"title":"Vue笔记02-模板语法","uri":"/posts/f3a212f/"},{"categories":["前端 - Vue"],"content":"参数 Arguments 某些指令会需要一个“参数”，在指令名后通过一个冒号隔开做标识。例如用 v-bind 指令来响应式地更新一个 HTML attribute： \u003ca v-bind:href=\"url\"\u003e ... \u003c/a\u003e \u003c!-- 简写 --\u003e \u003ca :href=\"url\"\u003e ... \u003c/a\u003e 这里 href 就是一个参数，它告诉 v-bind 指令将表达式 url 的值绑定到元素的 href attribute 上。在简写中，参数前的一切 (例如 v-bind:) 都会被缩略为一个 : 字符。 另一个例子是 v-on 指令，它将监听 DOM 事件： \u003ca v-on:click=\"doSomething\"\u003e ... \u003c/a\u003e \u003c!-- 简写 --\u003e \u003ca @click=\"doSomething\"\u003e ... \u003c/a\u003e 这里的参数是要监听的事件名称：click。v-on 有一个相应的缩写，即 @ 字符。我们之后也会讨论关于事件处理的更多细节。 ","date":"2024-05-18","objectID":"/posts/f3a212f/:10:0","tags":["Vue","前端web"],"title":"Vue笔记02-模板语法","uri":"/posts/f3a212f/"},{"categories":["前端 - Vue"],"content":"动态参数 同样在指令参数上也可以使用一个 JavaScript 表达式，需要包含在一对方括号内： \u003c!-- 注意，参数表达式有一些约束， 参见下面“动态参数值的限制”与“动态参数语法的限制”章节的解释 --\u003e \u003ca v-bind:[attributeName]=\"url\"\u003e ... \u003c/a\u003e \u003c!-- 简写 --\u003e \u003ca :[attributeName]=\"url\"\u003e ... \u003c/a\u003e 这里的 attributeName 会作为一个 JavaScript 表达式被动态执行，计算得到的值会被用作最终的参数。举例来说，如果你的组件实例有一个数据属性 attributeName，其值为 “href”，那么这个绑定就等价于 v-bind:href。 相似地，你还可以将一个函数绑定到动态的事件名称上： \u003ca v-on:[eventName]=\"doSomething\"\u003e ... \u003c/a\u003e \u003c!-- 简写 --\u003e \u003ca @[eventName]=\"doSomething\"\u003e 在此示例中，当 eventName 的值是 “focus” 时，v-on:[eventName] 就等价于 v-on:focus。 ","date":"2024-05-18","objectID":"/posts/f3a212f/:10:1","tags":["Vue","前端web"],"title":"Vue笔记02-模板语法","uri":"/posts/f3a212f/"},{"categories":["前端 - Vue"],"content":"动态参数值的限制​ 动态参数中表达式的值应当是一个字符串，或者是 null。特殊值 null 意为显式移除该绑定。其他非字符串的值会触发警告。 ","date":"2024-05-18","objectID":"/posts/f3a212f/:10:2","tags":["Vue","前端web"],"title":"Vue笔记02-模板语法","uri":"/posts/f3a212f/"},{"categories":["前端 - Vue"],"content":"动态参数语法的限制 动态参数表达式因为某些字符的缘故有一些语法限制，比如空格和引号，在 HTML attribute 名称中都是不合法的。例如下面的示例： \u003c!-- 这会触发一个编译器警告 --\u003e \u003ca :['foo' + bar]=\"value\"\u003e ... \u003c/a\u003e 当使用 DOM 内嵌模板 (直接写在 HTML 文件里的模板) 时，我们需要避免在名称中使用大写字母，因为浏览器会强制将其转换为小写： \u003ca :[someAttr]=\"value\"\u003e ... \u003c/a\u003e 上面的例子将会在 DOM 内嵌模板中被转换为 :[someattr]。如果你的组件拥有 “someAttr” 属性而非 “someattr”，这段代码将不会工作。单文件组件内的模板不受此限制。 ","date":"2024-05-18","objectID":"/posts/f3a212f/:10:3","tags":["Vue","前端web"],"title":"Vue笔记02-模板语法","uri":"/posts/f3a212f/"},{"categories":["前端 - Vue"],"content":"修饰符 Modifiers 修饰符是以点开头的特殊后缀，表明指令需要以一些特殊的方式被绑定。例如 .prevent 修饰符会告知 v-on 指令对触发的事件调用 event.preventDefault()： \u003cform @submit.prevent=\"onSubmit\"\u003e...\u003c/form\u003e ","date":"2024-05-18","objectID":"/posts/f3a212f/:11:0","tags":["Vue","前端web"],"title":"Vue笔记02-模板语法","uri":"/posts/f3a212f/"},{"categories":["前端 - Vue"],"content":"创建一个 Vue 应用 \u0026 了解vue npm create vue@latest 默认目录结构 vscode环境安装 第一个项目 删除无用文件，重新改下App.vue和router/index.js里面的内容 了解main.js import './assets/main.css' import { createApp } from 'vue' import { createPinia } from 'pinia' import App from './App.vue' import router from './router' const app = createApp(App) app.use(createPinia()) app.use(router) app.mount('#app') 每个 Vue 应用都是通过 createApp 函数创建一个新的 应用实例： ","date":"2024-05-18","objectID":"/posts/755e4bd/:0:0","tags":["Vue","前端web"],"title":"Vue笔记01-创建一个 Vue 应用 \u0026 了解vue","uri":"/posts/755e4bd/"},{"categories":["前端 - Vue"],"content":"根组件 我们传入 createApp 的对象实际上是一个组件，每个应用都需要一个“根组件”，其他组件将作为其子组件。 ","date":"2024-05-18","objectID":"/posts/755e4bd/:1:0","tags":["Vue","前端web"],"title":"Vue笔记01-创建一个 Vue 应用 \u0026 了解vue","uri":"/posts/755e4bd/"},{"categories":["前端 - Vue"],"content":"挂载应用 应用实例必须在调用了 .mount() 方法后才会渲染出来。该方法接收一个“容器”参数，可以是一个实际的 DOM 元素或是一个 CSS 选择器字符串： app.mount('#app') ","date":"2024-05-18","objectID":"/posts/755e4bd/:2:0","tags":["Vue","前端web"],"title":"Vue笔记01-创建一个 Vue 应用 \u0026 了解vue","uri":"/posts/755e4bd/"},{"categories":["Javascript","面向对象"],"content":"Javascript 面向对象(OOP) ","date":"2024-05-18","objectID":"/posts/178f51c/:0:0","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"语法 class 类名 { constructor(){ } } 举例: //Person类专门用来创建人的对象 class Person { constructor(name,age,hooby){ this.name = name; this.age = age; this.hooby = hooby; } } //调用构造函数创建对象创建对象 const xiaoming = new Person(\"xiaoming\",18,'programming'); console.log(xiaoming) ","date":"2024-05-18","objectID":"/posts/178f51c/:1:0","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"instanceOf用法 可以用来检查一个对象是否是由某个类创建,如果某个对象是由某个类创建,那么我们称这个对象是这个类的实例 //Person类专门用来创建人的对象 class Person { constructor(name,age,hooby){ this.name = name; this.age = age; this.hooby = hooby; } } class Dog { } //调用构造函数创建对象创建对象 const xiaoming = new Person(\"xiaoming\",18,'programming'); const dog1 = new Dog(); console.log(xiaoming instanceof Person); //true console.log(dog1 instanceof Person); //false ","date":"2024-05-18","objectID":"/posts/178f51c/:2:0","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"属性 //Person类专门用来创建人的对象 class Person { //在类中写属性,每次创建对象,它都会带有这些实例属性 //实例属性只能通过实例访问 name = \"meowrian\"; age = 17; hobby = \"game\" } const meowrain = new Person(); console.log(meowrain); console.log(meowrain.name,meowrain.age,meowrain.hobby); ","date":"2024-05-18","objectID":"/posts/178f51c/:3:0","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"静态属性 //Person类专门用来创建人的对象 class Person { //静态属性只能通过类名去访问 static test = \"test静态属性\"; } const meowrain = new Person(); console.log(Person.test); ","date":"2024-05-18","objectID":"/posts/178f51c/:3:1","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"方法 //Person类专门用来创建人的对象 class Person { name = \"meowrain\"; sayHello = ()=\u003e{ console.log(\"Hello~\"); } } const p1 = new Person(); console.log(p1) p1.sayHello(); ","date":"2024-05-18","objectID":"/posts/178f51c/:4:0","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"两种添加方法的方式: class Person { name = \"meowrain\"; sayHello = ()=\u003e{ console.log(\"Hello~\"); } sayGoodbye(){ console.log(\"Goodbye~\"); } //这种方式直接打印实例对象看不到这个方法 } const p1 = new Person(); console.log(p1) p1.sayHello(); p1.sayGoodbye(); ","date":"2024-05-18","objectID":"/posts/178f51c/:4:1","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"静态方法(类方法) //Person类专门用来创建人的对象 class Person { static sayGG = ()=\u003e{ console.log(\"GG~\",this);//静态方法中,this指向的是我们的当前类 } } console.log(Person.sayGG()); //只能通过类名来调用 ","date":"2024-05-18","objectID":"/posts/178f51c/:4:2","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"构造函数 class Person { //在类中添加一个特殊的方法constructor //该方法我们称为构造函数 //构造函数会在我们调用类创建对象时候执行 constructor(name, age, gender) { this.name = name; this.age = age; this.gender = gender; console.log(\"构造函数执行了\"); } } const p1 = new Person(\"meowrian\", 18, \"男\"); //调用类创建一次对象 const p2 = new Person(\"meow\", 10, \"男\"); //调用类创建一次对象 console.log(p1.name); ","date":"2024-05-18","objectID":"/posts/178f51c/:5:0","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"封装 //1. 封装 // - 对象就是一个用来存储不同属性的容器 //对象不仅负责属性,还要负责数据的安全 //直接添加到对象中的属性并不安全,因为它们可以被任意修改 // 如何确保数据安全 //提供setter和getter方法,来开放我们对数据的操作 /*实现封装的方式 * 1. 属性私有化 # * 通过getter和setter方法来操作属性 * get 属性名(){ * return this.#属性名; * } * set 属性名(value){ * this._属性名 = value; * } * */ class Person { //用#表示是私有属性 private,只能在类的内部访问 #name; #age; #gender; constructor(name, age, gender) { this.#name = name; this.#age = age; this.#gender = gender; this._name = name; this._age = age; this._gender = gender; } //getter方法,用来读取属性 get name() { return this.#name; } //这样写getter方法,在访问的时候直接用 实例.属性名就能获得 get age() { return this.#age; } get gender() { return this.#gender; } //setter方法,用来设置属性 set name(value) { this._name = value; } set age(value) { this._age = value; } set gender(value) { this._gender = value; } } const p1 = new Person(\"meow\", 17, \"男\"); console.log(p1.name, p1.age, p1.gender); //这些都是调用的getter方法 p1.name = \"meowmeow\"; //这里调用的是上面的setter方法 console.log(p1.name); ","date":"2024-05-18","objectID":"/posts/178f51c/:6:0","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"多态 //多态 /* * 在JS中不会检查参数的类型,所以这就意味着任何数据都可以作为参数传递 * 要调用某个函数,无需指定的类型,只需要对象满足某些条件计即可 * * */ class Person { constructor(name) { this.name = name; } } class Dog { constructor(name) { this.name = name; } } class Test { } const dog = new Dog('旺财'); const person = new Person(\"喵雨\"); const test = new Test(); // console.log(dog); // console.log(person); /*定义一个函数,这个函数将会接受一个对象作为参数,可以输出hello,并且打印name属性*/ const sayHello = (obj)=\u003e { if (obj.name == undefined) { console.log(\"没有name属性,hello毛呢\") } else if(obj instanceof Person){ console.log(\"Hello 人:\" + obj.name); }else { console.log(\"Hello \"+ obj.name); } } sayHello(dog); sayHello(person); sayHello(test); ","date":"2024-05-18","objectID":"/posts/178f51c/:7:0","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"继承 class Animal { constructor(name) { this.name = name; } sayHello() { console.log(\"Animal\") } } class Dog extends Animal{ constructor(name) { super(name); } sayHello() { console.log(\"旺\") } //重写父类方法 } class Cat extends Animal{ constructor(name) { super(name); } sayHello() { console.log(\"meow\") } } const dog = new Dog(\"旺财\"); const cat = new Cat(\"汤姆\"); dog.sayHello(); cat.sayHello(); ","date":"2024-05-18","objectID":"/posts/178f51c/:8:0","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"对象的结构 对象中存储属性的区域实际有两个: 对象自身 直接通过对象添加的属性,位于对象自身中 在类中通过x = y的形式添加的属性,位于对象自身中 class Person { name = \"meowrian\" age = 18 fun = ()=\u003e{ console.log('ffff'); } constructor(hobby) { this.hobby = hobby } } const p = new Person(\"打篮球\"); 原型对象(prototype) 对象中还有一些内容,会存储在其他的对象里(原型对象) 在对象中会有一个属性用来存储原型对象,这个属性叫做 __proto__ class Person { fun(){ console.log(\"hello\") } //添加到原型中 constructor(hobby) { this.hobby = hobby } } const p = new Person(\"打篮球\"); console.log(p) 会添加到原型对象中的情况: 在类中通过xxx(){}方式添加的方法,位于原型中 主动向原型中添加的属性和方法 ","date":"2024-05-18","objectID":"/posts/178f51c/:9:0","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"原型 相关链接:__proto__和prototype的区别 ","date":"2024-05-18","objectID":"/posts/178f51c/:10:0","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"__proto__ class Person { name = \"meowrain\" sayHello(){kde ubuntu console.log(\"hello,我是\" + this.name); } } const p = new Person(); /* * 访问一个对象的原型对象 对象.__proto__ * console.log(Object.getPrototypeOf(对象)); * */ console.log(p.__proto__);//{constructor: ƒ, sayHello: ƒ} console.log(Object.getPrototypeOf(p));//{constructor: ƒ, sayHello: ƒ} 原型的作用； 原型就相当于是一个公共的区域，可以被所有该类实例访问 可以将一个该类实例中所有的公共属性统一存储到原型中 这样我们只需要创建一个属性，即可被所有实例访问 ","date":"2024-05-18","objectID":"/posts/178f51c/:10:1","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"prototype class Person { sayHello(){ console.log(\"hello\") } } const p1 = new Person(); console.log(Person.prototype); console.log(Person.prototype === p1.__proto__); //true 可以通过上面两种方式完成类的修改 ","date":"2024-05-18","objectID":"/posts/178f51c/:10:2","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"Object.hasOwn用法 用来检查一个对象的自身是否含有某个属性 MDN文档-Object.hasOwn class Man { name = \"liming\"; } const man1 = new Man(); console.log(Object.hasOwn(man1, \"name\")) //true ","date":"2024-05-18","objectID":"/posts/178f51c/:10:3","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"旧类 早期js中,直接通过函数来定义类 一个函数如果直接调用xx(),那么这个函数就是一个普通函数 一个函数如果通过调用new xxx()那么这个函数就是一个构造函数 function Person (){ } const p = new Person(); 上面的等价于下面的 class Person { } const p = new Person(); function Person(name,age){ //构造函数里面写的内容就是class中constructor写的内容 this.name = name; this.age = age; this.sayHello = function (){ console.log(\"hello\") } } //向原型中添加 Person.prototype.sayNice = function (){ console.log(\"nice\") } const p = new Person(\"meowrain\",12); console.log(p.name); // meowrain console.log(p.age); // 12 p.sayHello(); //hello p.sayNice();//nice console.log(p); 如上图,从上图我们可以看到,sayNice方法被添加到原型中了 ","date":"2024-05-18","objectID":"/posts/178f51c/:11:0","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"旧类静态属性,静态方法… var Person = ( function () { //构造函数 function Person(name, age) { this.name = name; this.age = age; } //静态属性 Person.staticProperty = \"hobby\"; Person.hobby = \"nice\"; console.log(Person.hobby);//nice //静态方法 Person.staticMethod = function () { console.log(\"good\"); }; Person.staticMethod(); // good //创建实例 const p = new Person(\"meowrain\", 12); console.log(p.name); console.log(p.age); //返回对象 return Person; })(); 继承: var Animal = (function () { function Animal(name, age) { this.name = name; this.age = age; } return Animal; })(); var Cat = (function () { function Cat(name, age) { this.name = name; this.age = age; } //继承Animal Cat.prototype = new Animal(); return Cat; })(); const cat1 = new Cat(\"meow\", 2); console.log(cat1); ","date":"2024-05-18","objectID":"/posts/178f51c/:11:1","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Javascript","面向对象"],"content":"new运算符 new运算符是创建对象时候使用的运算符 new运算符-MDN docs ","date":"2024-05-18","objectID":"/posts/178f51c/:12:0","tags":["Javascript","面向对象"],"title":"Javascript 面向对象","uri":"/posts/178f51c/"},{"categories":["Java","面向对象"],"content":"Java面向对象(高级) 面型对象高级 面型对象中级 面型对象初级 ","date":"2024-05-18","objectID":"/posts/0112cbb/:0:0","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"类变量/类方法 类变量/类方法-博客园 ","date":"2024-05-18","objectID":"/posts/0112cbb/:1:0","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"类变量快速入门 介绍 类变量（又叫静态变量）是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量。 定义类变量：访问修饰符 static 数据类型 变量名; 静态变量是类加载的时候，就创建了,所以我们没有创建对象实例 定义一个变量 count ,是一个类变量(静态变量) static 静态 该变量最大的特点就是会被Child 类的所有的对象实例共享 package cn.meowrain.classVariable; public class var01 { public static void main(String[] args) { Child child01 = new Child(\"mike\"); Child child02 = new Child(\"john\"); child01.count++; child02.count++; System.out.println(\"共有\" + Child.count + \"个小朋友参加了游戏\"); } } class Child { private String name; public static int count = 0; public Child(String name){ this.name = name; } public void join() { System.out.println(\"小朋友\" + name + \"加入了游戏....\"); } } 输出: 共有2个小朋友参加了游戏 访问类变量 可以通过 类名.类变量名 或者 对象名.类变量名 来访问，但Java设计者推荐我们使用 类名.类变量名 的方式来访问。 package cn.meowrain.classVariable; public class var01 { public static void main(String[] args) { Child child01 = new Child(\"mike\"); Child child02 = new Child(\"john\"); child01.join(); child02.join(); System.out.println(\"共有\" + Child.count + \"个小朋友参加了游戏\"); //通过 对象名.类变量名 来访问 } } class Child { private String name; public static int count = 0; public Child(String name){ this.name = name; } public void join() { System.out.println(\"小朋友\" + name + \"加入了游戏....\"); count++; } } ","date":"2024-05-18","objectID":"/posts/0112cbb/:1:1","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"类方法 介绍 类变量也叫静态变量。 定义格式如下：访问修饰符 static 数据返回类型 方法名(){} 类方法经典使用场景 （1）当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率。 （2）比如工具类中的方法 utils Math类、Arrays类、Collections集合类 （3）在实际开发中，往往将一些通用的方法，设计成静态方法，这样我们不需要创建对象就可以使用，比如打印一维数组，冒泡排序等等 类方法和普通方法的区别 类方法中不允许使用和对象有关的关键字， 比如this 和super。普通方法(成员方法)可以。 类方法中，只能访问 静态变量 或 静态方法；而普通方法既可以访问普通变量（方法），也可以访问静态的。 类方法可以重写吗？ 可以被继承，但是不能被重写，如果父子类静态方法名相同，则会隐藏derive类方法（调用base类的方法） 静态方法是编译时绑定的，方法重写是运行时绑定的。 https://blog.csdn.net/m0_37974032/article/details/81157433 类方法的使用： 使用： 如下： package cn.meowrain.classVariable; public class var02 { } class Caculate { public static void main(String[] args) { int sum01 = sum(1, 2); int sum02 = sum(5, 10, 20); System.out.println(sum01 + \" \" + sum02);//3 35 } public static int sum(int a, int b) { return a + b; } public static int sum(int a, int b, int c) { return a + b + c; } } ","date":"2024-05-18","objectID":"/posts/0112cbb/:1:2","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"理解main方法 直接看下面这个文章就行了，写得很不错 https://www.cnblogs.com/ffforward/p/15253293.html ","date":"2024-05-18","objectID":"/posts/0112cbb/:2:0","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"Java代码块 基本介绍 代码块又称为初始化块，属于类中的成员，类似于方法，把逻辑语句封装在方法体中，通过{}包围起来 其在创建对象时隐式调用 基本语法 [修饰符]{ 代码 } 说明： (1) 修饰符可选，要写的话，也只能写static (2) 代码块分为两类，使用static修饰的叫静态代码块，没有static修饰的，叫普通代码块 (3) 逻辑语句可以为任何逻辑语句（输入、输出、方法调用、循环、判断等 (4) 分号；可以写上，也可以省略 代码块的好处 （1）相当于另外一种形式的构造器（对构造器的补充机制），可以做初始化的操作。 （2）如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的复用性 实际使用： 如下，我们的三个构造器中都含有System.out.println(\"Welcome to Code World!\");，这使得代码很冗杂，使用代码块，就能让这个代码更好看一些，代码块会在每次类创建时调用 package cn.meowrain.codeBlock; public class code01 { public static void main(String[] args) { code01_child child01 = new code01_child(\"mike\"); code01_child child02 = new code01_child(\"meme\", 15); code01_child child03 = new code01_child(\"meow\", 18, \"bear\"); } } class code01_child { String name; int age; String love; public code01_child(String name) { this.name = name; System.out.println(\"Welcome to Code World!\"); System.out.println(\"hello \" + name); } public code01_child(String name, int age) { this.name = name; this.age = age; System.out.println(\"Welcome to Code World!\"); System.out.println(\"hello \" + name); } public code01_child(String name,int age,String love) { this.name = name; this.love = love; this.age = age; System.out.println(\"Welcome to Code World!\"); System.out.println(\"hello \" + name); } } ·············修改版··················· package cn.meowrain.codeBlock; public class code01 { public static void main(String[] args) { code01_child child01 = new code01_child(\"mike\"); code01_child child02 = new code01_child(\"meme\", 15); code01_child child03 = new code01_child(\"meow\", 18, \"bear\"); } } class code01_child { String name; int age; String love; { System.out.println(\"Welcome to Code World!\"); } public code01_child(String name) { this.name = name; System.out.println(\"hello \" + name); } public code01_child(String name, int age) { this.name = name; this.age = age; System.out.println(\"hello \" + name); } public code01_child(String name,int age,String love) { this.name = name; this.love = love; this.age = age; System.out.println(\"hello \" + name); } } 输出结果： Welcome to Code World! hello mike Welcome to Code World! hello meme Welcome to Code World! hello meow static 代码块 static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，并且只会执行一次。 实际使用： package cn.meowrain.codeBlock; public class code01 { public static void main(String[] args) { code01_child child01 = new code01_child(\"mike\"); code01_child child02 = new code01_child(\"meme\", 15); code01_child child03 = new code01_child(\"meow\", 18, \"bear\"); } } class code01_child { String name; int age; String love; static{ System.out.println(\"Welcome to Code World!\"); } public code01_child(String name) { this.name = name; System.out.println(\"hello \" + name); } public code01_child(String name, int age) { this.name = name; this.age = age; System.out.println(\"hello \" + name); } public code01_child(String name,int age,String love) { this.name = name; this.love = love; this.age = age; System.out.println(\"hello \" + name); } } 输出结果： 因为静态代码块只执行一次，所以只输出一次 Welcome to Code World! Welcome to Code World! hello mike hello meme hello meow ","date":"2024-05-18","objectID":"/posts/0112cbb/:3:0","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"代码块使用注意事项 static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，只会执行一次。如果是普通代码块，每创建一个对象，就执行一次。可以看上面的代码和运行结果 类什么时候被加载？ 创建对象实例 new 的时候 创建子类对象实例，父类也会被加载 使用类的静态成员时（静态属性，静态方法） package cn.meowrain.codeBlock; public class code02 { public static void main(String[] args) { int c = A.sum(109, 10); } } class A { static{ System.out.println(\"hello\"); } public static int sum(int a,int b){ return a+b; } } class B extends A{ } 运行结果： hello 由上可见,静态代码块会在类加载的时候执行 普通的代码块，在创建对象实例（new的时候），会被隐式调用，如果只是单纯使用类中的静态变量，普通代码块不会被执行 package cn.meowrain.codeBlock; public class code02 { public static void main(String[] args) { int c = A.sum(109, 10); } } class A { { System.out.println(\"hello\"); } static int a = 10; public static int sum(int a, int b) { return a + b; } } class B extends A { } 输出结果： 无 创建一个对象的时候，在一个类的调用顺序是: 调用静态代码块和静态属性初始化，按照顺序调用 调用普通代码块和普通属性的初始化，按照顺序调用 调用构造方法 package cn.meowrain.codeBlock; public class code03 { public static void main(String[] args) { AB ab = new AB(); } } class AB { static { System.out.println(\"静态代码块初始化\"); } static int a = getN1(); public static int getN1(){ System.out.println(\"静态方法getN1初始化\"); return 100; } int c = getN2(); public int getN2() { System.out.println(\"普通方法getN2初始化\"); return 200; } public AB(){ System.out.println(\"构造器被调用\"); } } 运行结果如下 静态代码块初始化 静态方法getN1初始化 普通方法getN2初始化 构造器被调用 ","date":"2024-05-18","objectID":"/posts/0112cbb/:3:1","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"单例设计模式 参考https://www.cnblogs.com/ffforward/p/15259948.html ","date":"2024-05-18","objectID":"/posts/0112cbb/:4:0","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"介绍： 单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法 单例模式有两种： 饿汉式 懒汉式 ","date":"2024-05-18","objectID":"/posts/0112cbb/:4:1","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"实现方式 构造器私有化 类的内部创建对象 向外暴露一个静态的公共方法 ","date":"2024-05-18","objectID":"/posts/0112cbb/:4:2","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"饿汉式 类加载的时候实例化，并且创建单例对象 构造器私有化 在类的内部直接创建对象，该对象为static 提供一个公共的static方法，返回这个对象 package cn.meowrain.singlecasemode; class test { public static void main(String[] args) { Hungry hungry = Hungry.getInstance(); System.out.println(hungry.name); } } public class Hungry { public String name; private Hungry(String name){ this.name = name; } //构造器私有化 private static Hungry hungry = new Hungry(\"hello\"); public static Hungry getInstance(){ return hungry; } } ","date":"2024-05-18","objectID":"/posts/0112cbb/:4:3","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"懒汉式 懒汉式： 默认不会实例化，什么时候用什么时候new 构造器私有化 定义一个static静态属性对象 提供一个public的static方法，可以返回一个该类对象 懒汉式，只有当用户使用getInstance时，才返回对象，后面再次调用时，会返回上次创建的该类对象，从而保证单例 package cn.meowrain.singlecasemode; class test02 { public static void main(String[] args) { Lazy lazy = Lazy.getInstanceOf(); System.out.println(lazy.name); } } public class Lazy { public String name; private Lazy(String name){ this.name = name; } private static Lazy lazy = null; public static Lazy getInstanceOf(){ if(lazy==null){ lazy = new Lazy(\"mmm\"); } return lazy; } } ","date":"2024-05-18","objectID":"/posts/0112cbb/:4:4","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"饿汉式和懒汉式的区别 （1）二者最主要的区别在于创建对象的时机不同： 饿汉式是在类加载时就创建了对象实例， 而懒汉式是在使用时才创建。 （2）饿汉式不存在线程安全问题，懒汉式存在线程安全问题。 （3）饿汉式存在浪费资源的可能（没有使用到这个对象实例），而懒汉式不存在这个问题。 （4）在javaSE标准类中，java.lang.Runtime就是经典的单例模式。 ","date":"2024-05-18","objectID":"/posts/0112cbb/:4:5","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"final关键字 ","date":"2024-05-18","objectID":"/posts/0112cbb/:5:0","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"基本介绍： final可以修饰类，属性，方法和局部变量 使用环境： 1. 当不希望类被继承时，可以用final修饰 2. 当不希望父类的某个方法被子类覆盖/重写时，可以用final关键字修饰 3. 当不希望类的某个属性的值被修改，可用final修饰 4. 当不希望某个局部变量被修改，可以用final修饰 ","date":"2024-05-18","objectID":"/posts/0112cbb/:5:1","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"final使用注意事项 final修饰的属性又叫常量 final修饰的属性在定义的时候，必须赋初值，并且以后不能再修改 如果final修饰的属性是静态的，则初始化的位置只能是 1.定义时 2.在静态代码块中可以赋值，不能在构造器中赋值 final类不能继承，但是可以实例化对象 如果类不是final类，但是有final方法，则该方法虽然不能重写，但可以被继承 6.final和static往往搭配使用，效率更高，不会导致类加载，底层编译器做了优化处理 包装类(Integer,Double,Float,Boolean等都是final)，String也是final类 Java内部类 ","date":"2024-05-18","objectID":"/posts/0112cbb/:5:2","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"1.内部类定义 把一个类定义在另一个类内部称为内部类 ","date":"2024-05-18","objectID":"/posts/0112cbb/:6:0","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"2.内部类分类 成员内部类 成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式： class Circle { private double radius = 0; public Circle(double radius) { this.radius = radius; } class Draw { //内部类 public void drawSahpe() { System.out.println(\"drawshape\"); } } } 类Draw像是类Circle的一个成员，Circle称为外部类。 ** 成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。** class Circle { private double radius = 0; public Circle(double radius) { this.radius = radius; } public void calculateArea() { System.out.println(Math.PI * radius * radius); } class Draw { //内部类 public void drawSahpe() { System.out.println(\"drawshape\"); calculateArea(); } } } class Test { public static void main(String[] args) { Circle circle = new Circle(12); circle.new Draw().drawSahpe(); } } 当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。 如果要访问外部类的同名成员，需要以下面的形式进行访问： 外部类.this.成员变量 外部类.this.成员方法 class Shape { private String shape; public Shape(String shape) { this.shape = shape; } public void getShape() { System.out.println(\"The shape is \" + shape + \"in OuterClass\"); } class Circle { //内部类 private String shape; private int radius; public Circle(int radius,String shape) { this.radius = radius; this.shape = shape; } public void getShape() { System.out.println(\"The shape is Circle in InnerClass\"); } public void getArea() { getShape(); //调用内部类的方法 Shape.this.getShape(); //调用外部类的方法 System.out.println(Math.PI*radius*radius); } } } class Test { public static void main(String[] args) { Shape shape = new Shape(\"Circle\"); Shape.Circle circle = shape.new Circle(2,\"CircleInnerClass\"); circle.getArea(); } } 像这样，可以看到，内部类和外部类有同名方法和属性，我们使用内部类调用了内部类的getArea方法，然后getShape()先取得是内部类得方法，如果想调用外部类方法，就只能用`外部类.this.xxx方法/属性名来调用外部类得同名方法了。 外部类访问内部类 虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问： class Circle { private double radius = 0; public Circle(double radius) { this.radius = radius; new Draw().drawSahpe(); //必须先创建成员内部类的对象，再进行访问 } class Draw { //内部类 public void drawSahpe() { System.out.println(radius); //外部类的private成员 } } } 成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下： class Outer { public Inner getInnerInstance() { return new Inner(); } class Inner { } } public class Test { public static void main(String[] args) { Outer o = new Outer(); Outer.Inner in = o.new Inner(); //第一种 Outer.Inner in2 = o.getInnerInstance(); //第二种 } } 内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。比如上面的例子，如果成员内部类Inner用private修饰，则只能在外部类的内部访问，如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。 局部内部类 局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。 public class Test { public static void main(String[] args) { People man = new People(\"meowrain\").createMan(\"meowrain\", 20); man.outputInfo(); } } class People { String name; public People(String name) { this.name = name; } public void outputInfo() { System.out.println(\"The man's name is \" + name + \"\\n\"); } public People createMan(String name, int age) { class Man extends People { int age; public Man(String name, int age) { super(name); this.age = age; } public void outputInfo() { System.out.println(\"The man's name is \" + name + \"\\n\" + \"age is :\" + age); } } return new Man(name, age); } } 匿名内部类 匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。 不使用匿名内部类 interface func { public void sayHello(); public void PlayGames(); } class Human implements func { String name; int age; public Human(String name, int age) { this.name = name; this.age = age; } @Override public void sayHello() { System.out.println(\"Hello World\"); } @Override public void PlayGames() { System.out.println(\"Playing Games now\"); } public void outputInfo() { System.out.println(\"The human's name is \" + name + \"\\n\" + \"The human's age is \" + age); } } public class Anoymous { public static void main(String[] args) { Human human = new Human(\"meowrain\", 20); human.PlayGames(); human.sayHello(); human.outputInfo(); } } 》 在上面的代码中，我们没有使用匿名内部类，但是实现了func接口 接下来我们使用匿名内部类 //可以直接访问外部类的所有成员，包含私有的 //如果外部类和匿名内部类的成员重名时，匿名内部类访问的话， //默认遵循就近原则，如果想访问外部类的成员，则","date":"2024-05-18","objectID":"/posts/0112cbb/:6:1","tags":["Java","面向对象"],"title":"Java面向对象基础(高级)","uri":"/posts/0112cbb/"},{"categories":["Java","面向对象"],"content":"Java面向对象基础（中级） Consolas, ‘Courier New’, monospace ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:0:0","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"包 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:1:0","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"包的三大作用 1.区分相同名字的类 2.当类很多的时候，可以很好地管理类 3.控制访问范围 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:1:1","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"包的基本语法 1.package 关键字 2. com.xxxx 表示包名 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:1:2","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"包的本质分析 包的本质就是创建不同的文件夹和目录来保存类文件 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:1:3","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"包的命名 只能包含数字，下划线，小圆点，但不能用数字开头，也不能是关键字和保留字 命名规范： com.xxxx.usr 用户模块 com.xxxx.utils 工具模块 域名反着写，最后加上模块名 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:1:4","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"常用的包 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:1:5","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"引入包 语法：import 包名.类名 案例： package cn.meowrain.Object_.package_; import java.util.Scanner; public class package_01 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(); System.out.println(a); } } ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:1:6","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"访问修饰符 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:2:0","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"封装 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:3:0","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"封装介绍 封装就是把抽象出的数据[属性]和对数据的操作**[方法]封装在一起，数据被保护在内部，程序的其它部分只有通过被授权的操作[方法]**，才能对数据进行操作 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:3:1","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"封装的理解和好处 隐藏实现细节 可以对数据进行验证，保证安全合理 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:3:2","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"封装实现的步骤 将属性进行私有化（不能直接修改属性） 提供一个公共的(public)set方法，用于对属性判断并赋值 public void setXXX(类型 参数名) { // XXX表示某个属性 //加入数据验证的业务逻辑 属性 = 参数名; } 提供一个公共的(public)get方法，用于获取属性的值 public 数据类型 getXXX(){ //权限判断，xxx某个属性 return xxx; } ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:4:0","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"快速入门案例 package cn.meowrain.Encap_; public class encap_01 { public static void main(String[] args) { Person person = new Person(); person.setName(\"meowrainyyds\"); person.setAge(-1); } } class Person { public String name; private int age; private double salary; private String job; public void setName(String name) { if(name.length()\u003e=6||name.length()\u003c=2){ System.out.println(\"名字的长度错误，长度需要在2-6之间\"); }else { this.name = name; } } public void setAge(int age) { if(age\u003c=1||age\u003e=120){ System.out.println(\"输入年龄错误(1-120)\"); }else { this.age = age; } } public void setSalary(double salary) { this.salary = salary; } public void setJob(String job) { this.job = job; } public String getName() { return name; } public int getAge() { return age; } public double getSalary() { return salary; } public String getJob() { return job; } public void getInfo() { System.out.println(name + \" \" + \"is\" + age + \"years old\"); } } ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:4:1","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"把构造器和封装结合 在构造器中添加 setName(name); setAge(age); 即可实现构造的时候调用这两个函数，从而判断输入的数据是否符合要求，然后使用这两个函数进行赋值 package cn.meowrain.Encap_; public class encap_01 { public static void main(String[] args) { Person person = new Person(\"meowrainyyds\", -1); person.getInfo(); } } class Person { public String name; private int age; private double salary; private String job; public Person(String name, int age) { setName(name); setAge(age); } public void setName(String name) { if (name.length() \u003e= 6 || name.length() \u003c= 2) { System.out.println(\"名字的长度错误，长度需要在2-6之间\"); } else { this.name = name; } } public void setAge(int age) { if (age \u003c= 1 || age \u003e= 120) { System.out.println(\"输入年龄错误(1-120)\"); } else { this.age = age; } } public void setSalary(double salary) { this.salary = salary; } public void setJob(String job) { this.job = job; } public String getName() { return name; } public int getAge() { return age; } public double getSalary() { return salary; } public String getJob() { return job; } public void getInfo() { System.out.println(name + \" \" + \"is\" + age + \"years old\"); } } ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:4:2","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"课堂练习 package cn.meowrain.Encap_; public class encap_02 { } class Account { String name; int balance; public Account(String name, int balance) { setName(name); setBalance(balance); } public void setName(String name) { if (name.length() \u003e= 2 \u0026\u0026 name.length() \u003c= 4) { this.name = name; }else{ System.out.println(\"名字长度在2-4位之间，你输入的名字不合法\"); } } public void setBalance(int balance) { if(balance\u003e20){ this.balance = balance; }else { System.out.println(\"余额必须大于20\"); } } public void getInfo(){ System.out.println(name + \" \" + balance); } } class AccountTest { public static void main(String[] args) { Account account = new Account(\"meowrain\", 24); account.getInfo(); } } ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:4:3","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"继承 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:5:0","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"为什么需要继承 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:5:1","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"继承的基本介绍和示意图 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:5:2","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"继承的基本语法 class 子类 extends 父类{ } 1.子类就会自动拥有父类定义的属性和方法 2.父类又叫超类和基类 3.子类又叫做派生类 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:5:3","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"快速入门案例 package cn.meowrain.extends_; public class extends_01 { public static void main(String[] args) { Student student = new Student(\"mike\", 17, 100); student.eat(); //mike is eating } } class Human { String name; int age; public Human(String name, int age) { this.name = name; this.age = age; } //下面这个eat方法是共有的方法 public void eat(){ System.out.println(name + \" is \" + \"eating\"); } } class Student extends Human { //Student继承了父类Human的所有属性 double grades; public Student(String name, int age, double grades) { super(name, age);//构造器要使用super this.grades = grades; } } ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:5:4","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"继承给编程带来的便利 复用性增强 代码的扩展性和维护性提高 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:5:5","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"细节问题 子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问，要通过父类提供公共的方法去访问 子类必须调用父类的构造器，完成父类的初始化 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用super去指定使用父类的哪个构造器完成对父类的初始化工作，否则编译不会通过 如果希望指定去调用父类的某个构造器，则显式地调用一下：super(参数列表) super在使用时，必须放在构造器第一行（super只能在构造器中使用） super()和this()都只能放在构造器的第一行，因此这两个方法不能共存在一个构造器 super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。 this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。 java所有类都是 Object类的子类，Object类是所有类的基类 父类构造器的调用不限于直接父类，将一直往上追溯直到 Object类 子类最多只能继承一个父类 不能滥用继承，子类和父类之间必须满足is-a的逻辑关系 package cn.meowrain.extends_; public class extends_02 { } class Base { int n1; int n2; String name; public Base() { }// 无参构造器 public Base(int n1) { this.n1 = n1; } public Base(int n1, int n2) { this.n1 = n1; this.n2 = n2; } public Base(int n1, int n2, String name) { this(n1, n2); /* * 这个this(n1,n2); * 相当于调用上面的 this.n1 = n1; this.n2 = n2; */ this.name = name; } } class kids extends Base { int age; public kids(int n1,int n2,int age){ super(n1,n2); /* super(n1,n2); * 相当于 * this.n1 = n1; this.n2 = n2; */ this.age = age; } } class adult extends Base { public adult(int n1,int n2,String name){ super(n1,n2,name); } } class little_kids extends kids { String love; public little_kids(int n1,int n2,int age,String love){ super(n1,n2,age); this.love = love; } } ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:5:6","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"继承的本质分析 看下面这些代码 package com.hspedu.extend_; /** * 讲解继承的本质 */ public class ExtendsTheory { public static void main(String[] args) { Son son = new Son();// 内存的布局 // ?-\u003e 这时请大家注意，要按照查找关系来返回信息 // (1) 首先看子类是否有该属性 // (2) 如果子类有这个属性，并且可以访问，则返回信息 // (3) 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回信息..) // (4) 如果父类没有就按照(3)的规则，继续找上级父类，直到 Object... // System.out.println(son.name);//返回就是大头儿子 // System.out.println(son.age);//返回的就是 39 // System.out.println(son.getAge());//返回的就是 39 System.out.println(son.hobby);// 返回的就是旅游 } } class GrandPa { // 爷类 String name = \"大头爷爷\"; String hobby = \"旅游\"; } class Father extends GrandPa {// 父类 String name = \"大头爸爸\"; private int age = 39; public int getAge() { return age; } } class Son extends Father { // 子类 String name = \"大头儿子\"; } 子类创建的内存布局 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:5:7","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"练习 会输出 a b name b 分析：B类无参构造器中，其实第一句是隐藏的super()，所以会先执行A类的无参构造器，输出a，然后执行this(\"abc\")，调用B类本类下的有参构造器，输出b name，接着执行System.out.println(\"b\")，输出b 编写 Computer 类，包含 CPU、内存、硬盘等属性，getDetails 方法用于返回 Computer 的详细信息 编写 PC 子类，继承 Computer 类，添加特有属性【品牌 brand】 编写 NotePad 子类，继承 Computer 类，添加特有属性【color】 编写 Test 类，在 main 方法中创建 PC 和 NotePad 对象，分别给对象中特有的属性赋值，以及从 Computer 类继承的属性赋值，并使用方法并打印输出信息 package cn.meowrain.extends_; class Test { public static void main(String[] args) { PC pc = new PC(\"i5\", 16, 512, \"Lenovo\"); Notepad notepad = new Notepad(\"j1900\", 8, 64, \"white\"); pc.getDetails(); notepad.getDetails(); } } public class Computer { String brand; String cpu; int memory; int disk_size; public Computer(String cpu, int memory, int disk_size) { this.cpu = cpu; this.memory = memory; this.disk_size = disk_size; } public void getDetails() { System.out.println(\"the computer's\" + \" \" + \"cpu is \" + cpu + \" \" + \"the memory size is \" + memory + \" \" + \"the disk size is\" + \" \" + disk_size); } } class PC extends Computer { String brand; public PC(String cpu, int memory, int disk_size, String brand) { super(cpu, memory, disk_size); this.brand = brand; } public void getDetails() { System.out.println(\"the computer's brand is\" + brand + \" \" + \"cpu is \" + cpu + \" \" + \"the memory size is \" + memory + \" \" + \"the disk size is\" + \" \" + disk_size); } } class Notepad extends Computer { String color; public Notepad(String cpu, int memory, int disk_size, String color) { super(cpu, memory, disk_size); this.color = color; } public void getDetails() { System.out.println(\"the computer's color is\" + color + \" \" + \"cpu is \" + cpu + \" \" + \"the memory size is \" + memory + \" \" + \"the disk size is\" + \" \" + disk_size); } } ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:5:8","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"super关键字 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:6:0","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"基本介绍 super代表父类的引用，用于访问父类的属性，方法和构造器 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:6:1","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"基本语法 访问父类的属性，但是不能访问父类的 private属性 使用：super.属性名 访问父类的方法，不能访问父类的private方法 使用：super.方法名(参数列表) 访问父类的构造器 使用：super(参数列表) 只能放在构造器的第一句，只能出现一句 案例： package cn.meowrain.extends_; public class super_ { public static void main(String[] args) { Child_01 child = new Child_01(); child.getRes(); } } class Base_01 { public String name = \"mike\"; private int age = 8; public int getSum(int a,int b) { return a+b; } } class Child_01 extends Base_01 { public String name = super.name;//把父类的name属性的值赋值给自雷的name属性 // public int age = super.age; 报错 public void getRes(){ System.out.println(super.getSum(19, 20));//调用并且输出父类中getSum方法的返回值 } } ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:6:2","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"super给编程带来的便利 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:6:3","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"super和this的比较 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:6:4","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"方法重写（Override） ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:7:0","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"基本介绍 方法重写就是子类有一个方法，和父类的某个方法的名称，返回类型，参数一样，那么我们就说子类的这个方法覆盖了父类的方法 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:7:1","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"快速入门 package cn.meowrain.extends_; public class override_ { public static void main(String[] args) { Child_02 child_02 = new Child_02(); child_02.getInfo(); } } class Base_02 { public void getInfo() { System.out.println(\"hello my friends\"); } } class Child_02 extends Base_02 { @Override public void getInfo() { System.out.println(\"hello my good friends\"); } } ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:7:2","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"注意项 子类方法不能缩小父类方法的访问权限 子类方法的形参列表，方法名称，要和父类方法的形参列表，方法名称完全一样 子类方法的返回类型和父类方法的返回类型要一样，或者是父类返回类型的子类，比如：父类返回类型是Object，子类方法返回的类型是String ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:7:3","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"方法重写和重载的区别 重载是 https://meowrain.cn/archives/java-mian-xiang-dui-xiang-ji-chu--chu-ji- 中的内容，回顾清看上面链接的内容 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:7:4","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"多态 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:8:0","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"基本介绍 方法或对象具有多种形态，是面向对象的第三大特征，多态是建立在封装和继承基础上的 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:8:1","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"多态存在的三个必要条件 继承 重写 父类引用指向子类对象：Parent p = new Child(); ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:8:2","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"多态的具体体现 方法的多态 上图代码实现： Shap.java package cn.meowrain.Poly; public class Shape { public void draw(){ System.out.println(\"画图形\"); } } Circle.java package cn.meowrain.Poly; public class Circle extends Shape{ public void draw(){ System.out.println(\"画圆形\"); } } Square.java package cn.meowrain.Poly; public class Square extends Shape{ public void draw(){ System.out.println(\"画方形\"); } } Triangle.java package cn.meowrain.Poly; public class Triangle extends Shape{ public void draw(){ System.out.println(\"画三角形\"); } } Runner.java package cn.meowrain.Poly; public class Runner { public static void main(String[] args) { Shape circle = new Circle(); circle.draw(); Shape triangle = new Triangle(); triangle.draw(); Shape square = new Square(); square.draw(); } } 注意： 1.一个对象的编译类型和运行类型可以不一致 2.编译类型在定义对象时就确定了，不能改变 3.运行类型是可以变化的 4.编译类型看定义时候=号的左边，运行类型看=号的右边 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:8:3","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"多态注意事项和细节讨论 多态的前提是： 两个对象（类）存在继承关系 多态的向上转型 本质：父类的引用指向了子类的对象 语法：==父类类型 引用名 = new 子类类型();== 特点：编译类型看左边，运行类型看右边 可以调用父类中的所有成员（需遵守访问权限） 不能调用子类中的特有成员–\u003e只能调用子类和父类共有的成员 最终运行效果看子类的具体实现 多态的向下转型 语法： ==子类类型 引用名 = (子类类型)父类引用;== 只能强制转父类的引用，不能强转父类的对象 要求父类的引用必须指向的是当前目标类型的对象 当向下转型后，可以调用子类类型中所有成员 案例演示: Animal.java package cn.meowrain.Poly.poly02; public class Animal { String name = \"动物\"; int age = 10; public void sleeper() { System.out.println(\"睡\"); } public void run() { System.out.println(\"跑\"); } public void eat(){ System.out.println(\"吃\"); } public void show() { System.out.println(\"hello 你好\"); } } Cat.java package cn.meowrain.Poly.poly02; public class Cat extends Animal{ public void eat(){ //方法重写 System.out.println(\"猫吃鱼\"); } public void catchMouse() {//cat特有方法 System.out.println(\"猫抓老鼠\"); } } PolyDetail.java package cn.meowrain.Poly.poly02; public class PolyDetail { public static void main(String[] args) { //向上转型,父类的引用指向了子类的对象 Animal animal = new Cat(); //animal.catchMouse() 错误,只能调用共同的属性 //因为在编译阶段,能调用哪些成员,是由编译类型决定的 //最终运行效果看运行类型的具体实现 animal.eat(); animal.run(); animal.show(); animal.sleeper(); //如果想调用Cat的catchMouse方法 //多态的向下转型 //子类类型 引用名 = (子类类型)父类引用 Cat cat = (Cat)animal; cat.catchMouse(); } } 注意: 属性没有重写只说! 属性的值看编译类型,也就是左侧 看下面的代码: package cn.meowrain.Poly.poly03; public class item { public static void main(String[] args) { Base base = new Sub(); //属性的值看编译类型 System.out.println(base.count);//120 } } class Base {//父类 int count = 120; } class Sub extends Base { //子类 int count = 234; } instanceOf比较操作符 介绍: instanceOf比较操作符,用于判断对象的运行类型是否为XX类型的子类型 举个例子: package cn.meowrain.Poly.poly03; public class PolyDetail03 { public static void main(String[] args) { BB bb = new BB(); //运行类型是BB System.out.println(bb instanceof BB); //true System.out.println(bb instanceof AA); //true //向上转型 //AA是编译类型,BB是运行类型 AA aa = new BB();//运行类型是BB System.out.println(aa instanceof AA); //true System.out.println(aa instanceof BB);// true //向下转型 BB ab = (BB)aa;//运行类型是BB System.out.println(ab instanceof AA); //true System.out.println(ab instanceof BB); //true AA am = new AA(); //运行类型是AA System.out.println(am instanceof AA);// true System.out.println(am instanceof BB); //false } } class AA { } class BB extends AA { } ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:8:4","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"java的动态绑定 当调用对象方法的的时候，该方法回和该都西昂的内存地址/运行类型绑定 当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用 在向上转型情况下的动态绑定示例 父类方法，对象类型：class cn.meowrain.bind.Son package cn.meowrain.bind; public class bind01 { public static void main(String[] args) { Father sample = new Son();//向上转型 sample.method(); } } class Father { public void method(){ System.out.println(\"父类方法，对象类型：\" + this.getClass()); } } class Son extends Father { } 声明的是父类的引用，但是调用了子类对象，调用method，子类中没有这个方法，就去父类中去找，然后进行调用 接下来我们修改子类，在子类中重写method方法 package cn.meowrain.bind; public class bind01 { public static void main(String[] args) { Father sample = new Son();//向上转型 sample.method(); } } class Father { public void method(){ System.out.println(\"父类方法，对象类型：\" + this.getClass()); } } class Son extends Father { @Override public void method() { System.out.println(\"子类方法，对象类型： \" +this.getClass()); } } 子类方法，对象类型： class cn.meowrain.bind.Son 掉用子类对象，子类中含有method方法，所以调用子类中的这个method方法 注意： 下面说到的不属于动态绑定 运行时（动态）绑定针对的范畴只是对象的方法。 接下来我们来看一看属性绑定 package cn.meowrain.bind; public class bind01 { public static void main(String[] args) { Father sample = new Son();//向上转型 System.out.println(sample.name); } } class Father { String name = \"父类属性\"; } class Son extends Father { String name = \"子类属性\"; } 运行结果： 父类属性 从上面我们可以看出，输出是由编译类型决定的 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:9:0","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"多态的应用 多态数组 数组的定义类型是父类类型，里面保存的实际元素类型为子类类型 应用实例：： 现有一个结构如下，要求创建1个Person对象，2个Student对象和2个Teacher对象，统一放在数组中，并调用每个对象的say方法 package cn.meowrain.bind; public class bind02 { public static void main(String[] args) { Person[] persons = new Person[5]; persons[0] = new Person(\"jack\", 20); persons[1] = new Student(\"mike\", 18, 100); persons[2] = new Student(\"meowrain\", 19, 150); persons[3] = new Teacher(\"gac\", 24, 110); persons[4] = new Teacher(\"jjj\", 25, 123); // persons[i]编译类型是Person，运行类型是根据实际情况通过JVM判断的 for (int i = 0; i \u003c persons.length; i++) { System.out.println(persons[i].say());// 动态绑定机制 if (persons[i] instanceof Student) { Student student = (Student) persons[i];//向下转型 student.study(); //可以用下面这个替代 // ((Student)persons[i]).study(); } else if (persons[i] instanceof Teacher) { Teacher teacher = (Teacher) persons[i];//向下转型 teacher.teach(); //可以用下面这个替代 // ((Teacher)persons[i]).teach(); } } } } class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String say() { return \"Perosn \" + getName() + \" is \" + getAge() + \"years old\"; } } class Student extends Person { private int score; public Student(String name, int age, int score) { super(name, age); this.score = score; } public int getScore() { return score; } public void setScore(int score) { this.score = score; } @Override public String say() { return \"Student \" + getName() + \" \" + \"is\" + \" \" + \"learning\" + \" \" + \"his score is \" + getScore(); } public void study() { System.out.println(\"student \" + getName() + \"is learning\"); } } class Teacher extends Person { private double salary; public Teacher(String name, int age, double salary) { super(name, age); this.salary = salary; } public double getSalary() { return salary; } public void setSalary(double salary) { this.salary = salary; } @Override public String say() { return \"Teacher \" + getName() + \"is teaching\" + \" \" + \"his salary is \" + getSalary(); } public void teach() { System.out.println(\"Teacher \" + getName() + \"is teaching\"); } } 多态参数 方法定义的形参类型为父类类型，实参类型允许为子类类型 定义员工类Employee,包含姓名和月工资（private)，以及计算年工资getAnnual的方法，普通员工和经理继承了员工，经理类多了奖金bonus和管理manage方法，普通员工多了work方法，普通员工和经理类要求分别重写getAnnual方法 测试类中添加一个方法showEmpAnnual(Employee e),实现获取任何员工对象的年工资，并在main方法中调用该方法[e.getAnnual] 测试类中添加一个方法，testWork,如果是普通员工，就调用那个work方法。如果是经理，就调用manage方法 Test.java package cn.meowrain.Poly.poly04; public class Test { public double showEmpAnnual(Employee e) { return e.getAnnual(); } public void testWork(Employee e){ if(e instanceof NormalEmployee){ ((NormalEmployee)e).work(); }else if (e instanceof Manager){ ((Manager)e).manage(); } } public static void main(String[] args) { NormalEmployee worker = new NormalEmployee(\"mike\", 4000); Manager manager = new Manager(\"john\", 4300, 5000); Test test = new Test(); System.out.println(\"管理者工资： \" + test.showEmpAnnual(manager)); System.out.println(\"工人工资： \" + test.showEmpAnnual(worker)); test.testWork(manager); test.testWork(worker); } } Employee.java package cn.meowrain.Poly.poly04; public class Employee { private String name; private double salary; public Employee(String name, double salary) { this.name = name; this.salary = salary; } public String getName() { return name; } public void setName(String name) { this.name = name; } public double getSalary() { return salary; } public void setSalary(double salary) { this.salary = salary; } public double getAnnual () { return salary*12; } } Manager.java package cn.meowrain.Poly.poly04; public class Manager extends Employee{ private double bonus; public Manager(String name, double salary, double bonus) { super(name, salary); this.bonus = bonus; } public double getBonus() { return bonus; } public void setBonus(double bonus) { this.bonus = bonus; } public void manage(){ System.out.println(\"Manager \" + getName() + \" \" + \"is managing\"); } @Ove","date":"2024-05-18","objectID":"/posts/f4f8ed5/:9:1","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"Object类详解 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:10:0","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"equals方法 == 是一个比较运算符 在看下面这个东西之前，我们先抛出一个问题 String属于什么数据类型？ https://zhuanlan.zhihu.com/p/136468277 引用类型 基本数据类型和引用数据类型详见Java数据类型：基本数据类型和引用数据类型 (biancheng.net) 区分 package com.hsp.object; public class Equals_exercise02 { public static void main(String[] args) { String name_1 = \"hello\"; String name_2 = \"hello\"; System.out.println(name_2 == name_1);//true /* * String str1 = \"abcd\"的实现过程：首先栈区创建str引用， * 然后在String池（独立于栈和堆而存在，存储不可变量） * 中寻找其指向的内容为\"abcd\"的对象，如果String池中没有， * 则创建一个，然后str指向String池中的对象， * 如果有，则直接将str1指向\"abcd\"\"； * 如果后来又定义了字符串变量 str2 = \"abcd\", * 则直接将str2引用指向String池中已经存在的“abcd”， * 不再重新创建对象；当str1进行了赋值（str1=“abc”）， * 则str1将不再指向\"abcd\"，而是重新指String池中的\"abc\"， * 此时如果定义String str3 = \"abc\",进行str1 == str3操作， * 返回值为true，因为他们的值一样，地址一样， * 但是如果内容为\"abc\"的str1进行了字符串的+连接str1 = str1+\"d\" * ；此时str1指向的是在堆中新建的内容为\"abcd\"的对象， * 即此时进行str1==str2，返回值false，因为地址不一样。 String str3 = new String(\"abcd\")的实现过程： * 直接在堆中创建对象。 * 如果后来又有 * String str4 = new String(\"abcd\")，str4不会指向之前的对象， * 而是重新创建一个对象并指向它， * 所以如果此时进行str3==str4返回值是false， * 因为两个对象的地址不一样，如果是str3.equals(str4)， * 返回true,因为内容相同。 * */ String name_3 = new String(\"hello\"); String name_4 = new String(\"hello\"); System.out.println(name_3 == name_4);//false System.out.println(name_3.equals(name_4)); System.out.println(name_1.equals(name_2)); } } ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:10:1","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"hashCode方法 提高具有哈希结构的容器效率 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的 两个引用，如果指向的是不同的对象，则哈希值是不一样的 哈希值主要根据地址号来的，不能将哈希值等价于地址 package com.hsp.object; public class HashCode { public static void main(String[] args) { AA aa = new AA(); AA aa2 = new AA(); System.out.println(aa.hashCode()); System.out.println(aa2.hashCode()); /*460141958 1163157884*/ } } class AA {} ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:10:2","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"toString方法 基本介绍： 默认返回： 全类名 + @ + 哈希值的十六进制 子类往往重写toString方法，用于返回对象的属性信息 package com.hsp.object; public class toString { public static void main(String[] args) { Monster monster = new Monster(\"妖怪\",\"保安\",1000); System.out.println(monster.toString());//com.hsp.object.Monster@1b6d3586 } } class Monster { private String name; private String job; private double sal; public Monster(String name, String job, double sal) { this.name = name; this.job = job; this.sal = sal; } } 重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式 package com.hsp.object; public class toString { public static void main(String[] args) { Monster monster = new Monster(\"妖怪\",\"保安\",1000); System.out.println(monster.toString());//Monster{name='妖怪', job='保安', sal=1000.0} } } class Monster { private String name; private String job; private double sal; // 重写toString方法 @Override public String toString() { return \"Monster{\" + \"name='\" + name + '\\'' + \", job='\" + job + '\\'' + \", sal=\" + sal + '}'; } public Monster(String name, String job, double sal) { this.name = name; this.job = job; this.sal = sal; } } 当直接输出一个对象时候，toString方法会被默认的调用 package com.hsp.object; public class toString { public static void main(String[] args) { Monster monster = new Monster(\"妖怪\", \"保安\", 1000); System.out.println(monster); } } class Monster { private String name; private String job; private double sal; // 重写toString方法 @Override public String toString() { return \"Monster{\" + \"name='\" + name + '\\'' + \", job='\" + job + '\\'' + \", sal=\" + sal + '}'; } public Monster(String name, String job, double sal) { this.name = name; this.job = job; this.sal = sal; } } ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:10:3","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["Java","面向对象"],"content":"finalize() 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法 1.当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作 2.什么时候被回收：当某个对象没有任何引用的时候，则jvm就认为这个对象是一个垃圾对象，就会用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用finalize方法 3.垃圾回收机制的调用，是由系统来决定，也可以由System.gc()主动触发垃圾回收机制 实际开发中基本不会运用，应付面试 ","date":"2024-05-18","objectID":"/posts/f4f8ed5/:10:4","tags":["Java","面向对象"],"title":"Java面向对象基础(中级)","uri":"/posts/f4f8ed5/"},{"categories":["面向对象","Java"],"content":"Java面向对象基础(初级) 对面向对象和面向过程的理解 谈谈你对面向过程和面向对象的理解_智十七°的博客-CSDN博客_面向对象和面向过程的理解 ","date":"2024-05-18","objectID":"/posts/61c8cb0/:0:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"面向对象的三大特征 封装 (Encapsulation) 继承 (Inheritance) 多态 (Polymorphism) ","date":"2024-05-18","objectID":"/posts/61c8cb0/:1:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"初识对象和类 ","date":"2024-05-18","objectID":"/posts/61c8cb0/:2:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"初次使用对象和类 如下，在下面这个代码中，我创建了一个猫类，然后利用猫类创建了两个猫对象，一个赋值给cat01，一个赋值给cat02 package cn.meowrain.Object_; public class relean_01 { public static void main(String[] args) { //创建两猫对象 Cat cat01 = new Cat(); cat01.name = \"小花\"; cat01.age = 1; cat01.color = \"花色\"; Cat cat02 = new Cat(); cat02.name = \"小白\"; cat02.age = 2; cat02.color = \"白色\"; //访问对象属性 System.out.println(cat01.name); System.out.println(cat02.name); cat01.eat(); cat02.eat(); } } class Cat { public String name; public int age; public String color; public void eat(){ System.out.println(name + \"吃饭\"); } public void drink(){ System.out.println(name + \"喝水\"); } } new Cat() //创建一只猫对象 Cat cat01 = new Cat();//把创建的猫对象赋值给cat01 cat01是对象名(对象引用) ","date":"2024-05-18","objectID":"/posts/61c8cb0/:3:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"如何创建一个对象 1) 先声明再创建 Cat cat ; //声明对象 cat cat = new Cat(); //创建 2) 直接创建 Cat cat = new Cat(); 补充：Java中实例化对象是什么意思 在Java语言中使用new关键字创建/构造对象的过程叫做类的实例化，该过程的本质，会在内存空间的堆区申请一块存储区域，用于记录该对象独有的成员变量信息。 通俗点就是，实例化：使用关键字new来创建对象。 例如： Person person = new Person(); 这样的语句称为创建对象。 对象是根据类创建的。在Java中使用关键字new创建对象。 new Person(); 是 声明一个Person类型的对象，在堆区区域。 new Person(); ()是指创建Person类型的对象后，自动调用Person类中的构造方法，来进行成员变量的初始化。 Person person ，Person为类名，person 为引用变量名。 ———————————————— 版权声明：本文为CSDN博主「智十七°」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/weixin_45812336/article/details/113954823 ","date":"2024-05-18","objectID":"/posts/61c8cb0/:3:1","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"对象在内存中的存在形式 ","date":"2024-05-18","objectID":"/posts/61c8cb0/:4:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"属性，成员变量 package cn.meowrain.Object_; public class relearn_02 { } class Hunman { //下面都属于Human类的属性 String name; double salary; int age; String country; } 属性是类的一个组成部分，一般是基本数据类型,也可是引用类型(对象，数组)。上面这个代码中的name,salary等都是这个Human类的属性 属性的定义语法同变量， 示例：访问修饰符 属性类型 属性名 访问修饰符详情见Java 访问修饰符 - 喵雨の小屋|木更老婆！！！ (meowrain.cn) 属性的定义类型可以为任意类型，包含基本类型或引用类型 基本数据类型和引用数据类型详见Java数据类型：基本数据类型和引用数据类型 (biancheng.net) Java数据类型（八种基本数据类型 + 四种引用数据类型）_火火笔记的博客-CSDN博客_引用数据类型有哪几种 属性如果不赋值，有默认值，规则和数组一致。 具体: ==int 0，short 0, byte 0, long 0, float 0.0,double 0.0，char \\u0000， boolean false，String null== ","date":"2024-05-18","objectID":"/posts/61c8cb0/:5:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"如何访问属性 基本语法 对象名.属性名; 示范： package cn.meowrain.Object_; public class relearn_02 { Human human01 = new Human(); human01.name = \"mike\"; human01.age = 20; System.out.println(human.name + \"is\" + human01.age + \"years old\") } class Hunman { //下面都属于Human类的属性 String name; double salary; int age; String country; } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:5:1","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"类和对象的内存分配机制 我们定义一个人类(Person)(包括 名字,年龄) package cn.meowrain.Object_; public class relearn_03 { public static void main(String[] args) { Person p1 = new Person(); p1.age = 10; p1.name = \"小明\"; Person p2 = p1; System.out.println(p2.age); } } class Person { public int age; public String name; } 问题：p2.age 究竟是多少，画出内存图 ","date":"2024-05-18","objectID":"/posts/61c8cb0/:6:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"Java 内存的结构分析 栈： 一般存放基本数据类型(局部变量) 堆： 存放对象(Cat cat , 数组等) 方法区：常量池(常量，比如字符串)， 类加载信息 Java 创建对象的流程简单分析 ","date":"2024-05-18","objectID":"/posts/61c8cb0/:6:1","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"方法重载 java中允许同一个类中，多个同名方法的存在，但是要求形参列表不一致 通过重载，我们减轻了起名的麻烦 案例： package cn.meowrain.Object_; public class relearn_06 { public static void main(String[] args) { rel rel = new rel(); int m = rel.getSum(1,2,3); System.out.println(m); int n = rel.getSum(1,2); } } class rel { public int getSum(int n1,int n2){ return n1+n2; } public int getSum(int n1,int n2,int n3){ return n1+n2+n3; } } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:7:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"可变参数 java允许把同一个类中多个同名同功能但是参数个数不同的方法，封装成一个方法 基本语法： //int... 表示接受的是可变参数，类型是int，即可以接收多个int //使用可变参数时候，可以当数组来使用，nums可以当做数组 package cn.meowrain.Object_; public class relearn_07 { public static void main(String[] args) { rel_07 rel = new rel_07(); int m = rel.getSum(1,2,3,4);//10 int n = rel.getSum(5,6,7);//18 int b = rel.getSum(0,1);//1 System.out.println(m); System.out.println(n); System.out.println(b); } } class rel_07 { //int... 表示接受的是可变参数，类型是int，即可以接收多个int //使用可变参数时候，可以当数组来使用，nums可以当做数组 public int getSum(int... nums){ int res = 0; for(int i = 0;i\u003cnums.length;i++){ res+=nums[i]; } return res; } } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:7:1","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"作用域 package cn.meowrain.Object_; public class relearn_08 { public static void main(String[] args) { } } class Dog { //全局变量：也就是属性，作用域为整个类体Cat类，cry eat等方法使用属性 //属性在定义时，可以直接赋值 int age = 10; double weight;//默认是0.0 public void hi() { //局部变量必须赋值后才能使用，因为没有默认值 //局部变量一般是指在成员方法中定义的变量 int num = 1; String address = \"Beijing's Dog\"; System.out.println(\"num=\" + num); System.out.println(\"address\" + address); System.out.println(\"weight=\" + weight); } public void cry() { int n = 10; String name = \"jack\"; System.out.println(name + \"cry for\" + n + \"times\"); } public void eat() { String name = \"meow\"; System.out.println(name + \"eat\"); } } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:8:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"注意事项和使用细节 属性可以加修饰符，但是局部变量不能加修饰符 ","date":"2024-05-18","objectID":"/posts/61c8cb0/:8:1","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"构造器 构造方法又叫构造器(constructor)，是类的一种特殊的方法， 它的主要作用是完成对新对象的初始化。它有几个特点： 方法名和类名相同 没有返回值 在创建对象时，系统会自动的调用该类的构造器完成对象的初始化。 基本语法： [修饰符] 方法名(形参列表) { 方法体 } 案例： package cn.meowrain.Object_; public class relearn_09 { public static void main(String[] args) { rel_09 rel = new rel_09(\"meowrain\", 18); rel_09 rel_1 = new rel_09(\"meow\", 20, \"mouse\"); rel.getInfo(); rel_1.getItem(); } } class rel_09 { String name; int age; String item; public rel_09(String name, int age) { this.name = name; this.age = age; } // 构造器重载 public rel_09(String name, int age, String item) { this.name = name; this.age = age; this.item = item; } public void getInfo() { System.out.println(this.name + \" \" + this.age); } public void getItem() { System.out.println(this.item); } } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:9:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"练习题： package cn.meowrain.Object_; public class relearn_10 { public static void main(String[] args) { Person_n person01 = new Person_n(\"meow\", 12); Person_n person02 = new Person_n(); System.out.println(person01.name + \" is \" + person01.age + \"years old\"); System.out.println(person02.name + \" is \" + person02.age + \"years old\"); } } class Person_n { String name; int age; public Person_n() { this.age = 18; } public Person_n(String name, int age) { this.name = name; this.age = age; } } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:9:1","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"对象创建的流程分析 ","date":"2024-05-18","objectID":"/posts/61c8cb0/:10:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"this关键字 什么是this? ==简单说：哪个对象调用，this就代表哪个对象== package cn.meowrain.Object_; public class relearn12 { } class This01 { public static void main(String[] args) { Dog_new dog_new = new Dog_new(\"大黄\", 1); dog_new.info(); } } class Dog_new { String name; int age; public Dog_new(String name,int age) { this.name = name; this.age = age; } public void info(){ System.out.println(\"this.hashCode=\" + this.hashCode()); System.out.println(name + \"\\t\" + age + \"\\t\"); } } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:11:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"练习题： package cn.meowrain.Object_; public class relearn13 { public static void main(String[] args) { person_01 p1 = new person_01(\"mary\", 18); person_01 p2 = new person_01(\"mary\",18); System.out.println(p1.compareTo(p2)); //true } } class person_01 { String name; int age; public person_01(String name, int age) { this.name = name; this.age = age; } public boolean compareTo(person_01 p){ if(this.name.equals(p.name)\u0026\u0026this.age == p.age) { return true; } return false; } } 作业 ","date":"2024-05-18","objectID":"/posts/61c8cb0/:11:1","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"作业1 package cn.meowrain.Object_.homework; public class h1 { public static void main(String[] args) { double[] arr = { 1.0, -2.0, 4.5 }; A01 a01 = new A01(); double max = a01.max(arr); System.out.println(max); } } class A01 { public double max(double[] a) { double m = a[0]; for (int i = 0; i \u003c a.length; i++) { if (a[i] \u003e m) m = a[i]; } return m; } } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:12:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"作业2 package cn.meowrain.Object_.homework; public class h2 { public static void main(String[] args) { String[] strArr = {\"helloworld\",\"meowrain\"}; A02 a02 = new A02(); int a = a02.find(strArr); if(a == 0){ System.out.println(true); }else { System.out.println(false); } } } class A02 { public int find(String []arr){ for (int i = 0; i \u003c arr.length; i++){ if(arr[i].equals(\"helloworld\")){ return i; } } return -1; } } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:13:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"作业3 package cn.meowrain.Object_.homework; public class h3 { public static void main(String[] args) { Book book = new Book(\"猫的故事\", 200); Book book2 = new Book(\"狗的故事\", 120); Book book3 = new Book(\"驴的故事\", 20); book.updatePrice(book.price); book2.updatePrice(book2.price); book3.updatePrice(book3.price); System.out.println(book.name + \" : \" + book.price); System.out.println(book2.name + \" : \" + book2.price); System.out.println(book3.name + \" : \" + book3.price); /* * 猫的故事 : 150.0 狗的故事 : 100.0 驴的故事 : 20.0 * */ } } class Book { String name; double price; public Book(String name,double price) { this.name = name; this.price = price; } public void updatePrice(double price){ if(price \u003e 150){ this.price = 150; }else if(price \u003e 100) { this.price = 100; } } } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:14:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"作业4 package cn.meowrain.Object_.homework; public class h4 { public static void main(String[] args) { A03 a03 = new A03(); int[] arr = {1,2,3,4,5}; int[] a1 = a03.copyArr(arr); for(int i=0;i\u003ca1.length; i++){ System.out.println(a1[i]); } } } class A03 { public int[] copyArr(int[] arr) { int[] a = new int[arr.length]; for (int i = 0; i \u003c arr.length; i++){ a[i] = arr[i]; } return a; } } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:15:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"作业5 package cn.meowrain.Object_.homework; public class h5 { public static void main(String[] args) { Circle circle = new Circle(2); double perimeter = circle.perimeter(); double area = circle.area(); System.out.printf(\"%.2f\\n\",perimeter); System.out.printf(\"%.2f\\n\",area); /* * 12.57 12.57 */ } } class Circle { double r; public Circle(double r) { this.r = r; } public double perimeter() { return Math.PI*r*2; } public double area() { return Math.PI * r * r; } } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:16:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"作业6 package cn.meowrain.Object_.homework; public class h6 { public static void main(String[] args) { Cale cale01 = new Cale(5, 2); Cale cale02 = new Cale(1, 0); cale01.divide(); cale02.divide(); } } class Cale { int a, b; public Cale(int a, int b) { this.a = a; this.b = b; } public int sum() { return a + b; } public int multiply() { return a * b; } public void divide() { if (b == 0) { System.out.println(\"输入的除数不能为0！\"); } else { System.out.println(a * 1.0 / b); } } } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:17:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"作业7 package cn.meowrain.Object_.homework; public class h7 { public static void main(String[] args) { Dog dog = new Dog(\"mike\",\"white\",2); dog.show(); } } class Dog { String name; String color; int age; public Dog(String name,String color,int age){ this.name = name; this.color = color; this.age = age; } public void show(){ System.out.println(\"the dog \" + name + \" is \" + age + \" \" + \"years old and its color is \" + color); } } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:18:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"作业8 ","date":"2024-05-18","objectID":"/posts/61c8cb0/:19:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"作业9 package cn.meowrain.Object_.homework; public class h9 { public static void main(String[] args) { Music music01 = new Music(\"青花瓷\", \"4:00\"); Music music02 = new Music(\"鸡你太美\", \"3:00\"); music01.getInfo(); music01.play(); } } class Music { String name; String times; public Music(String name,String times){ this.name = name; this.times = times; } public void play(){ System.out.println(name + \"is palying for \" + times); } public void getInfo(){ System.out.println(\"the music name is \" + name + \"times is : \" + times); } } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:20:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"作业10 package cn.meowrain.Object_.homework; public class h8 { int i = 100; public void m(){ int j = i++; System.out.println(\"i=\" + i); System.out.println(\"j=\" + j); } } class Test { public static void main(String[] args) { h8 demo = new h8(); h8 demo2 = new h8(); demo.m(); System.out.println(demo.i); System.out.println(demo2.i); } } i=101 j=100 101 100 ","date":"2024-05-18","objectID":"/posts/61c8cb0/:21:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"作业11 不做了 ","date":"2024-05-18","objectID":"/posts/61c8cb0/:22:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"作业12 package cn.meowrain.Object_.homework; public class h12 { Employee_ emp1 = new Employee_(\"经理\", \"10000\"); } class Employee_ { String name; String sex; int age; String position; String salary; public Employee_(String name, String sex, int age, String position, String salary) { this.name = name; this.sex = sex; this.age = age; this.position = position; this.salary = salary; } public Employee_(String name, String sex, int age) { this.name = name; this.sex = sex; this.age = age; } public Employee_(String position, String salary) { this.position = position; this.salary = salary; } } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:23:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["面向对象","Java"],"content":"作业13 package cn.meowrain.Object_.homework; public class h13 { public static void main(String[] args) { Circle01 circle = new Circle01(); PassObject pass = new PassObject(); pass.printAreas(circle, 5); } } class Circle01 { public double radius; public double findArea(){ return radius*radius*Math.PI; } } class PassObject { public void printAreas(Circle01 c,int times) { for(int i = times;i\u003e0;i--){ c.radius = i; System.out.println(\"r:\" + i + \" \" + \"S=\" + c.findArea()); } } } ","date":"2024-05-18","objectID":"/posts/61c8cb0/:24:0","tags":["Java","面向对象"],"title":"Java面向对象基础(初级)","uri":"/posts/61c8cb0/"},{"categories":["C++","面向对象"],"content":"C++ OOP ","date":"2024-05-18","objectID":"/posts/ae3b30e/:0:0","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"Class(1) ","date":"2024-05-18","objectID":"/posts/ae3b30e/:1:0","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"private,protected,public private(默认就是 private) private 声明的类的私有成员只能由同一类的其他成员或者它们的朋友访问 #include \u003ciostream\u003e #include \u003cstring\u003e class Student { private: int score; public: std::string name; int age; Student(std::string _name,int _age,int _score) : name(_name),age(_age),score(_score){ } void getScore(){ std::cout \u003c\u003c score \u003c\u003c std::endl; } }; int main(void) { Student s(\"meow\",18,100); s.getScore(); } 我们如果在 main 函数中直接用对象输出学生的分数，就不能 #include \u003ciostream\u003e #include \u003cstring\u003e class Student { private: int score; public: std::string name; int age; Student(std::string _name,int _age,int _score) : name(_name),age(_age),score(_score){ } void getScore(){ std::cout \u003c\u003c score \u003c\u003c std::endl; } }; int main(void) { Student s(\"meow\",18,100); std::cout \u003c\u003c s.score \u003c\u003c std::endl; } protected protected 受保护的成员可以从同一类的其他成员（或从他们的“朋友”）访问，也可以从其派生类的成员访问。 #include \u003ciostream\u003e #include \u003cstring\u003e class Human { protected: std::string name; public: Human(std::string _name): name(_name){} void getHumanInfo() { std::cout \u003c\u003c \"Human name is: \" \u003c\u003c name \u003c\u003c std::endl; } //同一类成员访问 }; class Student:Human{ public: int score; Student(std::string _name,int _score): Human(_name),score(_score) { } void getStudentInfo() { std::cout \u003c\u003c \"Student name is :\" \u003c\u003c name \u003c\u003c \"\\tStudent score is :\" \u003c\u003c score \u003c\u003c std::endl; } }; //派生类成员访问 int main(void) { Student s(\"meow\",100); s.getStudentInfo(); Human h(\"meow\"); h.getHumanInfo(); return 0; } public 公共成员可以从对象可见的任何地方访问。 这里不作代码解释了。😊 ","date":"2024-05-18","objectID":"/posts/ae3b30e/:1:1","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"实现类成员函数 #include \u003ciostream\u003e class Square { int width; int height; public: void setWidth(int _width) { width = _width; } void setHeight(int _height) { height = _height; } int getArea(); int getPerimeter(); }; int Square::getArea() { return width * height; } int Square::getPerimeter() { return 2*(width + height); } int main() { Square s; s.setHeight(10); s.setWidth(19); std::cout \u003c\u003c s.getArea() \u003c\u003c std::endl; } 当然了，构造函数也可以在外面实现!😊 #include \u003ciostream\u003e #include \u003cstring\u003e class Student { public: std::string name; int age; Student(std::string,int); void getStudentInfo() { std::cout \u003c\u003c name \u003c\u003c \" \" \u003c\u003c age \u003c\u003c std::endl; } }; //在外面实现类的构造函数 Student::Student(std::string _name, int _age) : name(_name),age(_age){} int main() { Student s(\"meow\",10); s.getStudentInfo(); return 0; } ","date":"2024-05-18","objectID":"/posts/ae3b30e/:1:2","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"构造器（Constructors） c++ 构造器（最简单的实例） #include \u003ciostream\u003e class Rectangle { int width; int height; public: Rectangle(int,int); void getArea(); }; Rectangle::Rectangle(int _w, int _h) { width = _w; height = _h; } void Rectangle::getArea() { std::cout \u003c\u003c width * height \u003c\u003c std::endl; } int main(void) { Rectangle r(100,100); r.getArea(); } 上面是 c++构造器一个简单的用法 重载构造器（包括成员初始化列表） 试想一下，假如我要求用 Rectangle r创建对象的时候，默认 width = 5,height = 5,但是又要求能给 Rectangle 对象的成员变量赋值，比如让width = 10,height = 20,Rectangle r(10,20). 我们就得这么写 #include \u003ciostream\u003e class Rectangle { int width; int height; public: Rectangle(); Rectangle(int,int); void getArea(){ std::cout \u003c\u003c width*height \u003c\u003c std::endl; } }; Rectangle::Rectangle() { width = 5; height = 5; } Rectangle::Rectangle(int w, int h) { width = w; height = h; } int main(void) { Rectangle r; r.getArea(); //25 Rectangle r2(10,15); r2.getArea(); //150 } 当然了，我们可以不在外面实现构造函数，直接在类里面写也是可以的 #include \u003ciostream\u003e class Rectangle { int width; int height; public: Rectangle() { width = 5; height = 5; } Rectangle(int _w,int _h) { width = _w; height = _h; } void getArea(){ std::cout \u003c\u003c width*height \u003c\u003c std::endl; } }; int main(void) { Rectangle r; r.getArea(); //25 Rectangle r2(10,15); r2.getArea(); //150 } 😊 有没有发现这样很麻烦呢？ 其实在 c++中有一个东西，叫 成员初始化列表，看到上面的重载的第二个构造函数了吗？我们可以像下面这样写 Rectangle(int _w, int _h) : width(_w), height(_h) {}; 这样就大大简化了我们的构造函数书写啦！😊 ","date":"2024-05-18","objectID":"/posts/ae3b30e/:1:3","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"指向类的指针（Pointers to Class) 在 c++中，我们也 能用指针去指向类，然后通过指针调用类 #include \u003ciostream\u003e #include \u003cstring\u003e class Human { std::string name; public: Human(std::string _name):name(_name){}; void getHumanInfo() { std::cout \u003c\u003c \"Human name is :\" \u003c\u003c name \u003c\u003c std::endl; } }; int main() { //创建Human对象 Human h(\"Mike\"); Human *human = \u0026h; human-\u003egetHumanInfo(); //通过指针调用类的成员函数 //Human name is :Mike return 0; } 😊 既然这样，那我们就可以创建类数组啦 #include \u003ciostream\u003e class Rectangle { int width,height; public: Rectangle(int _w,int _h):width(_w),height(_h){}; void getArea() { std::cout \u003c\u003c width*height \u003c\u003c std::endl; } }; int main(void) { Rectangle r(10,20); Rectangle *ptr = new Rectangle[2]{{2,5},{3,6}}; ptr[0].getArea(); //10 ptr[1].getArea(); //18 delete []ptr; return 0; } 关于指针和 new 这个我会后面参考 c++ primer plus进行进一步说明 ","date":"2024-05-18","objectID":"/posts/ae3b30e/:1:4","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"静态函数 C++ 中的静态函数是指在类中使用static关键字修饰的成员函数。它与类的实例无关，可以通过类名直接调用，不需要创建类的对象 静态函数的声明和定义方式与普通成员函数相同，只需要在函数前面加上static关键字就行。静态函数可以访问类的静态成员变量和静态成员函数，但是不能访问非静态成员变量和成员函数。 静态函数不能使用关键字this，因为它没有隐含的指向对象 的指针 #include \u003ciostream\u003e class Student { public: Student(char* name,int age,float score); void show(); public: static int getTotal(); static float getPoints(); private: static int m_total; static float m_points; private: char *m_name; int m_age; float m_score; }; int Student::m_total = 0; float Student::m_points = 0.0; Student::Student(char *name,int age,float score): m_name(name),m_age(age),m_score(score){ m_total++; m_points += score; } void Student::show() { std::cout \u003c\u003c m_name \u003c\u003c \" 's age is \" \u003c\u003c m_age \u003c\u003c \", score is \" \u003c\u003c m_score \u003c\u003c std::endl; } //Define static member function float Student::getPoints(){ return m_points; } int Student::getTotal() { return m_total; } int main(){ (new Student(\"xiaoming\",15,90.7))-\u003eshow(); int total = Student::getTotal(); float points = Student::getPoints(); std::cout \u003c\u003c \"now there is \" \u003c\u003c total \u003c\u003c \" students ,their total score is \" \u003c\u003c points \u003c\u003c std::endl; return 0; } ","date":"2024-05-18","objectID":"/posts/ae3b30e/:1:5","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"析构函数 C++中析构函数是一种特殊的成员函数，用于在对象被销毁时执行清理工作。析构函数的名称和类名相同，但在名称前面加上一个波浪号~ #include \u003ciostream\u003e class MyClass { public: MyClass() { std::cout \u003c\u003c \"Constructor\" \u003c\u003c std::endl; } ~MyClass() { std::cout \u003c\u003c \"Destructor\" \u003c\u003c std::endl; } }; int main() { MyClass obj; return 0; } 析构函数的应用 #include \u003ciostream\u003e class MyClass { public: MyClass() { std::cout \u003c\u003c \"Constructor \" \u003c\u003c std::endl; data = new int[10]; } ~MyClass() { std::cout \u003c\u003c \"DestructorL: data内存已被释放\" \u003c\u003c std::endl; delete[] data; } void insertNum(int x) { if (top \u003e 9) return; data[top++] = x; } void printData() { for (int i = 0; i \u003c= top; i++) { std::cout \u003c\u003c data[i] \u003c\u003c \" \"; } std::cout \u003c\u003c std::endl; } private: int *data; int top = 0; }; int main(void) { MyClass obj; obj.insertNum(1); obj.insertNum(2); obj.insertNum(3); obj.insertNum(4); obj.insertNum(5); obj.insertNum(6); obj.printData(); return 0; } ","date":"2024-05-18","objectID":"/posts/ae3b30e/:1:6","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"C++成员对象和封闭类 一个类的成员变量如果是另一个类的对象，就称之为“成员对象”。包含成员对象的类叫封闭类（enclosed class） 封闭类对象生成时，先执行所有成员对象的构造函数，然后才执行封闭类自己的构造函数。成员对象构造函数的执行次序和成员对象在类定义中的次序一致，与它们在构造函数初始化列表中出现的次序无关。 当封闭类对象消亡时，先执行封闭类的析构函数，然后再执行成员对象的析构函数，成员对象析构函数的执行次序和构造函数的执行次序相反，即先构造的后析构，这是 C++ 处理此类次序问题的一般规律。 #include\u003ciostream\u003e using namespace std; class Tyre { public: Tyre() { cout \u003c\u003c \"Tyre constructor\" \u003c\u003c endl; } ~Tyre() { cout \u003c\u003c \"Tyre destructor\" \u003c\u003c endl; } }; class Engine { public: Engine() { cout \u003c\u003c \"Engine constructor\" \u003c\u003c endl; } ~Engine() { cout \u003c\u003c \"Engine destructor\" \u003c\u003c endl; } }; class Car { private: Engine engine; Tyre tyre; public: Car() { cout \u003c\u003c \"Car constructor\" \u003c\u003c endl; } ~Car() { cout \u003c\u003c \"Car destructor\" \u003c\u003c endl; } }; int main() { Car car; return 0; } ","date":"2024-05-18","objectID":"/posts/ae3b30e/:1:7","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"Class(2) ","date":"2024-05-18","objectID":"/posts/ae3b30e/:2:0","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"封装 定义了一个 Circle 类，包含了数据成员 radius 和成员函数 getRadius()、setRadius() 和 getArea()。其中，getRadius() 和 setRadius() 分别用于获取和设置半径的值，getArea() 用于计算圆的面积。可以看出，radius 数据成员被隐藏在类的私有部分，外部的调用者无法直接访问和修改它，只能通过公共的成员函数进行操作，从而实现了数据的封装。 在 main() 函数中，定义了一个 Circle 对象 c，并通过公共的成员函数获取并修改了半径的值，并计算圆的面积。可以看出，外部调用者只能通过公共的接口来访问和操作数据，无法直接访问和修改私有成员变量，从而保证了数据的安全性和可维护性。 通过封装，C++ 中的类可以将数据和操作数据的方法封装在一起，隐藏实现细节，提高代码的安全性和可维护性。需要注意的是，在设计类的接口时，应该尽可能地隐藏实现细节，只暴露必要的接口，避免外部调用者误操作数据，从而提高程序的健壮性和可靠性。 #include \u003ciostream\u003e class Circle { public: Circle(double r) : radius(r) {} double getRadius() const { return radius; } void setRadius(double r) { radius = r; } double getArea() const { return 3.14 * radius * radius; } private: double radius; }; int main() { Circle c(2.0); std::cout \u003c\u003c \"Radius = \" \u003c\u003c c.getRadius() \u003c\u003c std::endl; std::cout \u003c\u003c \"Area = \" \u003c\u003c c.getArea() \u003c\u003c std::endl; c.setRadius(3.0); std::cout \u003c\u003c \"Radius = \" \u003c\u003c c.getRadius() \u003c\u003c std::endl; std::cout \u003c\u003c \"Area = \" \u003c\u003c c.getArea() \u003c\u003c std::endl; return 0; } ","date":"2024-05-18","objectID":"/posts/ae3b30e/:2:1","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"常函数\u0026常对象 测试常函数 不加mutable，编译错误 加上mutable，编译通过 测试常对象 可见常对象只能调用常函数 ","date":"2024-05-18","objectID":"/posts/ae3b30e/:2:2","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"继承 C++ 中的继承是面向对象编程中的一个重要概念，它允许通过派生类来扩展基类的功能，从而实现代码的重用和扩展。 #include \u003ciostream\u003e class Animal { public: Animal(const std::string\u0026 _name) : name(_name){}; virtual void speak() const { std::cout \u003c\u003c \"I am an animal.\" \u003c\u003c std::endl; } protected: std::string name; }; class Dog : public Animal { public: Dog(const std::string\u0026 _name,const std::string\u0026 _breed) : Animal(_name),breed(_breed){}; virtual void speak() const { std::cout \u003c\u003c \"Woof! I am a dog.\" \u003c\u003c std::endl; } private: std::string breed; }; class Cat : public Animal { public: Cat(const std::string\u0026 _name,const std::string\u0026 _color) : Animal(_name),color(_color) {}; virtual void speak() const { std::cout \u003c\u003c \"Meow! I am a Cat.\" \u003c\u003c std::endl; } private: std::string color; }; int main(void) { Animal* animals[3]; animals[0] = new Animal(\"Generic Animal\"); animals[1] = new Dog(\"Rover\", \"Golden Retriever\"); animals[2] = new Cat(\"Fluffy\", \"White\"); for (int i = 0; i \u003c 3; ++i) { animals[i]-\u003espeak(); } delete animals[0]; delete animals[1]; delete animals[2]; } 继承中的静态变量 #include \u003ciostream\u003e class Parent { public: static int staticVar; }; int Parent::staticVar = 10; class Child : public Parent { }; int main() { std::cout \u003c\u003c Parent::staticVar \u003c\u003c std::endl; std::cout \u003c\u003c Child::staticVar \u003c\u003c std::endl; Child::staticVar = 30; std::cout \u003c\u003c Parent::staticVar \u003c\u003c std::endl; std::cout \u003c\u003c Child::staticVar \u003c\u003c std::endl; } 可见静态变量是父类和子类共享的。 关于继承时候加public,private,protected的区别 在C++中，继承时使用public、private和protected关键字可以控制基类成员对派生类的可访问性。这三个关键字的使用对于派生类中继承的成员的可见性和访问权限有不同的影响。 public继承： 公有继承时使用public关键字，派生类可以继承基类的公有成员和保护成员。基类的公有成员在派生类中仍然是公有的，保护成员在派生类中仍然是保护的。 基类的私有成员对派生类是不可访问的。 class Child : public Parent { // 可以访问 Parent 的公有成员和保护成员 }; private继承： 私有继承时使用private关键字，派生类可以继承基类的公有成员和保护成员，但它们在派生类中都将变为私有成员。 基类的私有成员对派生类是不可访问的。 class Child : private Parent { // 可以访问 Parent 的公有成员和保护成员，但它们在 Child 中都变为私有成员 }; protected继承： 保护继承时使用protected关键字，派生类可以继承基类的公有成员和保护成员，它们在派生类中都将变为保护成员。 基类的私有成员对派生类是不可访问的。 class Child : protected Parent { // 可以访问 Parent 的公有成员和保护成员，但它们在 Child 中都变为保护成员 }; 需要注意的是，上述访问控制关键字只影响派生类对基类成员的访问权限，而不影响基类内部对成员的访问权限。无论使用哪种访问控制关键字，在派生类中都可以访问基类的公有和保护成员，只是它们在派生类中的可见性和外部访问权限会有所不同。 继承时选择合适的访问控制关键字取决于设计需求和继承关系的语义。根据需要，可以选择public、private或protected继承来满足对基类成员的访问要求。 这里我来浅浅介绍一下virtual这个关键字 虚函数 virtual function 在 C++ 中，virtual 是一个关键字，用于定义虚函数。虚函数是一种特殊的成员函数，它通过动态绑定（dynamic binding）机制来实现多态，允许使用基类指针或引用调用派生类对象的成员函数，从而实现同一函数名在不同对象上具有不同的行为。 在使用 virtual 关键字定义虚函数时，需要注意以下几点： 只有类的成员函数才能被定义为虚函数，而普通的全局函数和静态成员函数不能被定义为虚函数。 虚函数必须在基类中声明，可以在派生类中重新定义，但是必须保持函数名、参数类型和返回类型相同，否则无法实现动态绑定。 基类的析构函数应该声明为虚函数，以保证在使用基类指针或引用删除派生类对象时，能够正确地调用派生类的析构函数。 在上面写继承得时候，就已经体现出了虚函数得作用 ","date":"2024-05-18","objectID":"/posts/ae3b30e/:2:3","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"抽象类 在 C++ 中，抽象类（Abstract Class）指的是包含至少一个纯虚函数的类，不能直接实例化对象，只能作为基类被继承。纯虚函数是在类中声明但没有定义的虚函数，其语法格式如下： virtual 返回类型 函数名 (参数列表) = 0; 需要注意的是，纯虚函数没有函数体，只是一个声明，其作用是强制派生类实现该函数，从而实现多态。 抽象类一般用于定义接口和规范派生类的行为，其派生类必须实现基类的纯虚函数，否则也会成为抽象类。抽象类不能直接创建对象，但是可以定义指向派生类对象的指针或引用，通过动态绑定实现多态。 需要注意的是，在定义抽象类时，应该将基类的析构函数声明为虚函数，以保证正确释放派生类对象的内存。同时，抽象类的派生类必须实现基类的纯虚函数，否则也会成为抽象类。 ","date":"2024-05-18","objectID":"/posts/ae3b30e/:2:4","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"接口 Interface 在 C++ 中，接口（Interface）指的是一个抽象类，包含纯虚函数和（或）常量数据成员，没有数据成员和函数实现。接口定义了一组规范，规定了派生类需要实现的函数和数据成员，用于实现类的多态和封装。 接口在 C++ 中通常使用抽象类来定义，其中的纯虚函数和常量数据成员用于描述派生类需要实现的接口规范。派生类必须实现所有的纯虚函数，否则也会成为抽象类。 抽象类和接口的主要区别在于，抽象类可以包含非纯虚函数和数据成员，而接口只能包含纯虚函数和常量数据成员。 使用案例： 在下面的示例中，定义了一个接口 Printable，包含了纯虚函数 print()。然后定义了一个抽象类 Shape，继承了接口 Printable，包含了纯虚函数getArea()。然后定义了两个派生类 Rectangle 和 Circle，分别实现了基类的纯虚函数，并添加了自己的数据成员和成员函数。在主函数中，定义了一个 Printable 类型的数组，分别用基类和派生类对象初始化数组元素。然后使用一个循环来遍历数组，并通过基类指针调用虚函数 print() 和 getArea()，实现了多态的效果。 在这个示例中，Printable 接口规定了 print() 函数，Shape 抽象类继承了 Printable 接口，并规定了 getArea() 函数，Rectangle 和 Circle 派生类分别实现了 Shape 抽象类的 getArea() 和 print() 函数。在主函数中，定义了一个 Printable 类型的数组，包含了 Rectangle 和 Circle 两种类型的对象，并通过循环实现了多态的效果。 #include \u003ciostream\u003e class Printable { public: virtual void print() const = 0; }; class Shape : public Printable { public: virtual double getArea() const = 0; }; class Rectangle : public Shape { public: Rectangle(double w, double h) : width(w), height(h) {} virtual double getArea() const { return width * height; } virtual void print() const { std::cout \u003c\u003c \"Rectangle (\" \u003c\u003c width \u003c\u003c \" x \" \u003c\u003c height \u003c\u003c \")\" \u003c\u003c std::endl; } private: double width; double height; }; class Circle : public Shape { public: Circle(double r) : radius(r) {} virtual double getArea() const { return 3.14 * radius * radius; } virtual void print() const { std::cout \u003c\u003c \"Circle (\" \u003c\u003c radius \u003c\u003c \")\" \u003c\u003c std::endl; } private: double radius; }; int main() { Printable* shapes[2]; shapes[0] = new Rectangle(2.0, 3.0); shapes[1] = new Circle(1.5); for (int i = 0; i \u003c 2; ++i) { shapes[i]-\u003eprint(); std::cout \u003c\u003c \"Area = \" \u003c\u003c dynamic_cast\u003cShape*\u003e(shapes[i])-\u003egetArea() \u003c\u003c std::endl; } delete shapes[0]; delete shapes[1]; return 0; } ","date":"2024-05-18","objectID":"/posts/ae3b30e/:2:5","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"多态 多态（Polymorphism）是面向对象编程中的一个重要概念，指的是同一函数名在不同对象上具有不同的行为. #include \u003ciostream\u003e class Shape { public: virtual double getArea() const = 0; virtual void print() const = 0; virtual ~Shape(){}; }; class Rectangle : public Shape { public: Rectangle(double w, double h) : width(w), height(h) {} virtual double getArea() const { return width * height; } virtual void print() const { std::cout \u003c\u003c \"Rectangle (\" \u003c\u003c width \u003c\u003c \" x \" \u003c\u003c height \u003c\u003c \")\" \u003c\u003c std::endl; } private: double width; double height; }; class Circle : public Shape { public: Circle(double r) : radius(r) {} virtual double getArea() const { return 3.14 * radius * radius; } virtual void print() const { std::cout \u003c\u003c \"Circle (\" \u003c\u003c radius \u003c\u003c \")\" \u003c\u003c std::endl; } private: double radius; }; int main() { Shape* shapes[2]; shapes[0] = new Rectangle(2.0, 3.0); shapes[1] = new Circle(1.5); for (int i = 0; i \u003c 2; ++i) { shapes[i]-\u003eprint(); std::cout \u003c\u003c \"Area = \" \u003c\u003c shapes[i]-\u003egetArea() \u003c\u003c std::endl; } delete shapes[0]; delete shapes[1]; return 0; } ","date":"2024-05-18","objectID":"/posts/ae3b30e/:2:6","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"重载运算符（overloading operators) 可重载运算符 为了方便说明，我这里直接拿牛客网的题来说明了，包括重载运算符有什么用 重载加号 #include \u003ciostream\u003e class Number { private: int value; public: Number() :value(0) {} Number(int val):value(val){} int getValue() const { return value; } //成员函数重载运算符 //重载加号运算符 Number operator+(const Number\u0026 num) { Number result; result.value = this-\u003evalue + num.value; return result; } //重载前置加号运算符 Number operator++() { value = value + 1; return *this; } //重载后置加号运算符 Number operator++(int) { Number tmp = *this; ++(*this); return tmp; } }; //全局函数实现运算符重载 Number operator+(Number \u0026num1,int num2) { int num = num1.getValue() + num2; num1 = Number(num); return num1; } int main(void) { Number num(10); Number num2(20); Number num3 = num + num2; //相当于num.operator+(num2); num3++; num3 = num3 + 20; //相当于 operator(num3,20) int val = num3.getValue(); std::cout \u003c\u003c val \u003c\u003c std::endl; } 重载» #include \u003ciostream\u003e class Person { public: std::string name; int age; Person(std::string name, int age); }; Person::Person(std::string name, int age) { this-\u003ename = name; this-\u003eage = age; } std::ostream\u0026 operator\u003c\u003c(std::ostream \u0026out, const Person \u0026p) { out \u003c\u003c \"name: \" \u003c\u003c p.name \u003c\u003c \", age: \" \u003c\u003c p.age; return out; } int main() { Person pe(\"meowrain\", 234); std::cout \u003c\u003c pe \u003c\u003c std::endl; return 0; } 我们前面说过，类的属性应该用private，但是这样的话，我们重载的«就没办法用了，怎么办呢？用友元 #include \u003ciostream\u003e class Person { private: std::string name; int age; friend std::ostream\u0026 operator\u003c\u003c(std::ostream \u0026out,const Person \u0026p); public: Person(std::string name, int age); }; Person::Person(std::string name, int age) { this-\u003ename = name; this-\u003eage = age; } std::ostream\u0026 operator\u003c\u003c(std::ostream \u0026out, const Person \u0026p) { out \u003c\u003c \"name: \" \u003c\u003c p.name \u003c\u003c \", age: \" \u003c\u003c p.age; return out; } int main() { Person pe(\"meowrain\", 234); std::cout \u003c\u003c pe \u003c\u003c std::endl; return 0; } 重载= #include \u003ciostream\u003e class Human { private: int *m_age; public: Human(int age){ m_age = new int(age); } ~Human() { if (m_age != nullptr) { delete m_age; m_age = nullptr; } } Human(const Human\u0026 human) { m_age = new int(*human.m_age); } void getAge(){ std::cout \u003c\u003c *m_age \u003c\u003c std::endl; } Human\u0026 operator=(const Human\u0026 human) { if(this != \u0026human) { delete this-\u003em_age; this-\u003em_age = new int(*human.m_age); } return *this; } }; int main(void) { Human h1(12); Human h2(14); h2 = h1; h1.getAge(); h2.getAge(); } 重载小于号__牛客网 (nowcoder.com) #include \u003ciostream\u003e using namespace std; class Time { public: int hours; // 小时 int minutes; // 分钟 Time() { hours = 0; minutes = 0; } Time(int h, int m) { this-\u003ehours = h; this-\u003eminutes = m; } void show() { cout \u003c\u003c hours \u003c\u003c \" \" \u003c\u003c minutes \u003c\u003c endl; } // write your code here...... bool operator\u003c(Time b){ if(hours \u003e b.hours \u0026\u0026 minutes \u003e b.minutes){ return false; } else if(hours == b.hours \u0026\u0026 minutes == b.minutes) return false; else return true; } }; int main() { int h, m; cin \u003e\u003e h; cin \u003e\u003e m; Time t1(h, m); Time t2(6, 6); if (t1\u003ct2) cout\u003c\u003c\"yes\"; else cout\u003c\u003c\"no\"; return 0; } 加号运算符重载__牛客网 (nowcoder.com) #include \u003ciostream\u003e using namespace std; class Time { public: int hours; // 小时 int minutes; // 分钟 Time() { hours = 0; minutes = 0; } Time(int h, int m) { this-\u003ehours = h; this-\u003eminutes = m; } void show() { cout \u003c\u003c hours \u003c\u003c \" \" \u003c\u003c minutes \u003c\u003c endl; } // write your code here...... Time operator+(Time b) { int sum_hours = hours + b.hours; int sum_minutes = minutes + b.minutes; if (sum_minutes \u003e= 60) { sum_minutes -= 60; sum_hours += 1; } Time sum(sum_hours, sum_minutes); return sum; } }; int main() { int h, m; cin \u003e\u003e h; cin \u003e\u003e m; Time t1(h, m); Time t2(2, 20); Time t3 = t1 + t2; t3.show(); return 0; } 加号运算符重载 ","date":"2024-05-18","objectID":"/posts/ae3b30e/:2:7","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"Copy Constructor 拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于： 通过使用另一个同类型的对象来初始化新创建的对象。 复制对象把它作为参数传递给函数。 复制对象，并从函数返回这个对象。 如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。拷贝构造函数的最常见形式如下： classname (const classname \u0026obj) { // 构造函数的主体 } #include \u003ciostream\u003e using namespace std; class Person { public: string name; int age; Person() { name = \"meow\"; age = 10; } Person(string _name,int _age) { name = _name; age = _age; } Person(const Person\u0026 other) { name = other.name; age = other.age; } void getInfo() { cout \u003c\u003c name \u003c\u003c \" \" \u003c\u003c age \u003c\u003c \" \" \u003c\u003c endl; } }; int main() { Person p(\"mew\",19); Person p1 = p; Person p2(p); p.getInfo(); p1.getInfo(); p2.getInfo(); return 0; } p1 是通过使用赋值语句来初始化的，即 Person p1 = p;。这实际上是一种隐式的赋值操作，编译器会使用 copy constructor 来创建 p1 对象，并将 p 对象的值复制到 p1 对象中。 而 p2 是通过直接调用 copy constructor 来初始化的，即 Person p2(p);。这是一种显式调用 copy constructor 的方法，它直接使用现有对象 p 来创建新对象 p2，不需要使用赋值语句。 ","date":"2024-05-18","objectID":"/posts/ae3b30e/:2:8","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"Copy assignment(复制赋值操作符) 是 C++中的一个运算符，用于将一个对象的值复制到另一个对象中。它通常用于将一个已经存在的对象的值赋给另一个已经存在的对象，从而使它们具有相同的值。 语法格式： classname\u0026 operator=(const classname\u0026 other) 默认情况下，C++会提供一个浅复制的 copy assignment 运算符 看一个例子： #include \u003ciostream\u003e #include \u003cstring\u003e class Person { public: std::string name; int age; Person() { name = \"meo\"; age = 12; } Person(std::string _name, int _age) : name(_name), age(_age) { } // copy constructor Person(const Person \u0026other) { name = other.name; age = other.age; } // copy assignment Person \u0026operator=(const Person \u0026other) { name = other.name; age = other.age; return *this; } }; int main(void) { Person p1(\"meow\", 12); Person p2; p2 = p1; std::cout \u003c\u003c \"p1.name \" \u003c\u003c p1.name \u003c\u003c \" age: \" \u003c\u003c p1.age \u003c\u003c std::endl; std::cout \u003c\u003c \"p2.name \" \u003c\u003c p2.name \u003c\u003c \" age: \" \u003c\u003c p2.age \u003c\u003c std::endl; return 0; } 浅复制是指简单地将现有对象的成员变量的值复制到新对象中。如果成员变量是基本类型，那么浅复制是没有问题的，因为它们只是简单的值。但是，如果成员变量是指针，浅复制可能会导致问题。在这种情况下，浅复制只会复制指针本身，而不会复制指针指向的数据。这意味着新对象和现有对象将共享同一块数据，这可能会导致内存泄漏或数据损坏。 深复制是指将现有对象的成员变量的值复制到新对象中，并复制指针指向的数据。这意味着新对象将有自己的数据副本，与现有对象完全独立。这通常需要手动实现，因为 C++默认提供的复制构造函数和赋值运算符只会执行浅复制。 ","date":"2024-05-18","objectID":"/posts/ae3b30e/:2:9","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"友元 友元是一种特殊的访问权限，允许一个函数或类访问另一个类的私有或受保护成员。 友元有三种： 友元函数 友元类 友元成员函数 友元函数 创建友元函数得第一步 hi 把原型放在类声明中，在原型声明前面加上 friend 需要注意的是，友元函数并不是 MyClass 的成员函数，它是一个独立的函数，只是被声明为 MyClass 的友元函数。 #include \u003ciostream\u003e class Person { private: std::string name; int age; public: Person(std::string _name,int _age) : name(_name),age(_age){} friend void printValue(Person \u0026p) { std::cout \u003c\u003c \"Person name: \" \u003c\u003c p.name \u003c\u003c \"\\t\" \u003c\u003c \"Person age: \" \u003c\u003c p.age \u003c\u003c std::endl; } /* 在友元函数中，我们能访问Person类的私有成员变量 */ }; int main(void) { Person p(\"meow\",18); printValue(p); //友元函数不是类Person的成员函数 return 0; } 友元类 友元类是指一个类可以访问另一个类的私有成员，这使得它们之间的关系更加密切。 例子： #include \u003ciostream\u003e class Me { private: std::string name; int age; protected: std::string hobby; public: Me(){ name = \"meowrain\"; age = 20; hobby = \"playing computer\"; } void playGames(){ std::cout \u003c\u003c \"I'm playing games\" \u003c\u003c std::endl; } friend class MyFriend; }; class MyFriend { private: std::string name; int age; public: MyFriend(){ name = \"meow\"; age = 2; } void eat(){ std::cout \u003c\u003c name \u003c\u003c \" is eating !\" \u003c\u003c std::endl; } void play(Me\u0026 me){ std::cout \u003c\u003c name \u003c\u003c \" is playing with \" \u003c\u003c me.name \u003c\u003c std::endl; std::cout \u003c\u003c \"while \" \u003c\u003c me.name \u003c\u003c \" is \" \u003c\u003c me.hobby \u003c\u003c std::endl; } }; int main(void) { Me me; MyFriend my_friend; my_friend.play(me); return 0; } 友元成员函数 friend void Me::getFriendGirlFriend(MyFriend\u0026 my_friend);重点在这句代码，必须在那个类里面添加友元成员函数才可以保证需要用这个类的私有属性的类的成员函数能用到这个需要用的类的私有属性 在 Me 类中声明了一个友元成员函数 getFriendGirlFriend，而为了让这个成员函数能够访问 MyFriend 类的私有属性，需要在 MyFriend 类中进行友元函数的声明。 #include \u003ciostream\u003e class MyFriend; class Me { private: std::string girlFriend; public: std::string name; int age; public: Me(); void play() const; void getFriendGirlFriend(MyFriend\u0026 my_friend); }; class MyFriend { private: std::string girlFriend; friend void Me::getFriendGirlFriend(MyFriend\u0026 my_friend); public: std::string name; int age; public: MyFriend(); }; MyFriend::MyFriend() { name = \"jack chan\"; age = 20; girlFriend = \"洛天依\"; }; Me::Me() { name = \"meowrain\"; age = 20; girlFriend = \"miku\"; }; void Me::play() const { std::cout \u003c\u003c name \u003c\u003c \" is playing\" \u003c\u003c std::endl; } void Me::getFriendGirlFriend(MyFriend\u0026 my_friend) { std::cout \u003c\u003c \"My Friend's girl friend is \" \u003c\u003c my_friend.girlFriend \u003c\u003c std::endl; } int main(void) { Me me; MyFriend myFriend; me.getFriendGirlFriend(myFriend); } ","date":"2024-05-18","objectID":"/posts/ae3b30e/:2:10","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"转换函数 在 C++ 中，转换函数（conversion function）是一种特殊的成员函数，用于将一个对象转换为另一个类型的对象。转换函数可以将一个类对象转换为基本数据类型或另一个用户自定义类型的对象，或者将一个类对象转换为指向类对象的指针或引用。转换函数允许程序员在类中定义自己的类型转换规则，从而增强类的灵活性和可扩展性。 转换函数的命名规则与构造函数和成员函数相同，使用类名作为函数名，并在函数名称前面加上要转换的类型的名称。转换函数可以具有任何返回类型，但不能具有任何参数。转换函数可以被显式调用，也可以在需要时自动调用。 #include \u003ciostream\u003e //转换函数 class MyInt { private: int data; public: explicit MyInt(int n = 0) : data(n) { } operator int() const { return data; } }; int main(void) { MyInt a(10); int b = a; //调用转换函数把MyInt对象转换成int类型 using std::cout; using std::endl; cout \u003c\u003c b \u003c\u003c endl; return 0; } #include \u003ciostream\u003e class Feet { private: int feet; public: Feet(int n = 0): feet(n) {}; int getFeet() const { return feet; } }; class Meters { public: Meters(double m = 0.0) : meters(m) {} Meters(const Feet\u0026 f) : meters(f.getFeet() * 0.3048) {} //转换函数，把Feet对象转换为Meters对象 double getMeters() const { return meters; } private: double meters; }; int main(void) { Feet f(10); Meters m = f; using std::cout,std::endl; cout \u003c\u003c m.getMeters() \u003c\u003c endl; return 0; } ","date":"2024-05-18","objectID":"/posts/ae3b30e/:2:11","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"explicit关键字 在C++中，构造函数的调用方式分为显式调用和隐式调用。 ","date":"2024-05-18","objectID":"/posts/ae3b30e/:3:0","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"显式调用构造函数： 直接调用： 构造函数可以通过类名和参数列表直接调用来创建对象。 class MyClass { public: MyClass(int x) { /* ... */ } }; int main() { MyClass obj1(10); // 直接调用构造函数创建对象 MyClass obj2 = MyClass(20); // 通过构造函数显式创建对象 return 0; } 使用 new 运算符： 在堆内存上分配对象时，可以使用 new 运算符显式调用构造函数。 MyClass* ptr = new MyClass(30); // 在堆上分配内存并调用构造函数创建对象 ","date":"2024-05-18","objectID":"/posts/ae3b30e/:3:1","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["C++","面向对象"],"content":"隐式调用构造函数： 使用 = 进行赋值： 当使用 = 进行对象初始化或赋值时，会隐式地调用构造函数。 MyClass obj = 40; // 隐式调用构造函数将整数转换为 MyClass 对象 函数调用时的参数传递： 当函数需要参数并且传递的参数类型与函数参数不匹配时，会隐式调用构造函数来执行类型转换。 void func(MyClass obj) { /* ... */ } int main() { func(50); // 隐式调用构造函数将整数转换为 MyClass 对象并传递给 func 函数 return 0; } explicit 关键字可以防止构造函数的隐式调用，只有在需要时才能显式地调用构造函数。这可以避免一些意外的类型转换和可能导致错误的行为。 在 C++ 中，explicit 是一个关键字，通常用于防止编译器执行隐式类型转换。它可以应用于单参数构造函数或转换运算符。主要作用有两点： 禁止隐式转换： 当一个构造函数被声明为 explicit 时，它不再能够隐式地将其参数转换为所需的类类型。这样可以防止意外的类型转换，避免意想不到的行为。 class MyClass { public: explicit MyClass(int x) { /* ... */ } }; void func(const MyClass\u0026 obj) { /* ... */ } int main() { // MyClass obj = 10; // 这里会导致编译错误，因为构造函数是 explicit 的 MyClass obj(10); // 必须显式调用构造函数 func(10); // 这里也会导致编译错误，因为构造函数是 explicit 的 func(MyClass(10)); // 必须显式地创建 MyClass 对象 return 0; } 明确表达意图： 使用 explicit 关键字可以使代码更加清晰明了，明确地表达出了构造函数或转换运算符不会进行隐式转换，需要显式地进行调用或转换。 当你希望避免隐式类型转换，或者想要更明确地表达构造函数的使用方式时，可以考虑使用 explicit 关键字。这在设计类时特别有用，可以避免一些潜在的错误或者意外行为。 ","date":"2024-05-18","objectID":"/posts/ae3b30e/:3:2","tags":["C++","面向对象"],"title":"C++面向对象","uri":"/posts/ae3b30e/"},{"categories":["Go"],"content":" https://courses.calhoun.io/courses/cor_gophercises 1. Quiz https://github.com/gophercises/quiz 第一部分： 编写一个程序，该程序能够读取通过CSV文件提供的测验（详细信息如下），并向用户展示此测验。程序需记录用户答对和答错的题目数量。无论答案正确与否，都应立即提出下一题。 默认情况下，CSV文件名为problems.csv，但用户应能通过标志自定义文件名。 CSV文件的格式如下：第一列是问题，同一行的第二列则是该问题的答案。 你可以假设测验相对较短（少于100题），且答案为单个词或数字。 测验结束时，程序应输出答对的问题总数和总问题数。对于给出无效答案的问题，视为回答错误。 第二部分： 根据第一部分的要求调整你的程序以添加计时器功能。默认时间限制应为30秒，但也可通过标志进行自定义设置。 一旦超过时间限制，测验应立即停止。也就是说，不应等待用户回答最后一个问题，而应在理想情况下完全停止测验，即使当时正在等待用户的答案也应如此处理。 在计时开始前，应提示用户按下回车键（或其他键）启动计时器；然后题目应逐一出示在屏幕上直至用户提供答案为止。无论答案正确与否都将继续下一题的提问过程直到全部完成测试内容为止！最后依然需要统计出本次答题过程中总共答对了多少道题目以及一共出现了多少道题目信息并展示给参与者查看结果情况哦~同时也要注意那些没有被有效解答过的或者是根本就没有来得及去作答的部分也都算作是错误的哟！ package main import ( \"context\" \"encoding/csv\" \"flag\" \"fmt\" \"log\" \"os\" \"strconv\" \"time\" ) func CommandLine() (string, int) { csvFileName := flag.String(\"csv\", \"problems.csv\", \"put the filename after this\") limitValue := flag.Int(\"limit\", 4, \"the time limit for the quiz in seconds\") flag.Parse() return *csvFileName, *limitValue } func main() { csvFileName, timeLimit := CommandLine() ctx, cancel := context.WithTimeout(context.Background(), time.Duration(timeLimit)*time.Second) defer cancel() file, err := os.Open(csvFileName) if err != nil { log.Fatalf(\"Error opening file: %v\", err) } defer file.Close() reader := csv.NewReader(file) lines, err := reader.ReadAll() if err != nil { log.Fatalf(\"Error reading CSV: %v\", err) } var correct, incorrect int for idx, line := range lines { select { case \u003c-ctx.Done(): fmt.Println(\"\\nTime's up!\") printResults(correct, incorrect) return default: formula := line[0] answerChan := make(chan int) go func() { var result int fmt.Printf(\"Question:%d/%d\\tFormula: %v = \", idx+1, len(lines), formula) fmt.Scanln(\u0026result) answerChan \u003c- result }() answer, err := strconv.Atoi(line[1]) if err != nil { log.Fatalf(\"Invalid answer in CSV: %v\", err) } select { case \u003c-ctx.Done(): fmt.Println(\"\\nTime's up!\") printResults(correct, incorrect) return case result := \u003c-answerChan: if result == answer { correct++ } else { incorrect++ } } } } printResults(correct, incorrect) } func printResults(correct, incorrect int) { fmt.Printf(\"\\nYou got %d correct and %d incorrect.\\n\", correct, incorrect) } ","date":"2024-05-18","objectID":"/posts/33dc7d7/:0:0","tags":["Go-exercises","Go"],"title":"Go Gophercises","uri":"/posts/33dc7d7/"},{"categories":["Go"],"content":"就是一直刷新当前行 package main import ( \"fmt\" \"time\" ) func main() { // 模拟一些操作，比如循环计数 for i := 0; i \u003c= 100; i++ { // 返回到行首 fmt.Print(\"\\r\") // 输出其他内容 fmt.Printf(\"Prefix: \") // 输出进度 fmt.Printf(\"Progress: %d%%\", i) // 强制刷新输出缓冲区 fmt.Print(\"\\033[0m\") // 重置 ANSI 颜色，防止影响后续输出 time.Sleep(100 * time.Millisecond) } fmt.Println(\"\\nDone!\") // 完成后换行 } ","date":"2024-05-18","objectID":"/posts/fc29587/:0:0","tags":["Go"],"title":"Go语言打印进度","uri":"/posts/fc29587/"},{"categories":["Go"],"content":"panic,recover 在 Go 语言中，panic 和 recover 是用于处理程序错误和恢复的两个关键机制。 panic： panic 是一个内建函数，用于表示程序发生了无法处理的错误。当发生 panic 时，程序会立即停止执行当前函数的剩余代码，并开始在调用栈中向上逐层执行 deferred 函数，直到达到当前协程的最顶层（即程序的入口函数），然后程序将终止并输出 panic 信息。 panic 通常用于表示不可恢复的错误，比如空指针引用、数组越界等，或者是程序运行过程中的一些不合法操作。 recover： recover 也是一个内建函数，用于在 defer 延迟执行的函数中捕获 panic 引起的错误，使程序能够继续执行而不会被终止。 recover 只能在 defer 中调用，并且只在发生 panic 时才会生效。如果在没有 panic 的情况下调用 recover，它将返回 nil。 当 recover 在 defer 中调用时，如果有 panic 发生，它将会返回被传递给 panic 的值，并且程序将继续执行而不会终止。 package main import ( \"fmt\" ) func recoverFromPanic() { if r := recover(); r != nil { fmt.Println(\"Recovered from panic:\", r) } } func divide(a, b int) int { // defer语句用于注册在当前函数返回时调用的函数 defer recoverFromPanic() if b == 0 { panic(\"Cannot divide by zero!\") } return a / b } func processDivision(x, y int) { result := divide(x, y) fmt.Println(\"Result of division:\", result) } func main() { // Case 1: Valid division processDivision(10, 2) // Case 2: Division by zero processDivision(10, 0) fmt.Println(\"Program continues after division.\") } ","date":"2024-05-18","objectID":"/posts/8a369fa/:0:0","tags":["Go","Go错误处理"],"title":"Go 错误处理","uri":"/posts/8a369fa/"},{"categories":["Go"],"content":"介绍 Go的gob是Go语言标准库中的一种序列化/反序列化格式，主要用于在编码和解码时传输和存储Go数据结构。Gob格式专为Go语言设计，提供了一种高效的二进制编码方式，特别适合在网络通信和文件存储中使用。 以下是Go的gob包的一些关键特性和使用方法： 特性 高效的二进制编码：Gob格式比JSON和XML等文本格式更为紧凑和高效，因为它使用二进制表示数据。 面向Go语言：Gob格式支持Go语言中的复杂数据结构，包括嵌套结构、切片、映射等。 自动化的编码和解码：使用gob包可以自动处理编码和解码过程，无需手动序列化和反序列化。 例子 package main import ( \"bytes\" \"encoding/gob\" \"fmt\" \"log\" \"os\" ) type Person struct { Name string Age int } func main() { // 创建一个Person实例 person := Person{Name: \"Alice\", Age: 30} // 创建一个缓冲区来存储编码后的数据 var buf bytes.Buffer // 创建一个新的编码器并对缓冲区进行编码 encoder := gob.NewEncoder(\u0026buf) err := encoder.Encode(person) if err != nil { fmt.Println(\"编码错误:\", err) } // 打印编码后的数据 fmt.Println(\"编码后的数据:\", buf.Bytes()) // 把编码后的数据写入文件中 file, err := os.OpenFile(\"data.gob\", os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0666) if err != nil { log.Fatal(\"打开文件错误:\", err) } defer file.Close() // 确保文件在程序结束时关闭 encoder2 := gob.NewEncoder(file) err = encoder2.Encode(person) if err != nil { log.Fatal(\"编码错误:\", err) } // 解码 file2, err := os.Open(\"data.gob\") if err != nil { log.Fatal(\"打开文件错误:\", err) } defer file2.Close() // 确保文件在程序结束时关闭 decoder2 := gob.NewDecoder(file2) var person2 Person err = decoder2.Decode(\u0026person2) if err != nil { log.Fatal(\"解码错误:\", err) } // 打印解码后的数据 fmt.Println(\"解码后的数据:\", person2) // 将解码后的数据写入 \"test.txt\" 文件 file3, err := os.OpenFile(\"test.txt\", os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0666) if err != nil { log.Fatal(\"打开文件错误:\", err) } defer file3.Close() // 确保文件在程序结束时关闭 _, err = fmt.Fprintf(file3, \"Name: %s, Age: %d\\n\", person2.Name, person2.Age) if err != nil { log.Fatal(\"写入文件错误:\", err) } } 代码解释 创建和编码Person实例：创建 Person 实例并编码成字节缓冲区。 打印编码后的数据：打印编码后的数据字节切片（注意：这是二进制数据，不是人类可读的格式）。 将编码数据写入文件：将编码后的数据写入 “data.gob” 文件。 解码数据：从 “data.gob” 文件中读取数据并解码回 Person 实例。 打印解码后的数据：打印解码后的 Person 实例数据。 写入解码数据到test.txt：将解码后的 Person 实例数据写入 “test.txt” 文件，以人类可读的格式输出。 ","date":"2024-05-18","objectID":"/posts/a47021b/:0:0","tags":["Go"],"title":"Go Gob","uri":"/posts/a47021b/"},{"categories":["Go"],"content":" vcard.go package vcard import ( \"time\" ) type Address struct { Street string HouseNumber uint32 HouseNumberAddOn string POBox string ZipCode string City string Country string } type VCard struct { FirstName string LastName string NickName string BirtDate time.Time Photo string Addresses map[string]*Address } jsonUtil.go package utils import ( \"encoding/json\" ) func ToJson(data any) string { js, _ := json.Marshal(data) return string(js) } main.go package main import ( . \"awesomeProject/utils\" . \"awesomeProject/vcard\" \"encoding/json\" \"fmt\" \"os\" \"time\" ) func main() { pa := \u0026Address{Street: \"private\", HouseNumber: 10086, HouseNumberAddOn: \"Belgium\"} wa := \u0026Address{Street: \"work\", HouseNumber: 10008611, HouseNumberAddOn: \"Belgium\"} vc := VCard{FirstName: \"Jan\", LastName: \"Kersschot\", NickName: \"Mike\", BirtDate: time.Date(1956, 1, 17, 15, 4, 5, 0, time.Local)} str := ToJson(vc) fmt.Println(str) str = ToJson(wa) fmt.Println(str) str = ToJson(pa) fmt.Println(str) //写入到vcard.json文件 file, err := os.Create(\"vcard.json\") if err != nil { fmt.Println(err) return } defer file.Close() encoder := json.NewEncoder(file) err = encoder.Encode(vc) if err != nil { return } fmt.Println(\"vcard.json created\") //读取vcard.json文件 file, err = os.Open(\"vcard.json\") if err != nil { fmt.Println(err) return } defer file.Close() decoder := json.NewDecoder(file) var vcard VCard err = decoder.Decode(\u0026vcard) if err != nil { return } fmt.Println(vcard) } 出于安全考虑，在 web 应用中最好使用 json.MarshalforHTML() 函数，其对数据执行HTML转码，所以文本可以被安全地嵌在 HTML\u003cscript\u003e标签中。 json.NewEncoder() 的函数签名是 func NewEncoder(w io.Writer) *Encoder，返回的Encoder类型的指针可调用方法 Encode(v interface{})，将数据对象 v 的json编码写入 io.Writer w 中。 ","date":"2024-05-18","objectID":"/posts/35b4611/:0:0","tags":["json编码解码"],"title":"Go Json解码和编码","uri":"/posts/35b4611/"},{"categories":null,"content":"meowrain's friends","date":"2024-05-18","objectID":"/friends/","tags":null,"title":"Index","uri":"/friends/"},{"categories":null,"content":"Base info - nickname: Lruihao avatar: https://lruihao.cn/images/avatar.jpg url: https://lruihao.cn description: Lruihao's Note ","date":"2024-05-18","objectID":"/friends/:1:0","tags":null,"title":"Index","uri":"/friends/"},{"categories":null,"content":"Friendly Reminder Notice If you want to exchange link, please leave a comment in the above format. (personal non-commercial blogs / websites only)  Website failure, stop maintenance and improper content may be unlinked! Those websites that do not respect other people’s labor achievements, reprint without source, or malicious acts, please do not come to exchange. ","date":"2024-05-18","objectID":"/friends/:2:0","tags":null,"title":"Index","uri":"/friends/"},{"categories":["设计模式"],"content":"[TOC] 面向对象相关知识 面向对象类关系(继承、实现、依赖、关联、聚合、组合)：https://www.cnblogs.com/zhongj/p/11169780.html UML: https://blog.csdn.net/quyingzhe0217/article/details/133683814 创建型模式 创建型设计模式包括以下几种常见的模式： 工厂模式（Factory Pattern）：通过工厂方法或抽象工厂来创建对象，将对象的创建过程封装起来，使得客户端代码与具体类解耦。 抽象工厂模式（Abstract Factory Pattern）：提供一个接口，用于创建相关或依赖对象的家族，而不需要指定具体类。 单例模式（Singleton Pattern）：确保一个类只有一个实例，并提供一个全局访问点来访问该实例。 建造者模式（Builder Pattern）：将一个复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。 原型模式（Prototype Pattern）：通过复制现有对象来创建新对象，而不是通过实例化来创建。 结构型模式 结构型设计模式主要包括以下几种常见的模式： 适配器模式（Adapter Pattern）：将一个类的接口转换成客户端所期望的另一个接口，使得原本不兼容的类可以一起工作。 桥接模式（Bridge Pattern）：将抽象部分与实现部分分离，使它们可以独立地变化，从而提高系统的灵活性。 组合模式（Composite Pattern）：将对象组合成树形结构，以表示“部分-整体”的层次结构，使得客户端可以统一地处理单个对象和组合对象。 装饰器模式（Decorator Pattern）：动态地给对象添加额外的职责，同时又不改变其接口。 外观模式（Facade Pattern）：提供一个统一的接口，用于访问子系统中的一组接口，从而简化客户端与子系统之间的交互。 享元模式（Flyweight Pattern）：通过共享细粒度的对象，以减少内存使用和提高性能。 代理模式（Proxy Pattern）：为其他对象提供一个代理，以控制对这个对象的访问。 行为模式 行为型设计模式主要包括以下几种常见的模式： 观察者模式（Observer Pattern）：定义了一种一对多的依赖关系，使得多个观察者对象可以同时监听并收到被观察者对象的通知。 策略模式（Strategy Pattern）：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，从而使算法的变化独立于使用算法的客户端。 命令模式（Command Pattern）：将请求封装成对象，以使得可以用不同的请求对客户端进行参数化，同时支持请求的排队、记录和撤销。 迭代器模式（Iterator Pattern）：提供一种顺序访问聚合对象中各个元素的方法，而又不暴露该对象的内部表示。 状态模式（State Pattern）：允许对象在内部状态发生改变时改变其行为，使对象看起来像是修改了其类。 责任链模式（Chain of Responsibility Pattern）：将请求的发送者和接收者解耦，使多个对象都有机会处理请求，从而避免请求的发送者与接收者之间的耦合关系。 访问者模式（Visitor Pattern）：在不改变被访问类的前提下，定义了一种新的访问操作，使得可以在不修改被访问类的情况下对其进行操作。 中介者模式（Mediator Pattern）：定义了一个中介对象，封装了一组对象之间的交互方式，使其能够独立地改变交互方式。 备忘录模式（Memento Pattern）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可以在以后恢复到这个状态。 解释器模式（Interpreter Pattern）：给定一个语言，定义它的文法的一种表示，并定义一个解释器，用于解释语言中的句子。 ","date":"2024-05-15","objectID":"/posts/a44e805/:0:0","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["设计模式"],"content":"工厂方法模式 factory_method 工厂方法模式是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。 问题： 假设你正在开发一款物流管理应用。 最初版本只能处理卡车运输， 因此大部分代码都在位于名为 卡车的类中。 一段时间后， 这款应用变得极受欢迎。 你每天都能收到十几次来自海运公司的请求， 希望应用能够支持海上物流功能。 这可是个好消息。 但是代码问题该如何处理呢？ 目前， 大部分代码都与 卡车类相关。 在程序中添加 轮船类需要修改全部代码。 更糟糕的是， 如果你以后需要在程序中支持另外一种运输方式， 很可能需要再次对这些代码进行大幅修改。 最后， 你将不得不编写繁复的代码， 根据不同的运输对象类， 在应用中进行不同的处理。 解决方案： 乍看之下， 这种更改可能毫无意义： 我们只是改变了程序中调用构造函数的位置而已。 但是， 仔细想一下， 现在你可以在子类中重写工厂方法， 从而改变其创建产品的类型。 但有一点需要注意:仅当这些产品具有共同的基类或者接口时， 子类才能返回不同类型的产品， 同时基类中的工厂方法还应将其返回类型声明为这一共有接口。 举例来说， 卡车Truck和 轮船Ship类都必须实现 运输Transport接口， 该接口声明了一个名为 deliver交付的方法。 每个类都将以不同的方式实现该方法： 卡车走陆路交付货物， 轮船走海路交付货物。 陆路运输RoadLogistics类中的工厂方法返回卡车对象， 而 海路运输SeaLogistics类则返回轮船对象。 调用工厂方法的代码 （通常被称为客户端代码） 无需了解不同子类返回实际对象之间的差别。 客户端将所有产品视为抽象的 运输 。 客户端知道所有运输对象都提供 交付方法， 但是并不关心其具体实现方式。 以上的实现已经写在factory_method文件夹里面了 Logistics相当于下面的Creator,RoadLogistic和SeaLogistic相当于ConcreteCreatorA和ConcreteCreatorB Transport相当于Product接口，下面的Ship和Truck是实现这个接口的实体类 ","date":"2024-05-15","objectID":"/posts/a44e805/:1:0","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["设计模式"],"content":"工厂方法应用场景： 当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。 工厂方法将创建产品的代码与实际使用产品的代码分离， 从而能在不影响其他代码的情况下扩展产品创建部分代码。 例如， 如果需要向应用中添加一种新产品， 你只需要开发新的创建者子类， 然后重写其工厂方法即可。 就像上面我们写的运输货物的例子一样，假如现在多出个飞机运输，我们只需要创建一个AirPlane类，然后让它implements Transport接口，实现其中的transport函数就可以了 同时需要创建一个FlightLogistic，继承Logistics抽象类，然后重写就可以 如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法。 继承可能是扩展软件库或框架默认行为的最简单方法。 但是当你使用子类替代标准组件时， 框架如何辨识出该子类？ 解决方案是将各框架中构造组件的代码集中到单个工厂方法中， 并在继承该组件之外允许任何人对该方法进行重写。 让我们看看具体是如何实现的。 假设你使用开源 UI 框架编写自己的应用。 你希望在应用中使用圆形按钮， 但是原框架仅支持矩形按钮。 你可以使用 圆形按钮RoundButton子类来继承标准的 按钮Button类。 但是， 你需要告诉 UI框架UIFramework类使用新的子类按钮代替默认按钮。 为了实现这个功能， 你可以根据基础框架类开发子类 圆形按钮 UIUIWithRoundButtons ， 并且重写其 createButton创建按钮方法。 基类中的该方法返回 按钮对象， 而你开发的子类返回 圆形按钮对象。 现在， 你就可以使用 圆形按钮 UI类代替 UI框架类。 就是这么简单！ 如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。 在处理大型资源密集型对象 （比如数据库连接、 文件系统和网络资源） 时， 你会经常碰到这种资源需求。 让我们思考复用现有对象的方法： 首先， 你需要创建存储空间来存放所有已经创建的对象。 当他人请求一个对象时， 程序将在对象池中搜索可用对象。 … 然后将其返回给客户端代码。 如果没有可用对象， 程序则创建一个新对象 （并将其添加到对象池中）。 这些代码可不少！ 而且它们必须位于同一处， 这样才能确保重复代码不会污染程序。 可能最显而易见， 也是最方便的方式， 就是将这些代码放置在我们试图重用的对象类的构造函数中。 但是从定义上来讲， 构造函数始终返回的是新对象， 其无法返回现有实例。 因此， 你需要有一个既能够创建新对象， 又可以重用现有对象的普通方法。 这听上去和工厂方法非常相像。 ","date":"2024-05-15","objectID":"/posts/a44e805/:1:1","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["设计模式"],"content":"优缺点 ","date":"2024-05-15","objectID":"/posts/a44e805/:1:2","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["设计模式"],"content":"生成器模式 https://refactoringguru.cn/design-patterns/builder 生成器模式是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。 问题 假设有这样一个复杂对象， 在对其进行构造时需要对诸多成员变量和嵌套对象进行繁复的初始化工作。 这些初始化代码通常深藏于一个包含众多参数且让人基本看不懂的构造函数中； 甚至还有更糟糕的情况， 那就是这些代码散落在客户端代码的多个位置。 如果为每种可能的对象都创建一个子类， 这可能会导致程序变得过于复杂。 例如， 我们来思考如何创建一个 房屋House对象。 建造一栋简单的房屋， 首先你需要建造四面墙和地板， 安装房门和一套窗户， 然后再建造一个屋顶。 但是如果你想要一栋更宽敞更明亮的房屋， 还要有院子和其他设施 （例如暖气、 排水和供电设备）， 那又该怎么办呢？ 最简单的方法是扩展 房屋基类， 然后创建一系列涵盖所有参数组合的子类。 但最终你将面对相当数量的子类。 任何新增的参数 （例如门廊类型） 都会让这个层次结构更加复杂。 另一种方法则无需生成子类。 你可以在 房屋基类中创建一个包括所有可能参数的超级构造函数， 并用它来控制房屋对象。 这种方法确实可以避免生成子类， 但它却会造成另外一个问题。 拥有大量输入参数的构造函数也有缺陷： 这些参数也不是每次都要全部用上的。 通常情况下， 绝大部分的参数都没有使用， 这使得对于构造函数的调用十分不简洁。 例如， 只有很少的房子有游泳池， 因此与游泳池相关的参数十之八九是毫无用处的。 解决方案： 生成器模式建议将对象构造代码从产品类中抽取出来， 并将其放在一个名为生成器的独立对象中。 该模式会将对象构造过程划分为一组步骤， 比如 buildWalls创建墙壁和 buildDoor创建房门创建房门等。 每次创建对象时， 你都需要通过生成器对象执行一系列步骤。 重点在于你无需调用所有步骤， 而只需调用创建特定对象配置所需的那些步骤即可。 当你需要创建不同形式的产品时， 其中的一些构造步骤可能需要不同的实现。 例如， 木屋的房门可能需要使用木头制造， 而城堡的房门则必须使用石头制造。 在这种情况下， 你可以创建多个不同的生成器， 用不同方式实现一组相同的创建步骤。 然后你就可以在创建过程中使用这些生成器 （例如按顺序调用多个构造步骤） 来生成不同类型的对象。 例如， 假设第一个建造者使用木头和玻璃制造房屋， 第二个建造者使用石头和钢铁， 而第三个建造者使用黄金和钻石。 在调用同一组步骤后， 第一个建造者会给你一栋普通房屋， 第二个会给你一座小城堡， 而第三个则会给你一座宫殿。 但是， 只有在调用构造步骤的客户端代码可以通过通用接口与建造者进行交互时， 这样的调用才能返回需要的房屋。 主管 你可以进一步将用于创建产品的一系列生成器步骤调用抽取成为单独的主管类。 主管类可定义创建步骤的执行顺序， 而生成器则提供这些步骤的实现。 严格来说， 你的程序中并不一定需要主管类。 客户端代码可直接以特定顺序调用创建步骤。 不过， 主管类中非常适合放入各种例行构造流程， 以便在程序中反复使用。 此外， 对于客户端代码来说， 主管类完全隐藏了产品构造细节。 客户端只需要将一个生成器与主管类关联， 然后使用主管类来构造产品， 就能从生成器处获得构造结果了。 ","date":"2024-05-15","objectID":"/posts/a44e805/:2:0","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["设计模式"],"content":"结构 ","date":"2024-05-15","objectID":"/posts/a44e805/:2:1","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["设计模式"],"content":"使用 在文件夹builder_patter 中，我创建了House实体类，对应结构中的Client，HouseBuilder接口对应其中的Builder,产品为Roof,Wall,Door,Window，分别在ConcretHouseBuilder中进行建造，ConcretHouseBuilder实现了HouseBuilder接口。 HouseBuilderEngineer对应图中的主管，负责定义构造步骤的顺序。 下面我们来看一下生成器模式的应用场景 1.使用生成器模式可避免 “重叠构造函数 （telescoping constructor）” 的出现。 假设你的构造函数中有十个可选参数， 那么调用该函数会非常不方便； 因此， 你需要重载这个构造函数， 新建几个只有较少参数的简化版。 但这些构造函数仍需调用主构造函数， 传递一些默认数值来替代省略掉的参数。 生成器模式让你可以分步骤生成对象， 而且允许你仅使用必须的步骤。 应用该模式后， 你再也不需要将几十个参数塞进构造函数里了。 2.当你希望使用代码创建不同形式的产品 （例如石头或木头房屋） 时， 可使用生成器模式 如果你需要创建的各种形式的产品， 它们的制造过程相似且仅有细节上的差异， 此时可使用生成器模式。 基本生成器接口中定义了所有可能的制造步骤， 具体生成器将实现这些步骤来制造特定形式的产品。 同时， 主管类将负责管理制造步骤的顺序。 3.使用生成器构造组合树或其他复杂对象。 生成器模式让你能分步骤构造产品。 你可以延迟执行某些步骤而不会影响最终产品。 你甚至可以递归调用这些步骤， 这在创建对象树时非常方便。 生成器在执行制造步骤时， 不能对外发布未完成的产品。 这可以避免客户端代码获取到不完整结果对象的情况。 ","date":"2024-05-15","objectID":"/posts/a44e805/:2:2","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["设计模式"],"content":"优缺点 ","date":"2024-05-15","objectID":"/posts/a44e805/:2:3","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["设计模式"],"content":"抽象工厂模式 ","date":"2024-05-15","objectID":"/posts/a44e805/:3:0","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["设计模式"],"content":"单例模式 https://refactoringguru.cn/design-patterns/singleton 单例模式还有七种写法，见 https://juejin.cn/post/6844904105891250189 我写的代码是懒汉式的 单例模式是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。 单例模式同时解决了两个问题， 所以违反了单一职责原则： 1.保证一个类只有一个实例。 为什么会有人想要控制一个类所拥有的实例数量？ 最常见的原因是控制某些共享资源 （例如数据库或文件） 的访问权限。 它的运作方式是这样的： 如果你创建了一个对象， 同时过一会儿后你决定再创建一个新对象， 此时你会获得之前已创建的对象， 而不是一个新对象。 注意， 普通构造函数无法实现上述行为， 因为构造函数的设计决定了它必须总是返回一个新对象。 2.为该实例提供一个全局访问节点。 还记得你 （好吧， 其实是我自己） 用过的那些存储重要对象的全局变量吗？ 它们在使用上十分方便， 但同时也非常不安全， 因为任何代码都有可能覆盖掉那些变量的内容， 从而引发程序崩溃。 和全局变量一样， 单例模式也允许在程序的任何地方访问特定对象。 但是它可以保护该实例不被其他代码覆盖。 还有一点： 你不会希望解决同一个问题的代码分散在程序各处的。 因此更好的方式是将其放在同一个类中， 特别是当其他代码已经依赖这个类时更应该如此。 ","date":"2024-05-15","objectID":"/posts/a44e805/:4:0","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["设计模式"],"content":"使用 所有单例的实现都包含以下两个相同的步骤： 将默认构造函数设为私有， 防止其他对象使用单例类的 new运算符。 新建一个静态构建方法作为构造函数。 该函数会 “偷偷” 调用私有构造函数来创建对象， 并将其保存在一个静态成员变量中。 此后所有对于该函数的调用都将返回这一缓存对象。 如果你的代码能够访问单例类， 那它就能调用单例类的静态方法。 无论何时调用该方法， 它总是会返回相同的对象。 ","date":"2024-05-15","objectID":"/posts/a44e805/:4:1","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["设计模式"],"content":"结构 代码在singleton_pattern文件夹下 ","date":"2024-05-15","objectID":"/posts/a44e805/:4:2","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["设计模式"],"content":"应用场景 ","date":"2024-05-15","objectID":"/posts/a44e805/:4:3","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["设计模式"],"content":"优缺点 ","date":"2024-05-15","objectID":"/posts/a44e805/:4:4","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["设计模式"],"content":"原型模式 https://refactoringguru.cn/design-patterns/prototype 原型模式是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。 ","date":"2024-05-15","objectID":"/posts/a44e805/:5:0","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["设计模式"],"content":"问题 如果你有一个对象， 并希望生成与其完全相同的一个复制品， 你该如何实现呢？ 首先， 你必须新建一个属于相同类的对象。 然后， 你必须遍历原始对象的所有成员变量， 并将成员变量值复制到新对象中。 不错！ 但有个小问题。 并非所有对象都能通过这种方式进行复制， 因为有些对象可能拥有私有成员变量， 它们在对象本身以外是不可见的。 直接复制还有另外一个问题。 因为你必须知道对象所属的类才能创建复制品， 所以代码必须依赖该类。 即使你可以接受额外的依赖性， 那还有另外一个问题： 有时你只知道对象所实现的接口， 而不知道其所属的具体类， 比如可向方法的某个参数传入实现了某个接口的任何对象。 ","date":"2024-05-15","objectID":"/posts/a44e805/:6:0","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["设计模式"],"content":"解决方案 原型模式将克隆过程委派给被克隆的实际对象。模式为所有支持克隆的对象声明了一个通用接口， 该接口让你能够克隆对象， 同时又无需将代码和对象所属类耦合。 通常情况下， 这样的接口中仅包含一个 克隆方法。 所有的类对克隆方法的实现都非常相似。 该方法会创建一个当前类的对象， 然后将原始对象所有的成员变量值复制到新建的类中。 你甚至可以复制私有成员变量， 因为绝大部分编程语言都允许对象访问其同类对象的私有成员变量。 支持克隆的对象即为原型。 当你的对象有几十个成员变量和几百种类型时， 对其进行克隆甚至可以代替子类的构造。 其运作方式如下： 创建一系列不同类型的对象并不同的方式对其进行配置。 如果所需对象与预先配置的对象相同， 那么你只需克隆原型即可， 无需新建一个对象。 ","date":"2024-05-15","objectID":"/posts/a44e805/:6:1","tags":["设计模式","面向对象"],"title":"设计模式","uri":"/posts/a44e805/"},{"categories":["Go"],"content":"使用详情见 https://pkg.go.dev/flag https://www.liwenzhou.com/posts/Go/flag/ 例子 写一个模拟git命令的 package main import ( \"flag\" \"fmt\" \"os\" ) func main() { // 定义子命令 initCmd := flag.NewFlagSet(\"init\", flag.ExitOnError) commitCmd := flag.NewFlagSet(\"commit\", flag.ExitOnError) // 为 commit 子命令定义参数 commitMessage := commitCmd.String(\"m\", \"\", \"Commit message\") // 检查是否传递了子命令 if len(os.Args) \u003c 2 { fmt.Println(\"expected 'init' or 'commit' subcommands\") printHelp() os.Exit(1) } // 解析子命令和参数 switch os.Args[1] { case \"init\": handleInit(initCmd, os.Args[2:]) case \"commit\": handleCommit(commitCmd, os.Args[2:], commitMessage) default: fmt.Println(\"expected 'init' or 'commit' subcommands\") printHelp() os.Exit(1) } } // 处理 init 子命令 func handleInit(initCmd *flag.FlagSet, args []string) { initCmd.Parse(args) if len(args) \u003e 0 \u0026\u0026 (args[0] == \"-h\" || args[0] == \"--help\") { initCmd.Usage() return } fmt.Println(\"Repository initialized\") } // 处理 commit 子命令 func handleCommit(commitCmd *flag.FlagSet, args []string, commitMessage *string) { commitCmd.Parse(args) if len(args) \u003e 0 \u0026\u0026 (args[0] == \"-h\" || args[0] == \"--help\") { commitCmd.Usage() return } if *commitMessage == \"\" { fmt.Println(\"commit message is required\") commitCmd.Usage() os.Exit(1) } fmt.Printf(\"Commit with message: %s\\n\", *commitMessage) } // 打印帮助信息 func printHelp() { fmt.Println(\"Usage:\") fmt.Println(\" git init Initialize a new repository\") fmt.Println(\" git commit -m Commit changes with a message\") } ","date":"2024-05-15","objectID":"/posts/2f5f3f2/:0:0","tags":["Go"],"title":"Go Flag库使用","uri":"/posts/2f5f3f2/"},{"categories":["计算机网络 - HTTP协议"],"content":"1xx 状态码 API 不需要1xx状态码，下面介绍其他四类状态码的精确含义。 ","date":"2024-05-15","objectID":"/posts/098d7b4/:1:0","tags":["Http","状态码"],"title":"HTTP状态码","uri":"/posts/098d7b4/"},{"categories":["计算机网络 - HTTP协议"],"content":"2xx 状态码 200状态码表示操作成功，但是不同的方法可以返回更精确的状态码。 GET: 200 OK POST: 201 Created PUT: 200 OK PATCH: 200 OK DELETE: 204 No Content 上面代码中，POST返回201状态码，表示生成了新的资源；DELETE返回204状态码，表示资源已经不存在。 ","date":"2024-05-15","objectID":"/posts/098d7b4/:2:0","tags":["Http","状态码"],"title":"HTTP状态码","uri":"/posts/098d7b4/"},{"categories":["计算机网络 - HTTP协议"],"content":"3xx 状态码 API 用不到301状态码（永久重定向）和302状态码（暂时重定向，307也是这个含义），因为它们可以由应用级别返回，浏览器会直接跳转，API 级别可以不考虑这两种情况。 API 主要是用303 See Other，表示参考另一个 URL。它与302和307的含义一样，也是”暂时重定向”，区别在于302和307用于GET请求，而303用于POST、PUT和DELETE请求。收到303以后，浏览器不会自动跳转，而会让用户自己决定下一步怎么办。下面是一个例子。 HTTP/1.1 303 See Other Location: /api/orders/12345 ","date":"2024-05-15","objectID":"/posts/098d7b4/:3:0","tags":["Http","状态码"],"title":"HTTP状态码","uri":"/posts/098d7b4/"},{"categories":["计算机网络 - HTTP协议"],"content":"4xx 状态码 4xx 状态码表示客户端错误，主要有下面几种： 400 Bad Request：服务器不理解客户端的请求，未做任何处理。 401 Unauthorized：用户未提供身份验证凭据，或者没有通过身份验证。 403 Forbidden：用户通过了身份验证，但是不具有访问资源所需的权限。 404 Not Found：所请求的资源不存在，或不可用。 405 Method Not Allowed：用户已经通过身份验证，但是所用的 HTTP 方法不在他的权限之内。 410 Gone：所请求的资源已从这个地址转移，不再可用。 415 Unsupported Media Type：客户端要求的返回格式不支持。比如，API 只能返回 JSON 格式，但是客户端要求返回 XML 格式。 422 Unprocessable Entity ：客户端上传的附件无法处理，导致请求失败。 429 Too Many Requests：客户端的请求次数超过限额。 ","date":"2024-05-15","objectID":"/posts/098d7b4/:4:0","tags":["Http","状态码"],"title":"HTTP状态码","uri":"/posts/098d7b4/"},{"categories":["计算机网络 - HTTP协议"],"content":"5xx 状态码 5xx状态码表示服务端错误。一般来说，API 不会向用户透露服务器的详细信息，所以只要两个状态码就够了。 500 Internal Server Error：客户端请求有效，服务器处理时发生了意外。 503 Service Unavailable：服务器无法处理请求，一般用于网站维护状态。 ","date":"2024-05-15","objectID":"/posts/098d7b4/:5:0","tags":["Http","状态码"],"title":"HTTP状态码","uri":"/posts/098d7b4/"},{"categories":["Docker"],"content":"Docker安装mysql $ docker pull mysql:latest $ cd ~ $ mkdir mysql $ cd mysql $ docker run -p 3306:3306 --name mysql -v $PWD/conf/my.cnf:/etc/mysql/my.cnf -v $PWD/logs:/logs -v $PWD/data:/mysql_data -e MYSQL_ROOT_PASSWORD=123456 -d mysql 连接mysql https://docs.fedoraproject.org/en-US/quick-docs/installing-mysql-mariadb/ 可以参考一下官方文档 $ sudo dnf install community-mysql-server $ mysql -h 127.0.0.1 -P 3306 -u root -p123456 ","date":"2024-05-15","objectID":"/posts/e3c5896/:0:0","tags":["Docker","Mysql"],"title":"Docker安装mysql","uri":"/posts/e3c5896/"},{"categories":["Docker"],"content":" 原文链接: https://www.yuque.com/qingkongxiaguang/zwhkpi/kq6rlg Docker容器技术 Docker是一门平台级别的技术，涉及的范围很广，所以，在开始之前，请确保你完成：Java SpringBoot 篇（推荐完成SpringCloud篇再来）视频教程及之前全部路线，否则学习会非常吃力，另外推荐额外掌握：《计算机网络》、《操作系统》相关知识。学一样东西不能完全靠记忆来完成，而是需要结合自己所学的基础知识加以理解，一般来说，单凭记忆能够掌握的东西往往是最廉价的。 **Docker官网：**https://www.docker.com **课前准备：**配置2C2G以上Linux服务器一台，云服务器、虚拟机均可。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:0:0","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"容器技术入门 随着时代的发展，Docker也逐渐走上了历史舞台，曾经我们想要安装一套环境，需要花费一下午甚至一整天来配置和安装各个部分（比如运行我们自己的SpringBoot应用程序，可能需要安装数据库、安装Redis、安装MQ等，各种各样的环境光是安装就要花费很多时间，真的是搞得心态爆炸），而有了Docker之后，我们的程序和环境部署就变得非常简单了，我们只需要将这些环境一起打包成一个镜像。而到服务器上部署时，可以直接下载镜像实现一键部署，是不是很方便？ 包括我们在学习SpringCloud需要配置的各种组件，可能在自己电脑的环境中运行会遇到各种各样的问题（可能由于电脑上各种环境没配置，导致无法运行），而现在只需要下载镜像就能直接运行，所有的环境全部在镜像中配置完成，开箱即用。 真的有这么神奇吗？我们来试试看。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:1:0","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"环境安装和部署 首先我们还是先将Docker环境搭建好（建议和我同一个环境，不然出了问题只能自己想办法了），这里我们使用： Ubuntu 22.04 操作系统 Docker分为免费的CE（Community Edition）社区版本和EE（Enterprise Edition）企业级付费版本，所以我们这里选择docker-ce进行安装。官方安装文档：https://docs.docker.com/engine/install/ubuntu/ 首先安装一些工具： sudo apt-get install ca-certificates curl gnupg lsb-release 不过在Ubuntu22.04已经默认安装好了。接着安装官方的GPG key： sudo mkdir -p /etc/apt/keyrings curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg 最后将Docker的库添加到apt资源列表中： echo \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list \u003e /dev/null 接着我们更新一次apt： sudo apt update 最后安装Docker CE版本： sudo apt install docker-ce 等待安装完成就可以了： 可以看到安装成功后版本是20.10.17，当然可能你们安装的时候就是更新的版本了。最后我们将当前用户添加到docker用户组中，不然每次使用docker命令都需要sudo执行，很麻烦： sudo usermod -aG docker \u003c用户名\u003e 配置好后，我们先退出SSH终端，然后重新连接就可以生效了。 这样我们Docker 的学习环境就配置好了，现在我们就尝试通过Docker来部署一个Nginx服务器试试看，使用很简单，只需要一个命令就可以了（当然现在看不懂没关系，我们后面会细嗦）： sudo docker run -d -p 80:80 nginx 首选它会从镜像仓库中下载对应的镜像，国内访问速度还行，不需要单独配置镜像源。接着下载完成后，就会在后台运行了，我们可以使用浏览器访问试试看： 可以看到，Nginx服务器已经成功部署了，但是实际上我们并没有在Ubuntu中安装Nginx，而是通过Docker运行的镜像来进行服务器搭建的，是不是感觉玩法挺新奇的。除了Nginx这种简单的应用之外，我们还可以通过Docker来部署复杂应用，之后我们都会一一进行讲解的。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:1:1","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"从虚拟机到容器 前面我们成功安装了Docker学习环境，以及浅尝了一下Docker为我们带来的应用快速部署。在正式进入学习之前，我们就先从Docker的发展开始说起。 在Docker出现之前，虚拟化技术可以说是占据了主导地位。首先我们来谈谈为什么会出现虚拟化技术，我们知道在企业中服务器可以说是必不可少的一种硬件设施了，服务器也是电脑，但是不像我们的家用电脑，服务器的配置是非常高的，我们家用电脑的CPU可能最高配也就20核了，内存很少有超过128G的电脑，64G内存的家用电脑可以算奢侈了。而服务器不一样，服务器级别的CPU动辄12核，甚至服务器还能同时安装多块CPU，能直接堆到好几十核： 我们家用级CPU一般是AMD的锐龙系列和Intel的酷睿系列（比如i3 i5 i7 i9），而服务器CPU一般是Intel的志强（Xeno）系列，这种CPU的特点就是核心数非常多： 并且服务器CPU相比家用CPU的功耗也会更大，因此服务器CPU的发热量非常高，如果你有幸去过机房，你会听见散热风扇猛烈转动的声音（但是服务器CPU的频率没有家用级CPU高，一般大型游戏要求的是高频率而不是核心数，而且功耗也比较大，所以并不适合做家用电脑，所以以后在网上买台式机，看到什么“i9级”CPU千万别买，是这些黑心商家把国外服务器上淘汰下来的服务器CPU（洋垃圾）装成电脑卖给你，所以会很便宜，同时核心数又能媲美i9，所以还是一分钱一分货实在） 服务器无论是CPU资源还是内存资源都远超家用电脑，而我们编写的Java后端项目，最后都会运行在这些服务器上，不过有一个问题，服务器既然有这么丰富的硬件资源，就跑咱们这一个小Java后端，是不是有点核弹炸蚊子的感觉了？可能顶多就用了服务器5%的硬件资源，服务器这么牛就运行个这也太浪费了吧。 所以，为了解决这种资源利用率只有5%-15%的情况，咱们能不能想个办法，把这一台服务器分成多个小服务器使用，每个小服务器只分配一部分的资源，比如分一个小服务器出去，只给2个CPU核心和4G内存。但是由于设计上的问题，我们的电脑只能同时运行一个操作系统，那么怎么办呢？此时虚拟化技术就开始兴起了。 虚拟化使用软件来模拟硬件并创建虚拟计算机系统。这样一来，企业便可以在单台服务器上运行多个虚拟系统，也就是运行多个操作系统和应用，而这可以实现规模经济以及提高效益。比如我们电脑上经常使用的VMware就是一种民用级虚拟化软件： 我们可以使用VMware来创建虚拟机，这些虚拟机实际上都是基于我们当前系统上的VMware软件来运行的，当然VMware也有服务器专用的虚拟化软件，有了虚拟化之后，我们的服务器就像这样： 相当于通过虚拟机模拟了很多来电脑出来，这样我们就可以在划分出来的多台虚拟机上分别安装系统和部署我们的应用程序了，并且我们可以自由分配硬件资源，合理地使用。一般在企业中，不同的应用程序可能会被分别部署到各个服务器上，隔离开来，此时使用虚拟机就非常适合。 实际上我们在什么腾讯云、阿里云租的云服务器，都是经过虚拟化技术划分出来的虚拟机而已。 那么，既然虚拟机都这么方便了，容器又是怎么杀出一条血路的呢？我们先来看看什么是容器。 容器和虚拟机比较类似，都可以为应用提供封装和隔离，都是软件，但是容器中的应用运行是寄托于宿主操作系统的，实际上依然是在直接使用操作系统的资源，当然应用程序之间环境依然是隔离的，而虚拟机则是完全模拟一台真正的电脑出来，直接就是两台不同的电脑。 因此容器相比虚拟机就简单多了，并且启动速度也会快很多，开销小了不少。 不过容器火的根本原因还是它的集装箱思想，我们知道，如果我们要写一个比如论坛、电商这类的Java项目，那么数据库、消息队列、缓存这类中间件是必不可少的，因此我们如果想要将一个服务部署到服务器，那么实际上还要提前准备好各种各样的环境，先安装好MySQL、Redis、RabbitMQ等应用，配置好了环境，再将我们的Java应用程序启动，整个流程下来，光是配置环境就要浪费大量的时间，如果是大型的分布式项目，可能要部署很多台机器，那岂不是我们得一个一个来？项目上个线就要花几天时间，显然是很荒唐的。 而容器可以打包整个环境，比较MySQL、Redis等以及我们的Java应用程序，可以被一起打包为一个镜像，当我们需要部署服务时，只需要像我们之前那样，直接下载镜像运行即可，不需要再进行额外的配置了，整个镜像中环境是已经配置好的状态，开箱即用。 而我们要重点介绍的就是Docker了，可以看到它的图标就是一只鲸鱼，鲸鱼的上面是很多个集装箱，每个集装箱就是我们的整个环境+应用程序，Docker可以将任何应用及其依赖打包为一个轻量级，可移植，自包含的容器，容器可以运行在几乎所有的操作系统上。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:1:2","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"容器工作机制简述 我们先来看看Docker的整体架构： 实际上分为三个部分： Docker 客户端：也就是我们之前使用的docker命令，都是在客户端上执行的，操作会发送到服务端上处理。 Docker 服务端：服务端就是启动容器的主体了，一般是作为服务在后台运行，支持远程连接。 Registry：是存放Docker镜像的仓库，跟Maven一样，也可以分公有和私有仓库，镜像可以从仓库下载到本地存放。 当我们需要在服务器上部署一个已经打包好的应用和环境，我们只需要下载打包好的镜像就可以了，我们前面执行了： sudo docker run -d -p 80:80 nginx 实际上这个命令输入之后： Docker客户端将操作发送给服务端，告诉服务端我们要运行nginx这个镜像。 Docker服务端先看看本地有没有这个镜像，发现没有。 接着只能从公共仓库Docker Hub去查找下载镜像了。 下载完成，镜像成功保存到本地。 Docker服务端加载Nginx镜像，启动容器开始正常运行（注意容器和其他容器之间，和外部之间，都是隔离的，互不影响） 所以，整个流程中，Docker就像是一搜运输船，镜像就像是集装箱，通过运输船将世界各地的货物送往我们的港口，货物到达港口后，Docker并不关心集装箱里面的是什么，只需要创建容器开箱即用就可以了。相比我们传统的手动安装配置环境，不知道方便了几个层次。 不过容器依然是寄托于宿主主机的运行的，所以一般在生产环境下，都是通过虚拟化先创建多台主机，然后再到各个虚拟机中部署Docker，这样的话，运维效率就大大提升了。 从下一章开始，我们就正式地来学习一下Docker的各种操作。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:1:3","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"容器与镜像 要启动容器最关键的就是镜像，我们来看看镜像相关的介绍。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:2:0","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"初识容器镜像 首先我们来了解一下镜像的相关操作，比如现在我们希望把某个镜像从仓库下载到本地，这里使用官方的hello-world镜像： docker pull hello-world 只需要输入pull命令，就可以直接下载到指定的镜像了： 可以看到对上面一行有一句Using default tag，实际上一个镜像的名称是由两部分组成的，一个是repository，还有一个是tag，一般情况下约定repository就是镜像名称，tag作为版本，默认为latest，表示最新版本。所以指定版本运行的话： docker pull 名称:版本 之后为了教学方便，我们就直接使用默认的tag，不去指定版本了。 镜像下载之后会存放在本地，要启动这个镜像的容器，实际上就像我们之前那样，输入run命令就可以了： docker run hello-world 当然如果仅仅是只想创建而不想马上运行的话，可以使用create命令： docker create hello-world 可以看到成功启动了： 启动之后，会使用当前镜像自动创建一个容器，我们可以输入ps命令来查看当前容器的容器列表： docker ps -a 注意后面要加一个-a表示查看所有容器（其他选项可以使用-h查看），如果不加的话，只会显示当前正在运行的容器，而HelloWorld是一次性的不是Nginx那样的常驻程序，所以容器启动打印了上面的内容之后，容器就停止运行了： 可以看到容器列表中有我们刚刚创建的hello-world以及我们之前创建的nginx（注意同一个镜像可以创建多个容器），每个容器都有一个随机生成的容器ID写在最前面，后面是容器的创建时间以及当前的运行状态，最后一列是容器的名称，在创建容器时，名称可以由我们指定也可以自动生成，这里就是自动生成的。 我们可以手动指定名称启动，在使用run命令时，添加--name参数即可： docker run --name=lbwnb hello-world 我们可以手动开启处于停止状态的容器： docker start \u003c容器名称/容器ID\u003e 注意启动的对象我们要填写容器的ID或是容器的名称才可以，容器ID比较长，可以不写全只写一半，但是你要保证你输入的不完全容器ID是唯一的。 如果想要停止容器直接输入stop命令就可以了： docker stop \u003c容器名称/容器ID\u003e 或是重启： docker restart \u003c容器名称/容器ID\u003e 如果我们不需要使用容器了，那么可以将容器删除，但是注意只有容器处于非运行状态时才可以删除： docker rm \u003c容器名称/容器ID\u003e 当然如果我们希望容器在停止后自动删除，我们可以在运行时添加--rm参数： docker run --rm 镜像名称 删除后，容器将不复存在，当没有任何关于nginx的容器之后，我们可以删除nginx的本地镜像： 我们可以使用images命令来检查一下当前本地有那些镜像： docker images 至此，我们已经了解了Docker的简单使用，在后面的学习中，我们还会继续认识更多的玩法。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:2:1","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"镜像结构介绍 前面我们了解了Docker的相关基本操作，实际上容器的基石就是镜像，有了镜像才能创建对应的容器实例，那么我们就先从镜像的基本结构开始说起，我们来看看镜像到底是个什么样的存在。 我们在打包项目时，实际上往往需要一个基本的操作系统环境，这样我们才可以在这个操作系统上安装各种依赖软件，比如数据库、缓存等，像这种基本的系统镜像，我们称为base镜像，我们的项目之后都会基于base镜像进行打包，当然也可以不需要base镜像，仅仅是基于当前操作系统去执行简单的命令，比如我们之前使用的hello-world就是。 一般base镜像就是各个Linux操作系统的发行版，比如我们正在使用的Ubuntu，还有CentOS、Kali等等。这里我们就下载一下CentOS的base镜像： docker pull centos 可以看到，CentOS的base镜像就已经下载完成，不像我们使用完整系统一样，base镜像的CentOS省去了内核，所以大小只有272M，这里需要解释一下base镜像的机制： Linux操作体系由内核空间和用户空间组成，其中内核空间就是整个Linux系统的核心，Linux启动后首先会加bootfs文件系统，加载完成后会自动卸载掉，之后会加载用户空间的文件系统，这一层是我们自己可以进行操作的部分： bootfs包含了BootLoader和Linux内核，用户是不能对这层作任何修改的，在内核启动之后，bootfs会自动卸载。 rootfs则包含了系统上的常见的目录结构，包括/dev、 /proc、 /bin等等以及一些基本的文件和命令，也就是我们进入系统之后能够操作的整个文件系统，包括我们在Ubuntu下使用的apt和CentOS下使用的yum，都是用户空间上的。 base镜像底层会直接使用宿主主机的内核，也就是说你的Ubuntu内核版本是多少，那么base镜像中的CentOS内核版本就是多少，而rootfs则可以在不同的容器中运行多种不同的版本。所以，base镜像实际上只有CentOS的rootfs，因此只有300M大小左右，当然，CentOS里面包含多种基础的软件，还是比较臃肿的，而某些操作系统的base镜像甚至都不到10M。 使用uname命令可以查看当前内核版本： 因此，Docker能够同时模拟多种Linux操作系统环境，就不足为奇了，我们可以尝试启动一下刚刚下载的base镜像： docker run -it centos 注意这里需要添加-it参数进行启动，其中-i表示在容器上打开一个标准的输入接口，-t表示分配一个伪tty设备，可以支持终端登录，一般这两个是一起使用，否则base容器启动后就自动停止了。 可以看到使用ls命令能够查看所有根目录下的文件，不过很多命令都没有，连clear都没有，我们来看看内核版本： 可以看到内核版本是一样的（这也是缺点所在，如果软件对内核版本有要求的话，那么此时使用Docker就直接寄了），我们输入exit就可以退出容器终端了，可以看到退出后容器也停止了： 当然我们也可以再次启动，注意启动的时候要加上-i才能进入到容器进行交互，否则会在后台运行： 基于base镜像，我们就可以在这基础上安装各种各样的软件的了，几乎所有的镜像都是通过在base镜像的基础上安装和配置需要的软件构建出来的： 每安装一个软件，就在base镜像上一层层叠加上去，采用的是一种分层的结构，这样多个容器都可以将这些不同的层次自由拼装，比如现在好几个容器都需要使用CentOS的base镜像，而上面运行的软件不同，此时分层结构就很爽了，我们只需要在本地保存一份base镜像，就可以给多个不同的容器拼装使用，是不是感觉很灵活？ 我们看到除了这些软件之外，最上层还有一个可写容器层，这个是干嘛的呢，为什么要放在最上面？ 我们知道，所有的镜像会叠起来组成一个统一的文件系统，如果不同层中存在相同位置的文件，那么上层的会覆盖掉下层的文件，最终我们看到的是一个叠加之后的文件系统。当我们需要修改容器中的文件时，实际上并不会对镜像进行直接修改，而是在最顶上的容器层（最上面一般称为容器层，下面都是镜像层）进行修改，不会影响到下面的镜像，否则镜像就很难实现多个容器共享了。所以各个操作如下： 文件读取：要读取一个文件，Docker会最上层往下依次寻找，找到后则打开文件。 文件创建和修改：创建新文件会直接添加到容器层中，修改文件会从上往下依次寻找各个镜像中的文件，如果找到，则将其复制到容器层，再进行修改。 删除文件：删除文件也会从上往下依次寻找各个镜像中的文件，一旦找到，并不会直接删除镜像中的文件，而是在容器层标记这个删除操作。 也就是说，我们对整个容器内的文件进行的操作，几乎都是在最上面的容器层进行的，我们是无法干涉到下面所有的镜像层文件的，这样就很好地保护了镜像的完整性，才能实现多个容器共享使用。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:2:2","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"构建镜像 前面我们已经了解了Docker镜像的结构，实际上所有常用的应用程序都有对应的镜像，我们只需要下载这些镜像然后就可以使用了，而不需要自己去手动安装，顶多需要进行一些特别的配置。当然要是遇到某些冷门的应用，可能没有提供镜像，这时就要我们手动去安装，接着我们就来看看如何构建我们自己的Docker镜像。构建镜像有两种方式，一种是使用commit命令来完成，还有一种是使用Dockerfile来完成，我们先来看第一种。 这里我们就做一个简单的例子，比如我们现在想要在Ubuntu的base镜像中安装Java环境，并将其打包为新的镜像（这个新的镜像就是一个包含Java环境的Ubuntu系统镜像） 咱们先启动Ubuntu镜像，然后使用yum命令（跟apt比较类似）来安装Java环境，首先是run命令： docker pull ubuntu 接着启动： 直接使用apt命令来安装Java环境，在这之前先更新一下，因为是最小安装所以本地没有任何软件包： 接着输入： apt install openjdk-8-jdk 等待安装完成： 这样，我们就完成了对Java环境的安装了，接着我们就可以退出这个镜像然后将其构建为新的镜像： 使用commit命令可以将容器保存为新的镜像： docker commit 容器名称/ID 新的镜像名称 可以看到安装了软件之后的镜像大小比我们原有的大小大得多，这样我们就可以通过这个镜像来直接启动一个带Java环境的Ubuntu操作系统容器了。不过这种方式虽然自定义度很高，但是Docker官方并不推荐，这样的话使用者并不知道镜像是如何构建出来的，是否里面带了后门都不知道，并且这样去构建效率太低了，如果要同时构建多种操作系统的镜像岂不是要一个一个去敲？我们作为普通用户实际上采用Dokcerfile的方式会更好一些。 我们来看看如何使用Dockerfile的形式创建一个带Java环境的Ubuntu系统镜像。首先直接新建一个名为Dockerfile的文件： touch Dockerfile 接着我们来进行编辑，Dockerfile内部需要我们编写多种指令来告诉Docker我们的镜像的相关信息： FROM \u003c基础镜像\u003e 首先我们需要使用FROM指令来选择当前镜像的基础镜像（必须以这个指令开始），这里我们直接使用ubuntu作为基础镜像即可，当然如果不需要任何基础镜像的话，直接使用scratch表示从零开始构建，这里就不演示了。 基础镜像设定完成之后，我们就需要在容器中运行命令来安装Java环境了，这里需要使用RUN指令： RUN apt update RUN apt install -y openjdk-8-jdk 每条指令执行之后，都会生成一个新的镜像层。 OK，现在我们的Dockerfile就编写完成了，只需要完成一次构建即可： docker build -t \u003c镜像名称\u003e \u003c构建目录\u003e 执行后，Docker会在构建目录中寻找Dockerfile文件，然后开始依次执行Dockerfile中的指令： 构建过程的每一步都非常清晰地列出来了，一共三条指令对应三步依次进行，我们稍微等待一段时间进行安装，安装过程中所以的日志信息会直接打印到控制台（注意Docker镜像构建有缓存机制，就算你现在中途退出了，然后重新进行构建，也会直接将之前已经构建好的每一层镜像，直接拿来用，除非修改了Dockerfile文件重新构建，只要某一层发生变化其上层的构建缓存都会失效，当然包括pull时也会有类似的机制） 最后成功安装，会出现在本地： 可以看到安装出来的大小跟我们之前的是一样的，因为做的事情是一模一样的。我们可以使用history命令来查看构建历史： 可以看到最上面两层是我们通过使用apt命令生成的内容，就直接作为当前镜像中的两层镜像，每层镜像都有一个自己的ID，不同的镜像大小也不一样。而我们手动通过commit命令来生成的镜像没有这个记录： 如果遇到镜像ID为missing的一般是从Docker Hub中下载的镜像会有这个问题，但是问题不大。用我们自己构建的镜像来创建容器就可以直接体验带Java环境的容器了： 有关Dockerfile的其他命令，我们还会在后续的学习中逐步认识。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:2:3","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"发布镜像到远程仓库 前面我们学习了如何构建一个Docker镜像，我们可以将自己的镜像发布到Docker Hub中，就像Git远程仓库一样，我们可以将自己的镜像上传到这里：https://hub.docker.com/repositories，没有账号的先去进行注册。 点击右上角的创建仓库，然后填写信息： 创建完成后，我们就有了一个公共的镜像仓库，我们可以将本地的镜像上传了，上传之前我们需要将镜像名称修改得规范一点，这里使用tag命令来重新打标签： docker tag ubuntu-java-file:latest 用户名/仓库名称:版本 这里我们将版本改成1.0版本吧，不用默认的latest了。 修改完成后，会创建一个新的本地镜像，名称就是我们自己定义的了。接着我们需在本地登录一下： 登录成功后我们就可以上传了： docker push nagocoler/ubuntu-java:1.0 哈哈，500M的东西传上去，还是有点压力的，如果实在太慢各位可以重新做一个简单点的镜像。上传完成后，打开仓库，可以看到已经有一个1.0版本了： 注意公共仓库是可以被搜索和下载的，所以我们这里把本地的镜像全部删掉，去下载我们刚刚上传好的镜像。这里我们先搜索一下，搜索使用search命令即可： docker search nagocoler/ubuntu-java 我们可以使用pull命令将其下载下来： docker pull nagocoler/ubuntu-java:1.0 上传之后的镜像是被压缩过的，所以下载的内容就比较少一些。运行试试看： 当然各位也可以让自己的同学或是在其他机器上尝试下载自己的镜像，看看是不是都可以正常运行。 Docker Hub也可以自行搭建私服，但是这里就不多做介绍了，至此，有关容器和镜像的一些基本操作就讲解得差不多了。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:2:4","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"实战：使用IDEA构建SpringBoot程序镜像 这里我们创建一个新的SpringBoot项目，现在我们希望能够使用Docker快速地将我们的SpringBoot项目部署到安装了Docker的服务器上，我们就可以将其打包为一个Docker镜像。 先创建好一个项目让它跑起来，可以正常运行就没问题了，接着我们需要将其打包为Docker镜像，这里创建一个新的Dockerfile： FROM ubuntu RUN apt update \u0026\u0026 apt install -y openjdk-8-jdk 首先还是基于ubuntu构建一个带Java环境的系统镜像，接着我们先将其连接到我们的Docker服务器进行构建，由于IDEA自带了Docker插件，所以我们直接点击左上角的运行按钮，选择第二项 “为Dockerfile构建镜像”： 这里需要配置Docker的服务器，也就是我们在Ubuntu服务器安装的Docker，这里我们填写服务器相关信息，我们首选需要去修改一下Docker的一些配置，开启远程客户端访问： sudo vim /etc/systemd/system/multi-user.target.wants/docker.service 打开后，添加高亮部分： 修改完成后，重启Docker服务，如果是云服务器，记得开启2375 TCP连接端口： sudo systemctl daemon-reload sudo systemctl restart docker.service 现在接着在IDEA中进行配置： 在引擎API URL处填写我们Docker服务器的IP地址： tcp://IP:2375 显示连接成功后，表示配置正确，点击保存即可，接着就开始在我们的Docker服务器上进行构建了： 最后成功构建： 可以看到，Docker服务器上已经有了我们刚刚构建好的镜像： 不过名称没有指定，这里我们重新配置一下： 重新进行构建，就是我们自定义的名称了： 我们来创建一个容器试试看： 好了，现在基本环境搭建好了，我们接着就需要将我们的SpringBoot项目打包然后再容器启动时运行了，打开Maven执行打包命令： 接着我们需要编辑Dockerfile，将我们构建好的jar包放进去： COPY target/DockerTest-0.0.1-SNAPSHOT.jar app.jar 这里需要使用COPY命令来将文件拷贝到镜像中，第一个参数是我们要拷贝的本地文件，第二个参数是存放在Docker镜像中的文件位置，由于还没有学习存储管理，这里我们直接输入app.jar直接保存在默认路径即可。 接着我们就需要指定在启动时运行我们的Java程序，这里使用CMD命令来完成： FROM ubuntu RUN apt update \u0026\u0026 apt install -y openjdk-8-jdk COPY target/DockerTest-0.0.1-SNAPSHOT.jar app.jar CMD java -jar app.jar # EXPOSE 8080 CMD命令可以设定容器启动后执行的命令，EXPOSE可以指定容器需要暴露的端口，但是现在我们还没有学习网络相关的知识，所以暂时不使用，这里指定为我们启动Java项目的命令。配置完成后，重新构建： 可以看到历史中已经出现新的步骤了： 接着启动我们的镜像，我们可以直接在IDEA中进行操作，不用再去敲命令了，有点累： 启动后可以在右侧看到容器启动的日志信息： 但是我们发现启动之后并不能直接访问，这是为什么呢？这是因为容器内部的网络和外部网络是隔离的，我们如果想要访问容器内的服务器，需要将对应端口绑定到宿主机上，让宿主主机也开启这个端口，这样才能连接到容器内： docker run -p 8080:8080 -d springboot-test:1.0 这里-p表示端口绑定，将Docker容器内的端口绑定到宿主机的端口上，这样就可以通过宿主的8080端口访问到容器的8080端口了（有关容器网络管理我们还会在后面进行详细介绍），-d参数表示后台运行，当然直接在IDEA中配置也是可以的： 配置好后，点击重新创建容器： 重新运行后，我们就可以成功访问到容器中运行的SpringBoot项目了： 当然，为了以后方便使用，我们可以直接将其推送到Docker Hub中，这里我们还是创建一个新的公开仓库： 这次我们就使用IDEA来演示直接进行镜像的上传，直接点击： 接着我们需要配置一下我们的Docker Hub相关信息： OK，远程镜像仓库配置完成，直接推送即可，等待推送完成。 可以看到远程仓库中已经出现了我们的镜像，然后IDEA中也可以同步看到： 这样，我们就完成了使用IDEA将SpringBoot项目打包为Docker镜像。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:2:5","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"容器网络管理 **注意：**本小节学习需要掌握部分《计算机网络》课程中的知识。 前面我们学习了容器和镜像的一些基本操作，了解了如何通过镜像创建容器、然后自己构建容器，以及远程仓库推送等，这一部分我们接着来讨论容器的网络管理。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:3:0","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"容器网络类型 Docker在安装后，会在我们的主机上创建三个网络，使用network ls命令来查看： docker network ls 可以看到默认情况下有bridge、host、none这三种网络类型（其实有点像虚拟机的网络配置，也是分桥接、共享网络之类的），我们先来依次介绍一下，在开始之前我们先构建一个镜像，默认的ubuntu镜像由于啥软件都没有，所以我们把一会网络要用到的先提前装好： docker run -it ubuntu apt update apt install net-tools iputils-ping curl 这样就安装好了，我们直接退出然后将其构建为新的镜像： docker commit lucid_sammet ubuntu-net OK，一会我们就可以使用了。 **none网络：**这个网络除了有一个本地环回网络之外，就没有其他的网络了，我们可以在创建容器时指定这个网络。 这里使用--network参数来指定网络： docker run -it --network=none ubuntu-net 进入之后，我们可以直接查看一下当前的网络： ifconfig 可以看到只有一个本地环回lo网络设备： 所以这个容器是无法连接到互联网的： “真”单机运行，可以说是绝对的安全，没人能访问进去，存点密码这些还是不错的。 **bridge网络：**容器默认使用的网络类型，这是桥接网络，也是应用最广泛的网络类型： 实际上我们在宿主主机上查看网络信息，会发现有一个名为docker0的网络设备： 这个网络设备是Docker安装时自动创建的虚拟设备，它有什么用呢？我们可以来看一下默认创建的容器内部的情况： docker run -it ubuntu-net 可以看到容器的网络接口地址为172.17.0.2，实际上这是Docker创建的虚拟网络，就像容器单独插了一根虚拟的网线，连接到Docker创建的虚拟网络上，而docker0网络实际上作为一个桥接的角色，一头是自己的虚拟子网，另一头是宿主主机的网络。 网络拓扑类似于下面这样： 通过添加这样的网桥，我们就可以对容器的网络进行管理和控制，我们可以使用network inspect命令来查看docker0网桥的配置信息： docker network inspect bridge 这里的配置的子网是172.17.0.0，子网掩码是255.255.0.0，网关是172.17.0.1，也就是docker0这个虚拟网络设备，所以我们上面创建的容器就是这个子网内分配的地址172.17.0.2了。 之后我们还会讲解如何管理和控制容器网络。 **host网络：**当容器连接到此网络后，会共享宿主主机的网络，网络配置也是完全一样的： docker run -it --network=host ubuntu-net 可以看到网络列表和宿主主机的列表是一样的，不知道各位有没有注意到，连hostname都是和外面一模一样的： 只要宿主主机能连接到互联网，容器内部也是可以直接使用的： 这样的话，直接使用宿主的网络，传输性能基本没有什么折损，而且我们可以直接开放端口等，不需要进行任何的桥接： apt install -y systemctl nginx systemctl start nginx 安装Nginx之后直接就可以访问了，不需要开放什么端口： 相比桥接网络就方便得多了。 我们可以根据实际情况，来合理地选择这三种网络使用。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:3:1","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"用户自定义网络 除了前面我们介绍的三种网络之外，我们也可以自定义自己的网络，让容器连接到这个网络。 Docker默认提供三种网络驱动：bridge、overlay、macvlan，不同的驱动对应着不同的网络设备驱动，实现的功能也不一样，比如bridge类型的，其实就和我们前面介绍的桥接网络是一样的。 我们可以使用network create来试试看： docker network create --driver bridge test 这里我们创建了一个桥接网络，名称为test： 可以看到新增了一个网络设备，这个就是一会负责我们容器网络的网关了，和之前的docker0是一样的： docker network inspect test 这里我们创建一个新的容器，使用此网络： docker run -it --network=test ubuntu-net 成功得到分配的IP地址，是在这个网络内的，注意不同的网络之间是隔离的，我们可以再创建一个容器试试看： 可以看到不同的网络是相互隔离的，无法进行通信，当然我们也为此容器连接到另一个容器所属的网络下： docker network connect test 容器ID/名称 这样就连接了一个新的网络： 可以看到容器中新增了一个网络设备连接到我们自己定义的网络中，现在这两个容器在同一个网络下，就可以相互ping了： 这里就不介绍另外两种类型的网络了，他们是用于多主机通信的，目前我们只学习单机使用。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:3:2","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"容器间网络 我们首先来看看容器和容器之间的网络通信，实际上我们之前已经演示过ping的情况了，现在我们创建两个ubuntu容器： docker run -it ubuntu-net 先获取其中一个容器的网络信息： 我们可以直接在另一个容器中ping这个容器： ![image-20220702175444713](/Users/nagocoler/Library/Application Support/typora-user-images/image-20220702175444713.png) 可以看到能够直接ping通，因为这两个容器都是使用的bridge网络，在同一个子网中，所以可以互相访问。 我们可以直接通过容器的IP地址在容器间进行通信，只要保证两个容器处于同一个网络下即可，虽然这样比较方便，但是大部分情况下，容器部署之后的IP地址是自动分配的（当然也可以使用--ip来手动指定，但是还是不方便），我们无法提前得知IP地址，那么有没有一直方法能够更灵活一些呢？ 我们可以借助Docker提供的DNS服务器，它就像是一个真的DNS服务器一样，能够对域名进行解析，使用很简单，我们只需要在容器启动时给个名字就行了，我们可以直接访问这个名称，最后会被解析为对应容器的IP地址，但是注意只会在我们用户自定义的网络下生效，默认的网络是不行的： docker run -it --name=test01 --network=test ubuntu-net docker run -it --name=test02 --network=test ubuntu-net 接着直接ping对方的名字就可以了： 可以看到名称会自动解析为对应的IP地址，这样的话就不用担心IP不确定的问题了。 当然我们也可以让两个容器同时共享同一个网络，注意这里的共享是直接共享同一个网络设备，两个容器共同使用一个IP地址，只需要在创建时指定： docker run -it --name=test01 --network=container:test02 ubuntu-net 这里将网络指定为一个容器的网络，这样两个容器使用的就是同一个网络了： 可以看到两个容器的IP地址和网卡的Mac地址是完全一样的，它们的网络现在是共享状态，此时在容器中访问，localhost，既是自己也是别人。 我们可以在容器1中，安装Nginx，然后再容器2中访问： apt install -y systemctl nginx systemctl start nginx 成功访问到另一个容器中的Nginx服务器。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:3:3","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"容器外部网络 前面我们介绍了容器之间的网络通信，我们接着来看容器与外部网络的通信。 首先我们来看容器是如何访问到互联网的，在默认的三种的网络下，只有共享模式和桥接模式可以连接到外网，共享模式实际上就是直接使用宿主主机的网络设备连接到互联网，这里我们主要来看一下桥接模式。 通过前面的学习，我们了解到桥接模式实际上就是创建一个单独的虚拟网络，让容器在这个虚拟网络中，然后通过桥接器来与外界相连，那么数据包是如何从容器内部的网络到达宿主主机再发送到互联网的呢？实际上整个过程中最关键的就是依靠NAT（Network Address Translation）将地址进行转换，再利用宿主主机的IP地址发送数据包出去。 这里我们就来补充一下《计算机网络》课程中学习的NAT： 实际上NAT在我们生活中也是经常见到的，比如我们要访问互联网上的某个资源，要和服务器进行通信，那么就需要将数据包发送出去，同时服务器也要将数据包发送回来，我们可以知道服务器的IP地址，也可以直接去连接，因为服务器的IP地址是暴露在互联网上的，但是我们的局域网就不一样了，它仅仅局限在我们的家里，比如我们连接了家里的路由器，可以得到一个IP地址，但是你会发现，这个IP公网是无法直接访问到我们的，因为这个IP地址仅仅是一个局域网的IP地址，俗称内网IP，既然公网无法访问到我们，那服务器是如何将数据包发送给我们的呢？ 实际上这里就借助了NAT在帮助我们与互联网上的服务器进行通信，通过NAT，可以实现将局域网的IP地址，映射为对应的公网IP地址，而NAT设备一端连接外网，另一端连接内网的所有设备，当我们想要与外网进行通信时，就可以将数据包发送给NAT设备，由它来将数据包的源地址映射为它在外网上的地址，这样服务器就能够发现它了，能够直接与它建立通信。当服务器发送数据回来时，也是直接交给NAT设备，然后再根据地址映射，转发给对应的内网设备（当然由于公网IP地址有限，所以一般采用IP+端口结合使用的形式ANPT） 所以你打开百度直接搜IP，会发现这个IP地址并不是你本地的，而是NAT设备的公网地址： 实际上我们家里的路由器一般都带有NAT功能，默认开启NAT模式，包括我们的小区也是有一个NAT设备在进行转换的，这样你的电脑才能在互联网的世界中遨游。当然NAT也可以保护内网的设备不会直接暴露在公网，这样也会更加的安全，只有当我们主动发起连接时，别人才能知道我们。 当然，我们的Docker也是这样的，实际上内网的数据包想要发送到互联网上去，那么就需要经过这样的一套流程： 这样，Docker容器使用的内网就可以和外网进行通信了。 但是这样有一个问题，单纯依靠NAT的话，只有我们主动与外界联系时，外界才能知道我们，但是现在我们的容器中可能会部署一些服务，需要外界来主动连接我们，此时该怎么办呢？ 我们可以直接在容器时配置端口映射，还记得我们在第一节课部署Nginx服务器吗？ docker run -d -p 80:80 nginx 这里的-p参数实际上是进行端口映射配置，端口映射可以将容器需要对外提供服务的端口映射到宿主主机的端口上，这样，当外部访问到宿主主机的对应端口时，就会直接转发给容器内映射的端口了。规则为宿主端口:容器端口，这里配置的是将容器的80端口映射到宿主主机的80端口上。 一旦监听到宿主主机的80端口收到了数据包，那么会直接转发给对应的容器。所以配置了端口映射之后，我们才可以从外部正常访问到容器内的服务： 我们也可以直接输入docker ps查看端口映射情况： 至此，有关容器的网络部分，就到此为止，当然这仅仅是单机下的容器网络操作，在以后的课程中，我们还会进一步学习多主机下的网络配置。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:3:4","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"容器存储管理 前面我们介绍了容器的网络管理，我们现在已经了解了如何配置容器的网络，以及相关的一些原理。还有一个比较重要的部分就是容器的存储，在这一小节我们将深入了解容器的存储管理。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:4:0","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"容器持久化存储 我们知道，容器在创建之后，实际上我们在容器中创建和修改的文件，实际上是被容器的分层机制保存在最顶层的容器层进行操作的，为了保护下面每一层的镜像不被修改，所以才有了这样的CopyOnWrite特性。但是这样也会导致容器在销毁时数据的丢失，当我们销毁容器重新创建一个新的容器时，所有的数据全部丢失，直接回到梦开始的地方。 在某些情况下，我们可能希望对容器内的某些文件进行持久化存储，而不是一次性的，这里就要用到数据卷（Data Volume）了。 在开始之前我们先准备一下实验要用到的镜像： docker run -it ubuntu apt update \u0026\u0026 apt install -y vim 然后打包为我们一会要使用的镜像： docker commit 我们可以让容器将文件保存到宿主主机上，这样就算容器销毁，文件也会在宿主主机上保留，下次创建容器时，依然可以从宿主主机上读取到对应的文件。如何做到呢？只需要在容器启动时指定即可： mkdir test 我们现在用户目录下创建一个新的test目录，然后在里面随便创建一个文件，再写点内容： vim test/hello.txt 接着我们就可以将宿主主机上的目录或文件挂载到容器的某个目录上： docker run -it -v ~/test:/root/test ubuntu-volume 这里用到了一个新的参数-v，用于指定文件挂载，这里是将我们刚刚创建好的test目录挂在到容器的/root/test路径上。 这样我们就可以直接在容器中访问宿主主机上的文件了，当然如果我们对挂载目录中的文件进行编辑，那么相当于编辑的是宿主主机的数据： vim /root/test/test.txt 在宿主主机的对应目录下，可以直接访问到我们刚刚创建好的文件。 接着我们来将容器销毁，看看当容器不复存在时，挂载的数据时候还能保留： 可以看到，即使我们销毁了容器，在宿主主机上的文件依然存在，并不会受到影响，这样的话，当我们下次创建新的镜像时，依然可以使用这些保存在外面的文件。 比如我们现在想要部署一个Nginx服务器来代理我们的前端，就可以直接将前端页面保存到宿主主机上，然后通过挂载的形式让容器中的Nginx访问，这样就算之后Nginx镜像有升级，需要重新创建，也不会影响到我们的前端页面。这里我们来测试一下，我们先将前端模板上传到服务器： scp Downloads/moban5676.zip 192.168.10.10:~/ 然后在服务器上解压一下： unzip moban5676.zip 接着我们就可以启动容器了： docker run -it -v ~/moban5676:/usr/share/nginx/html/ -p 80:80 -d nginx 这里我们将解压出来的目录，挂载到容器中Nginx的默认站点目录/usr/share/nginx/html/（由于挂在后位于顶层，会替代镜像层原有的文件），这样Nginx就直接代理了我们存放在宿主主机上的前端页面，当然别忘了把端口映射到宿主主机上，这里我们使用的镜像是官方的nginx镜像。 现在我们进入容器将Nginx服务启动： systemctl start nginx 然后通过浏览器访问看看是否代理成功： 可以看到我们的前端页面直接被代理了，当然如果我们要编写自定义的配置，也是使用同样的方法操作即可。 注意如果我们在使用-v参数时不指定宿主主机上的目录进行挂载的话，那么就由Docker来自动创建一个目录，并且会将容器中对应路径下的内容拷贝到这个自动创建的目录中，最后挂在到容器中，这种就是由Docker管理的数据卷了（docker managed volume）我们来试试看： docker run -it -v /root/abc ubuntu-volume 注意这里我们仅仅指定了挂载路径，没有指定宿主主机的对应目录，继续创建： 创建后可以看到root目录下有一个新的abc目录，那么它具体是在宿主主机的哪个位置呢？这里我们依然可以使用inspect命令： docker inspect bold_banzai 可以看到Sorce指向的是/var/lib中的某个目录，我们可以进入这个目录来创建一个新的文件，进入之前记得提升一下权限，权限低了还进不去： 我们来创一个新的文本文档： 实际上和我们之前是一样的，也是可以在容器中看到的，当然删除容器之后，数据依然是保留的。当我们不需要使用数据卷时，可以进行删除： 当然有时候为了方便，可能并不需要直接挂载一个目录上去，仅仅是从宿主主机传递一些文件到容器中，这里我们可以使用cp命令来完成： 这个命令支持从宿主主机复制文件到容器，或是从容器复制文件到宿主主机，使用方式类似于Linux自带的cp命令。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:4:1","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"容器数据共享 前面我们通过挂载的形式，将宿主主机上的文件直接挂载到容器中，这样容器就可以直接访问到宿主主机上的文件了，并且在容器删除时也不会清理宿主主机上的文件。 我们接着来看看如何实现容器与容器之间的数据共享，实际上按照我们之前的思路，我们可以在宿主主机创建一个公共的目录，让这些需要实现共享的容器，都挂载这个公共目录： docker run -it -v ~/test:/root/test ubuntu-volume 由于挂载的是宿主主机上的同一块区域，所以内容可以直接在两个容器中都能访问。当然我们也可以将另一个容器挂载的目录，直接在启动容器时指定使用此容器挂载的目录： docker run -it -v ~/test:/root/test --name=data_test ubuntu-volume docker run -it --volumes-from data_test ubuntu-volume 这里使用--volumes-from指定另一个容器（这种用于给其他容器提供数据卷的容器，我们一般称为数据卷容器） 可以看到，数据卷容器中挂载的内容，在当前容器中也是存在的，当然就算此时数据卷容器被删除，那么也不会影响到这边，因为这边相当于是继承了数据卷容器提供的数据卷，所以本质上还是让两个容器挂载了同样的目录实现数据共享。 虽然通过上面的方式，可以在容器之间实现数据传递，但是这样并不方便，可能某些时候我们仅仅是希望容器之间共享，而不希望有宿主主机这个角色直接参与到共享之中，此时我们就需要寻找一种更好的办法了。其实我们可以将数据完全放入到容器中，通过构建一个容器，来直接将容器中打包好的数据分享给其他容器，当然本质上依然是一个Docker管理的数据卷，虽然还是没有完全脱离主机，但是移植性就高得多了。 我们来编写一个Dockerfile： FROM ubuntu ADD moban5676.tar.gz /usr/share/nginx/html/ VOLUME /usr/share/nginx/html/ 这里我们使用了一个新的指令ADD，它跟COPY命令类似，也可以复制文件到容器中，但是它可以自动对压缩文件进行解压，这里只需要将压缩好的文件填入即可，后面的VOLUME指令就像我们使用-v参数一样，会创建一个挂载点在容器中： cd test tar -zcvf moban5676.tar.gz * mv moban5676.tar.gz .. cd .. 接着我们直接构建： docker build -t data . 现在我们运行一个容器看看： 可以看到所有的文件都自动解压出来了（除了中文文件名称乱码了之外，不过无关紧要）我们退出容器，可以看到数据卷列表中新增了我们这个容器需要使用的： 这个位置实际上就是数据存放在当前主机上的位置了，不过是由Docker进行管理而不是我们自定义的。现在我们就可以创建一个新的容器直接继承了： docker run -p 80:80 --volumes-from=data_test -d nginx 访问一下Nginx服务器，可以看到成功代理： 这样我们就实现了将数据放在容器中进行共享，我们不需要刻意去指定宿主主机的挂载点，而是Docker自行管理，这样就算迁移主机依然可以快速部署。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:4:2","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"容器资源管理 前面我们已经完成Docker的几个主要模块的学习，最后我们来看看如何对容器的资源进行管理。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:5:0","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"容器控制操作 在开始之前，我们还是要先补充一些我们前面没有提到的其他容器命令。 首先我们的SpringBoot项目在运行是，怎么查看输出的日志信息呢？ docker logs test 这里使用log命令来打印容器中的日志信息： 当然也可以添加-f参数来持续打印日志信息。 现在我们的容器已经启动了，但是我们想要进入到容器监控容器的情况怎么办呢？我们可以是attach命令来附加到容器启动命令的终端上： docker attach 容器ID/名称 注意现在就切换为了容器内的终端，如果想要退出的话，需要先按Ctrl+P然后再按Ctrl+Q来退出终端，不能直接使用Ctrl+C来终止，这样会直接终止掉Docker中运行的Java程序的。 退出后，容器依然是处于运行状态的。 我们也可以使用exec命令在容器中启动一个新的终端或是在容器中执行命令： docker exec -it test bash -it和run命令的操作是一样的，这里执行后，会创建一个新的终端（当然原本的程序还是在正常运行）我们会在一个新的终端中进行交互： 当然也可以仅仅在容器中执行一条命令： 执行后会在容器中打开一个新的终端执行命令，并输出结果。 前面我们还学习了容器的停止操作，通过输入stop命令来停止容器，但是此操作并不会立即停止，而是会等待容器处理善后，那么怎么样才能强制终止容器呢？我们可以直接使用kill命令，相当于给进程发送SIGKILL信号，强制结束。 docker kill test 相比stop命令，kill就没那么温柔了。 有时候可能只是希望容器暂时停止运行，而不是直接终止运行，我们希望在未来的某个时间点，恢复容器的运行，此时就可以使用pause命令来暂停容器： docker pause test 暂停容器后，程序暂时停止运行，无法响应浏览器发送的请求： 此时处于爱的魔力转圈圈状态，我们可以将其恢复运行，使用unpause命令： docker unpause test 恢复运行后，瞬间就响应成功了。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:5:1","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"物理资源管理 对于一个容器，在某些情况下我们可能并不希望它占据所有的系统资源来运行，我们只希望分配一部分资源给容器，比如只分配给容器2G内存，最大只允许使用2G，不允许再占用更多的内存，此时我们就需要对容器的资源进行限制。 docker run -m 内存限制 --memory-swap=内存和交换分区总共的内存限制 镜像名称 其中-m参数是对容器的物理内存的使用限制，而--memory-swap是对内存和交换分区总和的限制，它们默认都是-1，也就是说没有任何的限制（如果在一开始仅指定-m参数，那么交换内存的限制与其保持一致，内存+交换等于-m的两倍大小）默认情况下跟宿主主机一样，都是2G内存，现在我们可以将容器的内存限制到100M试试看，其中物理内存50M，交换内存50M，尝试启动一下SpringBoot程序： docker run -it -m 50M --memory-swap=100M nagocoler/springboot-test:1.0 可以看到，上来就因为内存不足无法启动了： 当然除了对内存的限制之外，我们也可以对CPU资源进行限额，默认情况下所有的容器都可以平等地使用CPU资源，我们可以调整不同的容器的CPU权重（默认为1024），来按需分配资源，这里需要使用到-c选项，也可以输入全名--cpu-share： docker run -c 1024 ubuntu docker run -c 512 ubuntu 这里容器的CPU权重比例为16比8，也就是2比1（注意多个容器时才会生效），那么当CPU资源紧张时，会按照此权重来分配资源，当然如果CPU资源并不紧张的情况下，依然是有机会使用到全部的CPU资源的。 这里我们使用一个压力测试工具来进行验证： docker run -c 1024 --name=cpu1024 -it ubuntu docker run -c 512 --name=cpu512 -it ubuntu 接着我们分别进入容器安装stress压力测试工具： apt update \u0026\u0026 apt install -y stress 接着我们分别在两个容器中都启动压力测试工具，产生4个进程不断计算随机数的平方根： stress -c 4 接着我们进入top来看看CPU状态（看完之后记得赶紧去kill掉容器，不然CPU拉满很卡的）： 可以看到权重高的容器中，分配到了更多的CPU资源，而权重低的容器中，只分配到一半的CPU资源。 当然我们也可以直接限制容器使用的CPU数量： docker run -it --cpuset-cpus=1 ubuntu --cpuset-cpus选项可以直接限制在指定的CPU上运行，比如现在我们的宿主机是2核的CPU，那么就可以分0和1这两个CPU给Docker使用，限制后，只会使用CPU 1的资源了： 可以看到，4个进程只各自使用了25%的CPU，加在一起就是100%，也就是只能占满一个CPU的使用率。如果要分配多个CPU，则使用逗号隔开： docker run -it --cpuset-cpus=0,1 ubuntu 这样就会使用这两个CPU了： 当然也可以直接使用--cpus来限制使用的CPU资源数： docker run -it --cpus=1 ubuntu 限制为1后，只能使用一个CPU提供的资源，所以这里加载一起只有一个CPU的资源了。当然还有更精细的--cpu-period 和--cpu-quota，这里就不做介绍了。 最后我们来看一下对磁盘IO读写性能的限制，我们首先使用dd命令来测试磁盘读写速度： dd if=/dev/zero of=/tmp/1G bs=4k count=256000 oflag=direct 可以不用等待跑完，中途Ctrl+C结束就行： 可以看到当前的读写速度为86.4 MB/s，我们可以通过--device-read/write-bps和--device-read/write-iops参数对其进行限制。 这里要先说一下区别： bps：每秒读写的数据量。 iops：每秒IO的次数。 为了直观，这里我们直接使用BPS作为限制条件： docker run -it --device-write-bps=/dev/sda:10MB ubuntu 因为容器的文件系统是在/dev/sda上的，所以这我们就/dev/sda:10MB来限制对/dev/sda的写入速度只有10MB/s，我们来测试一下看看： 可以看到现在的速度就只有10MB左右了。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:5:2","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"容器监控 最后我们来看看如何对容器的运行状态进行实时监控，我们现在希望能够对容器的资源占用情况进行监控，该怎么办呢？ 我们可以使用stats命令来进行监控： docker stats 可以实时对容器的各项状态进行监控，包括内存使用、CPU占用、网络I/O、磁盘I/O等信息，当然如果我们限制内存的使用的话： docker run -d -m 200M nagocoler/springboot-test:1.0 可以很清楚地看到限制情况： 除了使用stats命令来实时监控情况之外，还可以使用top命令来查看容器中的进程： docker top 容器ID/名称 当然也可以携带一些参数，具体的参数与Linux中ps命令参数一致，这里就不多做介绍了。 但是这样的监控是不是太原始了一点？有没有那种网页面板可以进行实时监控和管理的呢？有的。 我们需要单独部署一个Docker网页管理面板应用，一般比较常见的有：Portainer，我们这里可以直接通过Docker镜像的方式去部署这个应用程序，搜索一下，发现最新版维护的地址为：https://hub.docker.com/r/portainer/portainer-ce CE为免费的社区版本，当然也有BE商业版本，这里我们就直接安装社区版就行了，官方Linux安装教程：https://docs.portainer.io/start/install/server/docker/linux，包含一些安装前需要的准备。 首先我们需要创建一个数据卷供Portainer使用： docker volume create portainer_data 接着通过官方命令安装启动： docker run -d -p 8000:8000 -p 9443:9443 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:latest 注意这里需要开放两个端口，一个是8000端口，还有一个是9443端口。 OK，开启成功，我们可以直接登录后台面板：https://IP:9443/，这里需要HTTPS访问，浏览器可能会提示不安全，无视就行： 进入后就需要我们进行注册了，这里我们只需输入两次密码即可，默认用户名就是admin，填写完成后，我们就可以开始使用了： 点击Get Started即可进入到管理页面，我们可以看到目前有一个本地的Docker服务器正在运行： 我们可以点击进入，进行详细地管理，不过唯一缺点就是没中文，挺难受的，也可以使用非官方的汉化版本：https://hub.docker.com/r/6053537/portainer-ce。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:5:3","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"单机容器编排 最后我们来讲解一下Docker-Compose，它能够对我们的容器进行编排。比如现在我们要在一台主机上部署很多种类型的服务，包括数据库、消息队列、SpringBoot应用程序若干，或是想要搭建一个MySQL集群，这时我们就需要创建多个容器来完成来，但是我们希望能够实现一键部署，这时该怎么办呢？我们就要用到容器编排了，让多个容器按照我们自己的编排进行部署。 **官方文档：**https://docs.docker.com/get-started/08_using_compose/，视频教程肯定不可能把所有的配置全部介绍完，所以如果各位小伙伴想要了解更多的配置，有更多需求的话，可以直接查阅官方文档。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:6:0","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"快速开始 在Linux环境下我们需要先安装一下插件： sudo apt install docker-compose-plugin 接着输入docker compose version来验证一下是否安装成功。 这里我们就以部署SpringBoot项目为例，我们继续使用之前打包好的SpringBoot项目，现在我们希望部署这个SpringBoot项目的同时，部署一个MySQL服务器，一个Redis服务器，这时我们SpringBoot项目要运行的整个完整环境，先获取到对应的镜像： docker pull mysql/mysql-server docker pull redis 接着，我们需要在自己的本地安装一下DockerCompose，下载地址：https://github.com/docker/compose/releases，下载自己电脑对应的版本，然后在IDEA中配置： 下载完成后，将Docker Compose可执行文件路径修改为你存放刚刚下载的可执行文件的路径，Windows直接设置路径就行，MacOS下载之后需要进行下面的操作： mv 下载的文件名称 docker-compose sudo chmod 777 docker-compose sudo mv docker-compose /usr/local/bin 配置完成后就可以正常使用了，否则会无法运行，接着我们就可以开始在IDEA中编写docker-compose.yml文件了。 这里点击右上角的“与服务工具窗口同步”按钮，这样一会就可以在下面查看情况了。 我们现在就从头开始配置这个文件，现在我们要创建三个服务，一个是MySQL服务器，一个是Redis服务器，还有一个是SpringBoot服务器，需要三个容器来分别运行，首先我们先写上这三个服务： version: \"3.9\" #首先是版本号，别乱写，这个是和Docker版本有对应的 services: #services里面就是我们所有需要进行编排的服务了 spring: #服务名称，随便起 container_name: app_springboot #一会要创建的容器名称 mysql: container_name: app_mysql redis: container_name: app_redis 这样我们就配置好了一会要创建的三个服务和对应的容器名称，接着我们需要指定一下这些容器对应的镜像了，首先是我们的SpringBoot应用程序，可能我们后续还会对应用程序进行更新和修改，所以这里我们部署需要先由Dockerfile构建出镜像后，再进行部署： spring: container_name: app_springboot build: . #build表示使用构建的镜像，.表示使用当前目录下的Dockerfile进行构建 我们这里修改一下Dockerfile，将基础镜像修改为已经打包好JDK环境的镜像： FROM adoptopenjdk/openjdk8 COPY target/DockerTest-0.0.1-SNAPSHOT.jar app.jar CMD java -jar app.jar 接着是另外两个服务，另外两个服务需要使用对应的镜像来启动容器： mysql: container_name: app_mysql image: mysql/mysql-server:latest #image表示使用对应的镜像，这里会自动从仓库下载，然后启动容器 redis: container_name: app_redis image: redis:latest 还没有结束，我们还需要将SpringBoot项目的端口进行映射，最后一个简单的docker-compose配置文件就编写完成了： version: \"3.9\" #首先是版本号，别乱写，这个是和Docker版本有对应的 services: #services里面就是我们所有需要进行编排的服务了 spring: #服务名称，随便起 container_name: app_springboot #一会要创建的容器名称 build: . ports: - \"8080:8080\" mysql: container_name: app_mysql image: mysql/mysql-server:latest redis: container_name: app_redis image: redis:latest 现在我们就可以直接一键部署了，我们点击下方部署按钮： 看到 Running 4/4 就表示已经部署成功了，我们现在到服务器这边来看看情况： 可以看到，这里确实是按照我们的配置，创建了3个容器，并且都是处于运行中，可以正常访问： 如果想要结束的话，我们只需要点击停止就行了： 当然如果我们不再需要这套环境的话，可以直接点击下方的按钮，将整套编排给down掉，这样的话相对应的容器也会被清理的： 注意在使用docker-compose部署时，会自动创建一个新的自定义网络，并且所有的容器都是连接到这个自定义的网络里面： 这个网络默认也是使用bridge作为驱动： 这样，我们就完成了一个简单的配置，去部署我们的整套环境。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:6:1","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"部署完整项目 前面我们学习了使用docker-compose进行简单部署，但是仅仅只是简单启动了服务，我们现在来将这些服务给连起来。首先是SpringBoot项目，我们先引入依赖： \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-jdbc\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003c/dependency\u003e 接着配置一下数据源，等等，我们怎么知道数据库的默认密码是多少呢？所以我们先配置一下MySQL服务： mysql: container_name: app_mysql image: mysql/mysql-server:latest environment: #这里我们通过环境变量配置MySQL的root账号和密码 MYSQL_ROOT_HOST: '%' #登陆的主机，这里直接配置为'%' MYSQL_ROOT_PASSWORD: '123456.root' #MySQL root账号的密码，别设定得太简单了 MYSQL_DATABASE: 'study' #在启动时自动创建的数据库 TZ: 'Asia/Shanghai' #时区 ports: - \"3306:3306\" #把端口暴露出来，当然也可以不暴露，因为默认所有容器使用的是同一个网络 有关MySQL的详细配置请查阅：https://registry.hub.docker.com/_/mysql 接着我们将数据源配置完成： spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://app_mysql:3306/study #地址直接输入容器名称，会自动进行解析，前面已经讲过了 username: root password: 123456.root 然后我们来写点测试的代码吧，这里我们使用JPA进行交互： \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-jpa\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003c/dependency\u003e @Data @AllArgsConstructor @NoArgsConstructor @Entity @Table(name = \"db_account\") public class Account { @Column(name = \"id\") @Id long id; @Column(name = \"name\") String name; @Column(name = \"password\") String password; } @Repository public interface AccountRepository extends JpaRepository\u003cAccount, Long\u003e { } @RestController public class MainController { @Resource AccountRepository repository; @RequestMapping(\"/\") public String hello(){ return \"Hello World!\"; } @GetMapping(\"/get\") public Account get(@RequestParam(\"id\") long id){ return repository.findById(id).orElse(null); } @PostMapping(\"/post\") public Account get(@RequestParam(\"id\") long id, @RequestParam(\"name\") String name, @RequestParam(\"password\") String password){ return repository.save(new Account(id, name, password)); } } 接着我们来修改一下配置文件： spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://app_mysql:3306/study username: root password: 123456.root jpa: database: mysql show-sql: true hibernate: ddl-auto: update #这里自动执行DDL创建表，全程自动化，尽可能做到开箱即用 现在代码编写完成后，我们可以将项目打包了，注意执行我们下面的打包命令，不要进行测试，因为连不上数据库： mvn package -DskipTests 重新生成jar包后，我们修改一下docker-compose配置，因为MySQL的启动速度比较慢，我们要一点时间等待其启动完成，如果连接不上数据库导致SpringBoot项目启动失败，我们就重启： spring: #服务名称，随便起 container_name: app_springboot #一会要创建的容器名称 build: . ports: - \"8080:8080\" depends_on: #这里设置一下依赖，需要等待mysql启动后才运行，但是没啥用，这个并不是等到启动完成后，而是进程建立就停止等待 - mysql restart: always #这里配置容器停止后自动重启 然后我们将之前自动构建的镜像删除，等待重新构建： 现在我们重新部署docker-compos吧： 当三个服务全部为蓝色时，就表示已经正常运行了，现在我们来测试一下吧： 接着我们来试试看向数据库传入数据： 可以看到响应成功，接着我们来请求一下： 这样，我们的项目和MySQL基本就是自动部署了。 接着我们来配置一下Redis： \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-redis\u003c/artifactId\u003e \u003c/dependency\u003e 接着配置连接信息： spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://app_mysql:3306/study username: root password: 123456.root jpa: database: mysql show-sql: true hibernate: ddl-auto: update redis: host: app_redis //再加两个Redis操作进来 @Resource StringRedisTemplate template; @GetMapping(\"/take\") public String take(@RequestParam(\"key\") String key){ return template.opsForValue().get(key); } @PostMapping(\"/put\") public String put(@RequestParam(\"key\") String key, @RequestParam(\"value\") String value){ template.opsForValue().set(key, value); return \"操作成功！\"; } 最后我们来配置一下docker-compose的配置文件： redis: container_name: app_redis image: redis:latest ports: - \"6379:6379\" OK，按照之前的方式，我们重新再部署一下，然后测试： 这样我们就完成整套环境+应用程序的配置了，我们在部署整个项目时，只需要使用docker-compose配置文件进行启动即可，这样就大大方便了我们的操作，实现开箱即用。甚至我们还可以专门使用一个平台来同时对多个主机进行一次性配置，大规模快速部署，而这些就留到以后的课程中再说吧。 ","date":"2024-05-15","objectID":"/posts/7eb358a/:6:2","tags":["Docker"],"title":"Docker容器技术","uri":"/posts/7eb358a/"},{"categories":["Docker"],"content":"配置代理 打开/usr/lib/systemd/system/docker.service，在[Service]域中添加以下参数： Environment=\"HTTP_PROXY=http://proxy-addr:port/\" # 代理服务器地址 Environment=\"HTTPS_PROXY=http://proxy-addr:port/\" # https Environment=\"NO_PROXY=localhost,127.0.0.1\" # 哪些地址不需要走代理 更新配置，启动服务 systemctl daemon-reload systemctl restart docker.service ","date":"2024-05-15","objectID":"/posts/7c3ddcd/:0:0","tags":["Docker"],"title":"Docker用代理拉取镜像","uri":"/posts/7c3ddcd/"},{"categories":["编译原理"],"content":" package main import ( \"bufio\" \"fmt\" \"os\" \"unicode\" ) var keywords = map[string]int{ \"begin\": 1, \"if\": 2, \"then\": 3, \"while\": 4, \"do\": 5, \"end\": 6, } func lexicalAnalysis(input string) { //词法分析程序 var p int = 0 scanner := func() (int, string) { var syn int var token string for p \u003c len(input) \u0026\u0026 input[p] == ' ' { p++ //跳过空格 } if unicode.IsLetter(rune(input[p])) { for p \u003c len(input) \u0026\u0026 (unicode.IsLetter(rune(input[p])) || unicode.IsDigit(rune(input[p]))) { //如果当前是字符，那么把它加入到token中 token += string(input[p]) p++ } _, ok := keywords[token] if ok { syn = keywords[token] } else { syn = 10 } } else { if unicode.IsDigit(rune(input[p])) { syn = 11 token = string(input[p]) p++ } else { switch input[p] { case '+': token = \"+\" syn = 13 p++ case '-': token = \"-\" syn = 14 p++ case '*': token = \"*\" syn = 15 p++ case '/': token = \"/\" syn = 16 p++ case ':': if p+1 \u003c len(input) \u0026\u0026 input[p+1] == '=' { syn = 18 token = \":=\" p += 2 } else { token = \":\" syn = 17 p++ } case '\u003c': if p+1 \u003c len(input) \u0026\u0026 input[p+1] == '\u003e' { syn = 21 token = \"\u003c\u003e\" p += 2 } else if p+1 \u003c len(input) \u0026\u0026 input[p+1] == '=' { syn = 22 token = \"\u003c=\" p += 2 } else { syn = 20 token = \"\u003c\" p++ } case '\u003e': if p+1 \u003c len(input) \u0026\u0026 input[p+1] == '=' { syn = 24 token = \"\u003e=\" p += 2 } else { syn = 23 token = \"\u003e\" p++ } case '=': syn = 25 token = \"=\" p++ case ';': syn = 26 token = \";\" p++ case '(': syn = 27 token = \"(\" p++ case ')': syn = 28 token = \")\" p++ case '#': syn = 0 token = \"#\" p++ default: syn = -1 token = string(input[p]) p++ } } } return syn, token } for p \u003c len(input) { syn, token := scanner() if syn == -1 { fmt.Println(\"错误：非法字符\", token) break } else { res := fmt.Sprintf(\"(%d,%s)\", syn, token) fmt.Print(res + \" \") } } } func main() { fmt.Printf(\"请输入代码段\\n\") reader := bufio.NewReader(os.Stdin) readBytes, _, _ := reader.ReadLine() var codeSegment string = string(readBytes) //input := \"begin x:=9;if x\u003e0 then x:=2*x+1/3;end#\" lexicalAnalysis(codeSegment) } ","date":"2024-05-15","objectID":"/posts/1e5f18a/:0:0","tags":["Go","编译原理"],"title":"Go实现词法分析器","uri":"/posts/1e5f18a/"},{"categories":["编译原理"],"content":" package main import ( \"bufio\" \"fmt\" \"os\" \"strings\" ) var ( str []byte pointer int error_str string = \"Error: 非法的符号串\" withNoSharp string = \"Error: 符号串必须以#结尾\" ) // 打印颜色设置 const Red = \"\\033[31m\" const Green = \"\\033[32m\" const Reset = \"\\033[0m\" const Yellow = \"\\033[33m\" func match(token byte) { if pointer \u003e= len(str) { errors(error_str) return } if str[pointer] == token { pointer++ } else { errors(error_str) } } func errors(info string) { fmt.Println(Red, info, Reset) os.Exit(0) } func E() { fmt.Println(\"E() -\u003e T() -\u003e G()\") T() G() } func T() { fmt.Println(\"T() -\u003e F() -\u003e S()\") F() S() } func G() { if str[pointer] == '+' { match('+') fmt.Println(\"G() -\u003e + -\u003e T() -\u003e G()\") T() G() } else if str[pointer] == '-' { match('-') fmt.Println(\"G() -\u003e - -\u003e T() -\u003e G()\") T() G() } else { fmt.Println(\"G() -\u003e epsilon\") } } func F() { if str[pointer] == 'i' { match('i') fmt.Println(\"F() -\u003e i\") } else if str[pointer] == '(' { match('(') fmt.Println(\"F() -\u003e ( -\u003e E()\") E() if pointer \u003c len(str) \u0026\u0026 str[pointer] == ')' { match(')') fmt.Println(\"F() -\u003e ( -\u003e E() -\u003e )\") } else { errors(\"Error: 缺少右括号\") } } else { errors(\"Error: 与i或者(不匹配\") } } func S() { if str[pointer] == '*' { match('*') fmt.Println(\"S() -\u003e * -\u003e F() -\u003e S()\") F() S() } else if str[pointer] == '/' { match('/') fmt.Println(\"S() -\u003e / -\u003e F() -\u003e S()\") F() S() } else { fmt.Println(\"S() -\u003e epsilon\") } } func checkSuccess() { if pointer == len(str)-1 \u0026\u0026 str[pointer] == '#' { fmt.Println(Green, string(str), \"Success: 符号串匹配成功\", Reset) } else { errors(error_str) } os.Exit(0) } func main() { fmt.Println(Yellow, \"编制人: \", Reset) scanner := bufio.NewScanner(os.Stdin) fmt.Println(Yellow, \"请输入符号串:\", Reset) if scanner.Scan() { input := scanner.Text() if !strings.HasSuffix(input, \"#\") { //判断是否以#结尾 errors(withNoSharp) return } str = []byte(input) fmt.Println(\"读入的字符串为:\", string(str)) E() checkSuccess() } if err := scanner.Err(); err != nil { fmt.Fprintln(os.Stderr, \"读取输入时发生错误:\", err) } } ","date":"2024-05-15","objectID":"/posts/274359a/:0:0","tags":["编译原理","Go"],"title":"Go实现递归向下分析","uri":"/posts/274359a/"},{"categories":["Go"],"content":"Go数组和切片练习 数组 ","date":"2024-05-15","objectID":"/posts/4e31f59/:0:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习1：证明当数组赋值时，发生了数组内存拷贝。 package main import \"fmt\" func main() { arr1 := new([5]int) arr2 := arr1 arr2[1] = 3 fmt.Println(arr1) //\u0026[0 3 0 0 0] fmt.Println(arr2) //\u0026[0 3 0 0 0] arr3 := [5]int{1, 2, 3, 4, 5} arr4 := \u0026arr3 //使用\u0026获取地址，修改arr4也会修改arr3 arr4[2] = 6 fmt.Println(arr3) //[1 2 6 4 5] fmt.Println(arr4) //[1 2 6 4 5] arr5 := [5]int{1, 2, 3, 4, 5} arr6 := arr5 //会进行拷贝 arr6[1] = 9 fmt.Println(arr5) //[1 2 3 4 5] fmt.Println(arr6) //[1 9 3 4 5] } ","date":"2024-05-15","objectID":"/posts/4e31f59/:1:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习2:写一个循环并用下标给数组赋值（从 0 到 15）并且将数组打印在屏幕上。 package main import \"fmt\" func main() { var arr [16]int for i := 0; i \u003c 16; i++ { arr[i] = i } for _, v := range arr { fmt.Print(v, \" \") } /* 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 进程 已完成，退出代码为 0 */ } ","date":"2024-05-15","objectID":"/posts/4e31f59/:2:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习3：通过数组我们可以更快的计算出 Fibonacci 数。完成该方法并打印出前 50 个 Fibonacci 数字。 package main import \"fmt\" func fibonacci(n int) []int { fib := make([]int, n+1) fib[0], fib[1] = 0, 1 for i := 2; i \u003c= n; i++ { fib[i] = fib[i-1] + fib[i-2] } return fib } func main() { n := 50 var fibSeq []int = fibonacci(n) for _, v := range fibSeq { fmt.Print(v, \" \") } } 切片 ","date":"2024-05-15","objectID":"/posts/4e31f59/:3:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习4： 给定切片 sl，将一个 []byte 数组追加到 sl 后面。写一个函数 Append(slice, data []byte) []byte，该函数在 sl 不能存储更多数据的时候自动扩容。 package main import \"fmt\" // 给定切片 sl，将一个 []byte 数组追加到 sl 后面。写一个函数 Append(slice, data []byte) []byte，该函数在 sl 不能存储更多数据的时候自动扩容。 func Append(originByteSlice, data []byte) []byte { originLen := len(originByteSlice) originCap := cap(originByteSlice) appendLen := len(data) var newByteSlice []byte // 判断原切片容量是否足够 if originLen+appendLen \u003e originCap { // 不够时，计算新切片的容量 newCapacity := (originLen + appendLen) * 2 // 创建新切片并复制原切片内容 newByteSlice = make([]byte, originLen+appendLen, newCapacity) copy(newByteSlice, originByteSlice) } else { // 容量足够时，只需引用原切片 newByteSlice = originByteSlice[:originLen+appendLen] } // 将data切片的内容复制到新切片的后面，实现追加 copy(newByteSlice[originLen:], data) return newByteSlice } func Append2(originByteSlice, data []byte) []byte { originLen := len(originByteSlice) originCap := cap(originByteSlice) appendLen := len(data) // 判断原切片容量是否足够 if originLen+appendLen \u003e originCap { // 不够时，计算新切片的容量（这里简单地设置为两倍于原切片长度加上追加长度） newCapacity := (originLen + appendLen) * 2 // 创建新切片并复制原切片内容 newByteSlice := make([]byte, originLen+appendLen, newCapacity) copy(newByteSlice, originByteSlice) originByteSlice = newByteSlice } // 更新切片的长度 originByteSlice = originByteSlice[:originLen+appendLen] // 将data切片的内容复制到原切片的后面，实现追加 copy(originByteSlice[originLen:], data) return originByteSlice } func main() { slice := []byte{'a', 'c', 'e', 'g', 'i'} res := Append2(slice, []byte{'m', 'm'}) res1 := Append2(res, []byte{'f', 'n'}) for _, b := range res1 { fmt.Printf(\"%q \", b) } } ‘a’ ‘c’ ’e’ ‘g’ ‘i’ ’m’ ’m’ ‘f’ ’n’ ","date":"2024-05-15","objectID":"/posts/4e31f59/:4:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习5：把一个缓存 buf 分片成两个切片：第一个是前 n 个 bytes，后一个是剩余的，用一行代码实现。 package main import ( \"bytes\" \"fmt\" ) func main() { var buffer bytes.Buffer var n int = 3 buffer.WriteString(\"helloworld\") bytesBeforeN, bytesAfterN := buffer.Bytes()[:n], buffer.Bytes()[n:] for _, v := range bytesBeforeN { fmt.Printf(\"%c\", v) } fmt.Println() for _, v := range bytesAfterN { fmt.Printf(\"%c\", v) } } hel loworld ","date":"2024-05-15","objectID":"/posts/4e31f59/:5:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习5：遍历多维切片，使用for-range package main import \"fmt\" func main() { slice := make([][]int, 4) slice[0] = []int{1, 2, 3} slice[1] = []int{4, 5, 6} slice[2] = []int{7, 8, 9} slice[3] = []int{10, 11, 12} for row := range slice { for col := range slice[row] { fmt.Print(slice[row][col]) } } } ","date":"2024-05-15","objectID":"/posts/4e31f59/:6:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习6：通过使用省略号操作符 ... 来实现累加方法。 package main import \"fmt\" func add(array ...int) int { var res int = 0 for _, b := range array { res += b } return res } func main() { var res int = add(1, 2, 3, 4, 5, 6) fmt.Println(res) } ","date":"2024-05-15","objectID":"/posts/4e31f59/:7:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习7：给定一个切片 s []int 和一个 int 类型的因子 factor，扩展 s 使其长度为 len(s) * factor。 // 给定一个切片 `s []int` 和一个 `int` 类型的因子 `factor`，扩展 `s` 使其长度为 `len(s) * factor`。 package main import \"fmt\" func enlarge(s *[]int, factor int) { ns := make([]int, len(*s)*factor) copy(ns, *s) *s = ns } func main() { var s []int = []int{1, 2, 3} fmt.Println(\"The length of s before enlarging is:\", len(s)) fmt.Println(s) enlarge(\u0026s, 5) fmt.Println(\"The length of s after enlarging is:\", len(s)) fmt.Println(s) } ","date":"2024-05-15","objectID":"/posts/4e31f59/:8:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习8:用顺序函数过滤容器：s 是前 10 个整型的切片。构造一个函数 Filter，第一个参数是 s，第二个参数是一个 fn func(int) bool，返回满足函数 fn 的元素切片。通过 fn 测试方法测试当整型值是偶数时的情况 package main import \"fmt\" func Filter(s []int, fn func(int) bool) []int { var result []int for _, v := range s { if fn(v) { result = append(result, v) } } return result } func main() { s := []int{1, 2, 3, 4, 5, 6} fn := func(i int) bool { return i%2 == 0 } res := Filter(s, fn) fmt.Println(res) } ","date":"2024-05-15","objectID":"/posts/4e31f59/:9:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习9:写一个函数 InsertStringSlice() 将切片插入到另一个切片的指定位置。 // 写一个函数 InsertStringSlice() 将切片插入到另一个切片的指定位置。 package main import \"fmt\" func InsertIntSlice(src *[]int, dst *[]int, index int) { newSlice := make([]int, len(*src)+len(*dst)) at := copy(newSlice, (*src)[:index]) at += copy(newSlice[at:], (*dst)[:]) copy(newSlice[at:], (*src)[index:]) //for i, v := range *src { // newSlice[i] = v //} //for i := len(*src) + len(*dst) - 1; i \u003e= index+len(*dst); i-- { // newSlice[i] = newSlice[i-len(*dst)] //} //copy(newSlice[index:], *dst) *src = newSlice } func InsertStringSlice(src *[]string, dst *[]string, index int) { newSlice := make([]string, len(*src)+len(*dst)) at := copy(newSlice, (*src)[:index]) at += copy(newSlice[at:], (*dst)[:]) copy(newSlice[at:], (*src)[index:]) *src = newSlice } func main() { src := []int{1, 2, 3, 4, 5, 6, 7, 8, 9} dst := []int{12, 13} InsertIntSlice(\u0026src, \u0026dst, 2) fmt.Println(src) s := []string{\"M\", \"N\", \"O\", \"P\", \"Q\", \"R\"} in := []string{\"A\", \"B\", \"C\"} InsertStringSlice(\u0026s, \u0026in, 3) // at the front fmt.Println(s) } [1 2 12 13 3 4 5 6 7 8 9] ","date":"2024-05-15","objectID":"/posts/4e31f59/:10:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习10:写一个函数 RemoveStringSlice() 将从 start 到 end 索引的元素从切片中移除。 // 写一个函数 RemoveStringSlice() 将从 start 到 end 索引的元素从切片中移除。 package main import \"fmt\" func RemoveStringSlice(source *[]string, start, end int) { tempSlice := make([]string, len(*source)) at := copy(tempSlice, (*source)[0:start]) copy(tempSlice[at:], (*source)[end+1:]) tempSlice = tempSlice[:(len(*source) - end + start - 1)] *source = tempSlice } func main() { src := []string{\"meowrain\", \"hello\", \"world\", \"thanks\", \"meow\", \"miku\", \"aww\"} RemoveStringSlice(\u0026src, 0, 4) fmt.Println(src) } ","date":"2024-05-15","objectID":"/posts/4e31f59/:11:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习11：从字符串生成切片 package main import \"fmt\" func main() { var s string = \"helloworld\" Stringslice := []byte(s) fmt.Println(Stringslice) } ","date":"2024-05-15","objectID":"/posts/4e31f59/:12:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习12：修改字符串中的某个字符 package main import \"fmt\" func main() { var str string = \"helloworld\" slice := []byte(str) slice[2] = 'e' str = string(slice) fmt.Println(str) } 字符串 ","date":"2024-05-15","objectID":"/posts/4e31f59/:13:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习13：编写一个函数，要求其接受两个参数，原始字符串 str 和分割索引 i，然后返回两个分割后的字符串。 package main // 练习13：编写一个函数，要求其接受两个参数，原始字符串 str 和分割索引 i，然后返回两个分割后的字符串。 func splitString(str string, i int) (string, string) { if i \u003c 0 || i \u003e= len(str) { return \"\", \"\" } return str[:i], str[i:] } func main() { str := \"helloworld\" i := 5 s1, s2 := splitString(str, i) println(s1, s2) } ","date":"2024-05-15","objectID":"/posts/4e31f59/:14:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习14：假设有字符串 str，那么 str[len(str)/2:] + str[:len(str)/2] 的结果是什么？ package main func main() { str := \"helloworld\" strslice := str[len(str)/2:] + str[:len(str)/2] println(strslice) //worldhello } ","date":"2024-05-15","objectID":"/posts/4e31f59/:15:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习15:编写一个程序，要求能够反转字符串，即将 “Google” 转换成 “elgooG”（提示：使用 []byte 类型的切片）。 如果您使用两个切片来实现反转，请再尝试使用一个切片（提示：使用交换法）。 如果您想要反转 Unicode 编码的字符串，请使用 []int32 类型的切片。 // 编写一个程序，要求能够反转字符串，即将 \"Google\" 转换成 \"elgooG\"（提示：使用 []byte 类型的切片）。 // // 如果您使用两个切片来实现反转，请再尝试使用一个切片（提示：使用交换法）。 // // 如果您想要反转 Unicode 编码的字符串，请使用 []int32 类型的切片。 package main import ( \"fmt\" \"strings\" ) func reverseString(s string) string { b := []byte(s) for i, j := 0, len(b)-1; i \u003c j; i, j = i+1, j-1 { b[i], b[j] = b[j], b[i] } return string(b) } func reverseStringVersion2(s string) string { str := strings.Builder{} for i := len(s) - 1; i \u003e= 0; i-- { str.WriteByte(s[i]) } return str.String() } func main() { s := \"Google\" //s = reverseString(s) s = reverseStringVersion2(s) fmt.Println(s) } ","date":"2024-05-15","objectID":"/posts/4e31f59/:16:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习16：编写一个程序，要求能够遍历一个字符数组，并将当前字符和前一个字符不相同的字符拷贝至另一个数组。 // Q29_uniq.go package main import \"fmt\" var arr []byte = []byte{'a', 'b', 'a', 'a', 'a', 'c', 'd', 'e', 'f', 'g'} func main() { arru := make([]byte, len(arr)) // this will contain the unique items idx := 0 for i, j := 0, 1; i \u003c len(arr) \u0026\u0026 j \u003c len(arr); i, j = i+1, j+1 { // 在这里执行循环体的操作 if arr[i] != arr[j] { arru[idx] = arr[i] idx++ } } for i := 0; i \u003c idx; i++ { fmt.Printf(\"%c \", arru[i]) //a b a c d e f } } ","date":"2024-05-15","objectID":"/posts/4e31f59/:17:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"练习17:写一个程序，使用冒泡排序的方法排序一个包含整数的切片（算法的定义可参考 维基百科）。 package main import \"fmt\" func bubbleSort(arr []int) []int { for i := 0; i \u003c len(arr)-1; i++ { for j := 0; j \u003c len(arr)-i-1; j++ { if arr[j] \u003e arr[j+1] { arr[j], arr[j+1] = arr[j+1], arr[j] } } } return arr } func bubbleSortPointerVersion(arr *[]int) { for i := 0; i \u003c len(*arr)-1; i++ { for j := 0; j \u003c len(*arr)-i-1; j++ { if (*arr)[j] \u003e (*arr)[j+1] { (*arr)[j], (*arr)[j+1] = (*arr)[j+1], (*arr)[j] } } } } func main() { arr := []int{5, 2, 8, 3, 9, 1} // 2 5 8 3 9 1 // 2 5 3 8 9 1 // 2 5 3 8 1 9 // ----- // 2 3 5 8 1 9 // 2 3 5 1 8 9 // ---- // 2 3 1 5 8 9 //--- // 2 1 3 5 8 9 //---- // 1 2 3 5 8 9 sortedArr := bubbleSort(arr) fmt.Println(sortedArr) bubbleSortPointerVersion(\u0026arr) fmt.Println(arr) } ","date":"2024-05-15","objectID":"/posts/4e31f59/:18:0","tags":["Go"],"title":"Go数组和切片联系","uri":"/posts/4e31f59/"},{"categories":["Go"],"content":"Go 接口 ","date":"2024-05-15","objectID":"/posts/b3efa23/:0:0","tags":["Go","Go接口"],"title":"Go接口","uri":"/posts/b3efa23/"},{"categories":["Go"],"content":"接口定义 Go语言提倡面向接口编程。 ","date":"2024-05-15","objectID":"/posts/b3efa23/:1:0","tags":["Go","Go接口"],"title":"Go接口","uri":"/posts/b3efa23/"},{"categories":["Go"],"content":"指针接收者实现接口 package main import \"fmt\" // 接口定义 type USB interface { Connect() Disconnect() } type Laptop struct { name string version string } type Desktop struct { name string version string } // 实现USB接口 func (laptop *Laptop) Connect() { fmt.Println(\"USB Connecting to\", laptop.name) } func (laptop *Laptop) Disconnect() { fmt.Println(\"USB Disconnecting from\", laptop.name) } func (desktop *Desktop) Connect() { fmt.Println(\"USB Connecting to\", desktop.name) } func (desktop *Desktop) Disconnect() { fmt.Println(\"USB Disconnecting from\", desktop.name) } func main() { var legion_laptop Laptop = Laptop{ name: \"Legion Y7000P\", version: \"2022\", } var legion_desktop2 *Desktop = \u0026Desktop{ name: \"Legion Y9000P\", version: \"2023\", } var legion_desktop Desktop = Desktop{ name: \"Legion Desktop Computer\", version: \"2023\", } var x USB = legion_laptop x.Disconnect() x.Connect() x = legion_desktop2 x.Connect() x.Disconnect() x = legion_desktop x.Connect() x.Disconnect() } 当我们写成这样的时候，可以看到 也就是说，当我们使用指针接收者的时候，是不能传递结构体变量给接口变量的 ","date":"2024-05-15","objectID":"/posts/b3efa23/:2:0","tags":["Go","Go接口"],"title":"Go接口","uri":"/posts/b3efa23/"},{"categories":["Go"],"content":"值接收者实现接口 package main import \"fmt\" // 接口定义 type USB interface { Connect() Disconnect() } type Laptop struct { name string version string } type Desktop struct { name string version string } // 实现USB接口 func (laptop Laptop) Connect() { fmt.Println(\"USB Connecting to\", laptop.name) } func (laptop Laptop) Disconnect() { fmt.Println(\"USB Disconnecting from\", laptop.name) } func (desktop Desktop) Connect() { fmt.Println(\"USB Connecting to\", desktop.name) } func (desktop Desktop) Disconnect() { fmt.Println(\"USB Disconnecting from\", desktop.name) } func main() { var legion_laptop Laptop = Laptop{ name: \"Legion Y7000P\", version: \"2022\", } var legion_desktop2 *Desktop = \u0026Desktop{ name: \"Legion Y9000P\", version: \"2023\", } var legion_desktop Desktop = Desktop{ name: \"Legion Desktop Computer\", version: \"2023\", } var x USB = legion_laptop x.Disconnect() x.Connect() x = legion_desktop2 x.Connect() x.Disconnect() x = legion_desktop x.Connect() x.Disconnect() } 我们可以发现，使用值接收者实现接口之后，不管是Laptop的结构体还是其结构体指针，都可以赋值给接口变量 ","date":"2024-05-15","objectID":"/posts/b3efa23/:3:0","tags":["Go","Go接口"],"title":"Go接口","uri":"/posts/b3efa23/"},{"categories":["Go"],"content":"一个类型实现多个接口 一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现 package main import \"fmt\" type Payer interface { Pay() } type Talker interface { Talk() } type AliPay struct { } type Wechat struct { } func (w Wechat) Pay() { fmt.Println(\"Wechat Pay\") } func (w Wechat) Talk() { fmt.Println(\"Wechat Talk\") } func (a AliPay) Pay() { fmt.Println(\"AliPay Pay\") } func (a AliPay) Talk() { fmt.Println(\"AliPay Talk\") } func main() { var payer Payer = AliPay{} payer.Pay() payer = Wechat{} payer.Pay() var talker Talker = Wechat{} talker.Talk() talker = AliPay{} talker.Talk() } ","date":"2024-05-15","objectID":"/posts/b3efa23/:4:0","tags":["Go","Go接口"],"title":"Go接口","uri":"/posts/b3efa23/"},{"categories":["Go"],"content":"接口嵌套 接口与接口间可以通过嵌套创造出新的接口。 package main import \"fmt\" type Payer interface { Pay() } type Talker interface { Talk() } type AliPay struct { } type Wechat struct { } type Tooler interface { Payer Talker } func (w Wechat) Pay() { fmt.Println(\"Wechat Pay\") } func (w Wechat) Talk() { fmt.Println(\"Wechat Talk\") } func (a AliPay) Pay() { fmt.Println(\"AliPay Pay\") } func (a AliPay) Talk() { fmt.Println(\"AliPay Talk\") } func main() { var tool Tooler = AliPay{} tool.Talk() tool.Pay() tool = Wechat{} tool.Talk() tool.Pay() } ","date":"2024-05-15","objectID":"/posts/b3efa23/:5:0","tags":["Go","Go接口"],"title":"Go接口","uri":"/posts/b3efa23/"},{"categories":["Go"],"content":"空接口 空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。 空接口类型的变量可以存储任意类型的变量。 package main import \"fmt\" func show(anything interface{}) { fmt.Println(anything) } type Animal struct { name string age int } func main() { show(\"fdsafdasf\") show(123) show(Animal{ \"neko\", 12, }) } 可以用any来替代 空接口还可以作为map的value值 package main import \"fmt\" func main() { var studentInfo = make(map[string]interface{}) //var studentInfo = make(map[string]any) studentInfo[\"name\"] = \"meowrain\" studentInfo[\"age\"] = 12 studentInfo[\"hobby\"] = \"play computer\" fmt.Println(studentInfo) } ","date":"2024-05-15","objectID":"/posts/b3efa23/:6:0","tags":["Go","Go接口"],"title":"Go接口","uri":"/posts/b3efa23/"},{"categories":["Go"],"content":"类型断言 ","date":"2024-05-15","objectID":"/posts/b3efa23/:7:0","tags":["Go","Go接口"],"title":"Go接口","uri":"/posts/b3efa23/"},{"categories":["Go"],"content":"接口值 一个接口的值（简称接口值）是由一个具体类型和具体类型的值两部分组成的。这两部分分别称为接口的动态类型和动态值。 判断空接口中的这个值可以用类型断言 x.(T) package main import \"fmt\" func show(anything interface{}) { v, ok := anything.(string) if ok { fmt.Println(v) } else { fmt.Println(\"not string\") } } func main() { show(\"fdsfdsafa\") show(23) } ","date":"2024-05-15","objectID":"/posts/b3efa23/:7:1","tags":["Go","Go接口"],"title":"Go接口","uri":"/posts/b3efa23/"},{"categories":["Go"],"content":" 参考文档：https://www.liwenzhou.com/posts/Go/file/ ","date":"2024-05-15","objectID":"/posts/17ec745/:0:0","tags":["Go","Go文件读写"],"title":"Go文件读写","uri":"/posts/17ec745/"},{"categories":["Go"],"content":"读取文件 package main import ( \"fmt\" \"io\" \"os\") func main() { file, err := os.Open(\"./data.txt\") if err != nil { fmt.Println(\"open file err:\", err) return } defer file.Close() var tmp = make([]byte, 1024) n, err := file.Read(tmp) if err == io.EOF { fmt.Println(\"文件读取完毕\") return } fmt.Printf(\"读取了%d字节数据\\n\", n) fmt.Println(string(tmp)) } 上面这个代码只是读取了文件中的1024个字节，并没有读取完文件内的所有内容，下面我们使用循环读取将文件全部读取 package main import ( \"fmt\" \"io\" \"os\") func main() { file, err := os.Open(\"./data.txt\") if err != nil { fmt.Println(\"open file err:\", err) return } defer file.Close() var content []byte var tmp = make([]byte, 10) var sumByte int for { n, err := file.Read(tmp) if err == io.EOF { fmt.Println(\"文件读取完毕\") break } if err != nil { fmt.Println(\"read file failed\", err) return } sumByte += n content = append(content, tmp[:n]...) } fmt.Println(string(content)) fmt.Println(\"读取了\", sumByte, \"字节\") } ","date":"2024-05-15","objectID":"/posts/17ec745/:1:0","tags":["Go","Go文件读写"],"title":"Go文件读写","uri":"/posts/17ec745/"},{"categories":["Go"],"content":"bufio读取文件 bufio是在file的基础上封装了一层API，支持更多的功能。 package main import ( \"bufio\" \"fmt\" \"io\" \"os\") func main() { file, err := os.Open(\"data.txt\") if err != nil { fmt.Println(\"file open failed\", err) return } defer file.Close() reader := bufio.NewReader(file) for { line, err := reader.ReadString('\\n') if err == io.EOF { if len(line) != 0 { fmt.Println(line) } fmt.Println(\"文件读完了\") break } if err != nil { fmt.Println(\"read file err:\", err) return } fmt.Println(line) } } ","date":"2024-05-15","objectID":"/posts/17ec745/:1:1","tags":["Go","Go文件读写"],"title":"Go文件读写","uri":"/posts/17ec745/"},{"categories":["Go"],"content":"os.ReadFIle读取整个文件 package main import ( \"fmt\" \"os\") func main() { content, err := os.ReadFile(\"./data.txt\") if err != nil { fmt.Println(\"read file failed:\", err) return } fmt.Println(string(content)) } ","date":"2024-05-15","objectID":"/posts/17ec745/:1:2","tags":["Go","Go文件读写"],"title":"Go文件读写","uri":"/posts/17ec745/"},{"categories":["Go"],"content":"文件写入 ","date":"2024-05-15","objectID":"/posts/17ec745/:2:0","tags":["Go","Go文件读写"],"title":"Go文件读写","uri":"/posts/17ec745/"},{"categories":["Go"],"content":"Write和WriteString package main import ( \"fmt\" \"os\") func main() { file, err := os.OpenFile(\"./data.txt\", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666) if err != nil { fmt.Println(\"file open failed err:\", err) return } defer file.Close() str := \"good\" file.Write([]byte(str)) //file.WriteString(str) } ","date":"2024-05-15","objectID":"/posts/17ec745/:2:1","tags":["Go","Go文件读写"],"title":"Go文件读写","uri":"/posts/17ec745/"},{"categories":["Go"],"content":"使用os.WriteFile函数 package main import ( \"fmt\" \"os\") func main() { str := \"helloworld\" err := os.WriteFile(\"./data.txt\", []byte(str), 0666) if err != nil { fmt.Println(\"write file failed, err : \", err) return } } Practice 复制一个文件中的内容到另一个文件 package main import ( \"fmt\" \"io\" \"os\") func main() { src, err := os.OpenFile(\"data.txt\", os.O_RDONLY, 0666) if err != nil { fmt.Println(\"open file failed,err\", err) return } defer src.Close() var content []byte buf := make([]byte, 1024) for { n, err := src.Read(buf) if err == io.EOF { break } content = append(content, buf[:n]...) } dst, err := os.OpenFile(\"copy.txt\", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666) if err != nil { fmt.Println(\"open file failed,err\", err) return } dst.Write(content) defer dst.Close() } 其实可以用系统的io.Copy函数 package main import ( \"fmt\" \"io\" \"os\") func CopyFile(source, destination string) { src, err := os.OpenFile(source, os.O_RDONLY, 0666) if err != nil { fmt.Println(\"open file failed,err\", err) return } defer src.Close() dst, err := os.OpenFile(destination, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666) if err != nil { fmt.Println(\"open file failed,err\", err) return } defer dst.Close() _, err = io.Copy(dst, src) if err != nil { fmt.Println(\"copy file failed,err: \", err) return } } func main() { var source string = \"data.txt\" var destination string = \"copy.txt\" CopyFile(source, destination) } ","date":"2024-05-15","objectID":"/posts/17ec745/:2:2","tags":["Go","Go文件读写"],"title":"Go文件读写","uri":"/posts/17ec745/"},{"categories":["Go"],"content":"用go实现cat基本功能 package main import ( \"fmt\" \"os\") func main() { if len(os.Args) \u003c 2 { fmt.Println(\"Usage: cat \u003cfilename\u003e\") return } filename := os.Args[1] content, err := os.ReadFile(filename) if err != nil { fmt.Println(\"open file failed,err: \", err) return } fmt.Printf(\"%v\", string(content)) } ","date":"2024-05-15","objectID":"/posts/17ec745/:3:0","tags":["Go","Go文件读写"],"title":"Go文件读写","uri":"/posts/17ec745/"},{"categories":["Go"],"content":"用go实现拷贝文件到另一个文件 package main import ( \"io\" \"os\" ) func CopyFile(dstName, srcName string) error { src, err := os.Open(srcName) if err != nil { return err } defer src.Close() dst, err := os.Create(dstName) if err != nil { return err } defer dst.Close() _, err = io.Copy(dst, src) if err != nil { return err } return nil } func main() { CopyFile(\"./test.txt\", \"./go.mod\") } ","date":"2024-05-15","objectID":"/posts/17ec745/:4:0","tags":["Go","Go文件读写"],"title":"Go文件读写","uri":"/posts/17ec745/"},{"categories":null,"content":" Hi there 👋,I’m MeowRain.From SXAU. ","date":"2024-05-15","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"About 大家好，我是MeowRain ❤️(●’◡’●)今年20岁了，读大二。 热爱开源！ 梦想着成为一个和棒的程序猿(๑•̀ㅂ•́)و✧，在为自己的目标努力着！！ ","date":"2024-05-15","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Learning 目前正在学习Android应用开发，短期目标为做两个App ","date":"2024-05-15","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"IDE\u0026Editor ","date":"2024-05-15","objectID":"/about/:3:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"💻System-using 现在主要使用Fedora ","date":"2024-05-15","objectID":"/about/:4:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Links 欢迎访问我的博客！ Meowrain’s Blog ","date":"2024-05-15","objectID":"/about/:5:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Stats ","date":"2024-05-15","objectID":"/about/:6:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Languages ","date":"2024-05-15","objectID":"/about/:7:0","tags":null,"title":"About","uri":"/about/"},{"categories":["Go"],"content":"Go语言Web框架Gin","date":"2024-05-15","objectID":"/posts/31a491d/","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"Go 语言 Web 框架 Gin 参考 https://docs.fengfengzhidao.com https://www.liwenzhou.com/posts/Go/gin/#c-0-7-2 返回各种值 ","date":"2024-05-15","objectID":"/posts/31a491d/:0:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"返回字符串 package main import ( \"net/http\" \"github.com/gin-gonic/gin\" ) func main() { router := gin.Default() router.GET(\"/\", func(c *gin.Context) { c.String(http.StatusOK, \"helloworld\") }) router.Run(\":8080\") } ","date":"2024-05-15","objectID":"/posts/31a491d/:1:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"返回 json package main import ( \"net/http\" \"github.com/gin-gonic/gin\" ) type Student struct { Name string `json:\"name\"` Age int `json:\"age\"` Number string `json: \"number\"` } func main() { router := gin.Default() router.GET(\"/\", func(c *gin.Context) { var student Student = Student{ Name: \"meowrain\", Age: 20, Number: \"10086\", } c.JSON(http.StatusOK, student) }) router.Run(\":8080\") } ","date":"2024-05-15","objectID":"/posts/31a491d/:2:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"返回 map package main import ( \"net/http\" \"github.com/gin-gonic/gin\" ) func main() { router := gin.Default() router.GET(\"/\", func(c *gin.Context) { userMap := map[string]any{ \"username\": \"meowrain\", \"age\": 20, \"number\": 10086, } c.JSON(http.StatusOK, userMap) }) router.Run(\":8080\") } ","date":"2024-05-15","objectID":"/posts/31a491d/:3:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"返回原始 json package main import ( \"net/http\" \"github.com/gin-gonic/gin\" ) func main() { router := gin.Default() router.GET(\"/\", func(c *gin.Context) { c.JSON(http.StatusOK, gin.H{ \"username\": \"meowrain\", \"age\": 20, \"number\": 10086, }) }) router.Run(\":8080\") } ","date":"2024-05-15","objectID":"/posts/31a491d/:4:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"返回 html 并传递参数 package main import ( \"net/http\" \"github.com/gin-gonic/gin\" ) func _html(c *gin.Context) { type UserInfo struct { Username string `json:\"username\"` Age int `json:\"age\"` Password string `json:\"-\"` } user := UserInfo{ Username: \"meowrain\", Age: 20, Password: \"12345678\", } c.HTML(http.StatusOK, \"index.html\", gin.H{\"obj\": user}) } func main() { router := gin.Default() router.LoadHTMLGlob(\"template/*\") router.GET(\"/\", _html) router.Run(\":8080\") } \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eUser Information\u003c/h1\u003e \u003cp\u003eUsername: {{.obj.Username}}\u003c/p\u003e \u003cp\u003eAge: {{.obj.Age}}\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2024-05-15","objectID":"/posts/31a491d/:5:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"静态文件配置 router.Static和router.StaticFS都是用于处理静态文件的 Gin 框架路由处理方法，但它们有一些区别。 router.Static: 使用 router.Static 时，Gin 会简单地将请求的 URL 路径与提供的本地文件系统路径进行映射。通常，这适用于将 URL 路径直接映射到一个静态文件或目录。 示例：router.Static(\"/static\", \"./static\") 将 /static 映射到当前工作目录下的 ./static 文件夹。 router.StaticFS: router.StaticFS 则允许你使用 http.FileSystem 对象，这可以提供更多的灵活性。你可以使用 http.Dir 创建 http.FileSystem，并将其传递给 router.StaticFS。 这允许你更灵活地处理静态文件，例如从不同的源（内存、数据库等）加载静态文件，而不仅限于本地文件系统。 示例：router.StaticFS(\"/static\", http.Dir(\"/path/to/static/files\")) 使用本地文件系统路径创建一个 http.FileSystem 对象，然后将 /static 映射到这个文件系统。 总体而言，router.Static更简单，适用于基本的静态文件服务，而router.StaticFS提供了更多的灵活性，允许你自定义静态文件的加载方式。选择使用哪一个取决于你的具体需求。 package main import ( \"net/http\" \"github.com/gin-gonic/gin\" ) func _html(c *gin.Context) { type UserInfo struct { Username string `json:\"username\"` Age int `json:\"age\"` Password string `json:\"-\"` } user := UserInfo{ Username: \"meowrain\", Age: 20, Password: \"12345678\", } c.HTML(http.StatusOK, \"index.html\", gin.H{\"obj\": user}) } func main() { router := gin.Default() router.LoadHTMLGlob(\"template/*\") router.Static(\"/static/\", \"./static\") router.GET(\"/\", _html) router.Run(\":8080\") } \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eUser Information\u003c/h1\u003e \u003cp\u003eUsername: {{.obj.Username}}\u003c/p\u003e \u003cp\u003eAge: {{.obj.Age}}\u003c/p\u003e \u003cimg src=\"/static/c68a16221f5bdf5486749d0993052981178827471.jpg\" /\u003e \u003c/body\u003e \u003c/html\u003e 重定向 package main import ( \"net/http\" \"github.com/gin-gonic/gin\" ) func _html(c *gin.Context) { type UserInfo struct { Username string `json:\"username\"` Age int `json:\"age\"` Password string `json:\"-\"` } user := UserInfo{ Username: \"meowrain\", Age: 20, Password: \"12345678\", } c.HTML(http.StatusOK, \"index.html\", gin.H{\"obj\": user}) } func _redirect(c *gin.Context) { c.Redirect(301, \"https://www.baidu.com\") } func main() { router := gin.Default() router.LoadHTMLGlob(\"template/*\") router.Static(\"/static/\", \"./static\") router.GET(\"/\", _html) router.GET(\"/baidu\", _redirect) router.Run(\":8080\") } ","date":"2024-05-15","objectID":"/posts/31a491d/:5:1","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"301 和 302 的区别 HTTP 状态码中的 301 和 302 分别表示重定向（Redirect）。它们之间的主要区别在于重定向的性质和原因： 301 Moved Permanently（永久重定向）: 当服务器返回状态码 301 时，它告诉客户端请求的资源已经被永久移动到新的位置。 客户端收到 301 响应后，应该更新书签、链接等，将这个新的位置作为将来所有对该资源的请求的目标。 搜索引擎在遇到 301 时，通常会更新索引，将原始 URL 替换为新的 URL。 302 Found（临时重定向）: 当服务器返回状态码 302 时，它表示请求的资源暂时被移动到了另一个位置。 客户端收到 302 响应后，可以在不更新书签和链接的情况下继续使用原始 URL。 搜索引擎在遇到 302 时，通常会保留原始 URL 在索引中，并不会立即更新为新的 URL。 总体来说，使用 301 通常是在确定资源永久移动的情况下，而 302 通常用于暂时性的重定向，即资源可能在将来回到原始位置。选择使用哪种状态码取决于你希望客户端和搜索引擎如何处理被重定向的资源。 路由 ","date":"2024-05-15","objectID":"/posts/31a491d/:5:2","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"默认路由 当访问路径不被匹配的时候返回默认路由内容 目录结构 //main.go package main import ( \"awesomeProject/pkg/controller\" \"github.com/gin-gonic/gin\" ) func main() { router := gin.Default() router.LoadHTMLGlob(\"templates/*\") router.GET(\"/\", func(c *gin.Context) { c.String(200, \"helloworld\") }) router.NoRoute(controller.Default_route) router.Run(\":80\") } //server.go package controller import ( \"github.com/gin-gonic/gin\" \"net/http\" ) func Default_route(c *gin.Context) { c.HTML(http.StatusNotFound, \"404.html\", nil) } \u003c!--404.html--\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003ctitle\u003e404 NOT FOUND\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003e404 Not Found\u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e 效果 ","date":"2024-05-15","objectID":"/posts/31a491d/:6:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"路由组 参考：https://www.liwenzhou.com/posts/Go/gin/#c-0-7-2 我们可以将拥有共同 URL 前缀的路由划分为一个路由组。习惯性一对{}包裹同组的路由，这只是为了看着清晰，你用不用{}包裹功能上没什么区别。 //main.go package main import ( \"awesomeProject/pkg/controller\" \"github.com/gin-gonic/gin\" ) func main() { router := gin.Default() userGroup := router.Group(\"/user\") { userGroup.GET(\"/all\", controller.GetUserList) userGroup.GET(\"/detail\", controller.GetUserDetail) } router.LoadHTMLGlob(\"templates/*\") router.NoRoute(controller.Default_route) router.Run(\":80\") } //controller/userController.go package controller import ( . \"awesomeProject/pkg/entity\" \"github.com/gin-gonic/gin\" \"net/http\" \"strconv\" ) func GetUserList(c *gin.Context) { c.JSON(http.StatusOK, Response{ Code: http.StatusOK, Data: UserList, Msg: \"返回成功\", }) } func GetUserDetail(c *gin.Context) { id := c.Query(\"id\") for _, res := range UserList { if strconv.Itoa(res.ID) == id { c.JSON(http.StatusOK, Response{ Code: http.StatusOK, Data: res, Msg: \"get successfully\", }) } } } //user.go package entity type User struct { ID int `json:\"id\"` Name string `json:\"name\"` Age int `json:\"age\"` } type Response struct { Code int `json:\"code\"` Data any `json:\"data\"` Msg string `json:\"msg\"` } var UserList []User = []User{ { ID: 1, Name: \"meowrian\", Age: 20, }, { ID: 2, Name: \"Mike\", Age: 30, }, { ID: 3, Name: \"Amy\", Age: 23, }, { ID: 4, Name: \"John\", Age: 24, }, } //server.go package controller import ( \"github.com/gin-gonic/gin\" \"net/http\" ) func Default_route(c *gin.Context) { c.HTML(http.StatusNotFound, \"404.html\", nil) } 路由组也是支持嵌套的 参数 ","date":"2024-05-15","objectID":"/posts/31a491d/:7:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"查询参数 package main import ( \"net/http\" \"github.com/gin-gonic/gin\" ) func _query(c *gin.Context) { user := c.Query(\"user\") c.HTML(http.StatusOK, \"index.html\", gin.H{ \"user\": user, }) } func main() { router := gin.Default() router.LoadHTMLGlob(\"template/*\") router.Static(\"/static\", \"./static\") router.GET(\"/\", _query) router.Run(\":8080\") } package main import ( \"fmt\" \"net/http\" \"github.com/gin-gonic/gin\") func _query(c *gin.Context) { user, ok := c.GetQuery(\"user\") ids := c.QueryArray(\"id\") //拿到多个相同的查询参数 maps := c.QueryMap(\"id\") fmt.Println(maps) if ok { c.HTML(http.StatusOK, \"index.html\", gin.H{ \"user\": user, \"id\": ids, }) } else { c.String(http.StatusOK, \"No query!\") } } func main() { router := gin.Default() router.LoadHTMLGlob(\"template/*\") router.Static(\"static\", \"./static\") router.GET(\"/\", _query) router.Run(\":8080\") } 请求为： http://127.0.0.1:8080/?user=good\u0026id=1\u0026id=2\u0026id=3\u0026id[good]=meowrain \u003e \u003e ","date":"2024-05-15","objectID":"/posts/31a491d/:8:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"动态参数 package main import ( \"fmt\" \"github.com/gin-gonic/gin\" \"net/http\") func _param(c *gin.Context) { param := c.Param(\"user_id\") fmt.Println(param) c.HTML(http.StatusOK, \"index.html\", gin.H{ \"param\": param, }) } func main() { router := gin.Default() router.LoadHTMLGlob(\"template/*\") router.Static(\"static\", \"./static\") router.GET(\"/param/:user_id\", _param) router.Run(\":8080\") } ","date":"2024-05-15","objectID":"/posts/31a491d/:9:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"表单参数 PostForm package main import ( \"github.com/gin-gonic/gin\" \"net/http\") func postForm(c *gin.Context) { name := c.PostForm(\"name\") password := c.PostForm(\"password\") c.JSON(http.StatusOK, gin.H{ \"name\": name, \"password\": password, }) } func index(c *gin.Context) { c.HTML(http.StatusOK, \"index.html\", gin.H{}) } func main() { router := gin.Default() router.LoadHTMLGlob(\"template/*\") router.Static(\"static\", \"./static\") router.GET(\"/\", index) router.POST(\"/post\", postForm) router.Run(\":8080\") } \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e \u003ctitle\u003ePost Form Test\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003ePost Form Test\u003c/h1\u003e \u003cform id=\"myForm\" action=\"/post\" method=\"post\"\u003e \u003clabel for=\"name\"\u003eName:\u003c/label\u003e \u003cinput type=\"text\" id=\"name\" name=\"name\" required /\u003e \u003cbr /\u003e \u003clabel for=\"password\"\u003ePassword: \u003c/label\u003e \u003cinput type=\"password\" id=\"password\" name=\"password\" required /\u003e \u003cbr /\u003e \u003cbutton type=\"button\" onclick=\"postData()\"\u003eSubmit\u003c/button\u003e \u003c/form\u003e \u003ch3 id=\"response\"\u003eResponse:\u003c/h3\u003e \u003cscript\u003e function postData() { var form = document.getElementById(\"myForm\"); var formData = new FormData(form); var resp = document.getElementById(\"response\"); fetch(\"http://127.0.0.1:8080/post\", { method: \"POST\", body: formData, }) .then((response) =\u003e response.json()) .then((data) =\u003e { console.log(\"Success:\", data); resp.innerText = \"Response: \" + JSON.stringify(data); }) .catch((error) =\u003e { console.error(\"Error:\", error); resp.innerText = \"Response Error: \" + JSON.stringify(error); }); } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e postFormArray 函数 package main import ( \"github.com/gin-gonic/gin\" \"net/http\") func postForm(c *gin.Context) { name := c.PostForm(\"name\") password := c.PostForm(\"password\") respArr := c.PostFormArray(\"name\") c.JSON(http.StatusOK, gin.H{ \"name\": name, \"password\": password, \"respArray\": respArr, }) } func index(c *gin.Context) { c.HTML(http.StatusOK, \"index.html\", gin.H{}) } func main() { router := gin.Default() router.LoadHTMLGlob(\"template/*\") router.Static(\"static\", \"./static\") router.GET(\"/\", index) router.POST(\"/post\", postForm) router.Run(\":8080\") } ","date":"2024-05-15","objectID":"/posts/31a491d/:10:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"原始参数 /* 原始参数 */ package main import ( \"fmt\" \"github.com/gin-gonic/gin\") func _raw(c *gin.Context) { buf, err := c.GetRawData() if err != nil { fmt.Println(\"error:\", err) return } fmt.Println(string(buf)) } func main() { router := gin.Default() router.POST(\"/\", _raw) router.Run(\":8080\") } ","date":"2024-05-15","objectID":"/posts/31a491d/:11:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"解析 json 数据 /* 原始参数 */ package main import ( \"encoding/json\" \"fmt\" \"github.com/gin-gonic/gin\") func bindJSON(c *gin.Context, obj any) error { body, err := c.GetRawData() contentType := c.GetHeader(\"Content-Type\") fmt.Println(\"ContentType:\", contentType) if err != nil { fmt.Println(\"error:\", err) return err } switch contentType { case \"application/json\": err := json.Unmarshal(body, obj) if err != nil { fmt.Println(err.Error()) return err } } return nil } func raw(c *gin.Context) { type User struct { Name string `json:\"name\"` Age int `json:\"age\"` Password string `json:\"-\"` } var user User err := bindJSON(c, \u0026user) if err != nil { fmt.Println(\"Error binding JSON:\", err) return } fmt.Println(user) } func main() { router := gin.Default() router.POST(\"/\", raw) router.Run(\":8080\") } 四大请求方式 ","date":"2024-05-15","objectID":"/posts/31a491d/:11:1","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"简单实现以下 CRUD package main import ( \"github.com/gin-gonic/gin\" \"net/http\" \"strconv\") type Article struct { Id int `json:\"id\"` Title string `json:\"title\"` Content string `json:\"content\"` Author string `json:\"author\"` } type Response struct { Code int `json:\"code\"` Data any `json:\"data\"` Msg string `json:\"msg\"` } var articleList []Article = []Article{ { 1, \"Go语言从入门到精通\", \"Learn better\", \"Mike Jason\", }, { 2, \"Java从入门到精通\", \"Java is good\", \"Jack Smith\", }, { 3, \"Javascript从入门到精通\", \"Javascript is a nice programming language!\", \"Amy Gorden\", }, { 4, \"Python从入门到精通\", \"Python is a simple language!\", \"Jack Buffer\", }, } /*简单增删改查*/ func _getList(c *gin.Context) { c.JSON(http.StatusOK, Response{Code: 200, Data: articleList, Msg: \"获取成功\"}) } func _getDetail(c *gin.Context) { id := c.Param(\"id\") flag := false for _, res := range articleList { if strconv.Itoa(res.Id) == id { flag = true c.JSON(http.StatusOK, Response{ Code: 200, Data: res, Msg: \"获取成功！\", }) } } if flag == false { c.JSON(404, Response{ Code: 404, Data: \"Not Found the data\", Msg: \"获取失败，因为数据不存在\", }) } } func _create(c *gin.Context) { id, _ := strconv.ParseInt(c.PostForm(\"id\"), 10, 0) title := c.PostForm(\"title\") content := c.PostForm(\"content\") author := c.PostForm(\"author\") var article Article = Article{ Id: int(id), Title: title, Content: content, Author: author, } articleList = append(articleList, article) c.JSON(200, Response{Code: 200, Data: article, Msg: \"添加成功！\"}) } func _delete(c *gin.Context) { id := c.Param(\"id\") index := -1 for i, res := range articleList { if strconv.Itoa(res.Id) == id { index = i break } } if index != -1 { articleList = append(articleList[:index], articleList[index+1:]...) c.JSON(http.StatusOK, Response{Code: 200, Data: nil, Msg: \"删除成功\"}) } else { c.JSON(http.StatusNotFound, Response{Code: 404, Data: \"Not Found the data\", Msg: \"删除失败，数据不存在\"}) } } func _update(c *gin.Context) { id, _ := strconv.Atoi(c.Param(\"id\")) title := c.PostForm(\"title\") content := c.PostForm(\"content\") author := c.PostForm(\"author\") found := false for i, res := range articleList { if res.Id == id { found = true articleList[i] = Article{ id, title, content, author, } break } } if found { c.JSON(http.StatusOK, Response{ Code: 200, Data: nil, Msg: \"更新成功\", }) return } else { c.JSON(http.StatusNotFound, Response{ Code: 404, Data: \"Not found the data\", Msg: \"更新失败，因为数据不存在\", }) } } func main() { router := gin.Default() router.GET(\"/articles\", _getList) router.GET(\"/articles/:id\", _getDetail) router.POST(\"/articles\", _create) router.PUT(\"/articles/:id\", _update) router.DELETE(\"/articles/:id\", _delete) router.Run(\":8080\") } ","date":"2024-05-15","objectID":"/posts/31a491d/:12:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"文件上传 ","date":"2024-05-15","objectID":"/posts/31a491d/:13:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"上传单个文件 package main import ( \"awesomeProject/pkg/controller\" \"github.com/gin-gonic/gin\" ) func main() { router := gin.Default() router.LoadHTMLGlob(\"templates/*\") router.GET(\"/\", func(c *gin.Context) { c.HTML(200, \"upload.html\", nil) }) router.POST(\"/upload\",controller.Upload_file) router.NoRoute(controller.Default_route) router.Run(\":80\") } package controller import ( \"fmt\" \"github.com/gin-gonic/gin\" \"log\" \"net/http\" ) func Default_route(c *gin.Context) { c.HTML(http.StatusNotFound, \"404.html\", nil) } //文件上传 func Upload_file(c *gin.Context) { file, err := c.FormFile(\"f1\") if err != nil { c.JSON(http.StatusInternalServerError, gin.H{ \"message\": err.Error(), }) return } log.Println(file.Filename) dst := fmt.Sprintf(\"./tmp/%s\", file.Filename) c.SaveUploadedFile(file, dst) c.JSON(http.StatusOK, gin.H{ \"message\": fmt.Sprintf(\"'%s' uploaded\", file.Filename), }) } \u003c!DOCTYPE html\u003e \u003chtml lang=\"zh-CN\"\u003e \u003chead\u003e \u003ctitle\u003e上传文件示例\u003c/title\u003e \u003cstyle\u003e body { font-family: Arial, sans-serif; background-color: #f2f2f2; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; } form { background-color: #fff; padding: 30px; border-radius: 5px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); text-align: center; } input[type=\"file\"] { margin-bottom: 20px; } input[type=\"submit\"] { background-color: #4caf50; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; } input[type=\"submit\"]:hover { background-color: #45a049; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cform id=\"uploadForm\"\u003e \u003cinput type=\"file\" id=\"fileInput\" name=\"f1\" /\u003e \u003cinput type=\"button\" value=\"上传\" onclick=\"uploadFile()\" /\u003e \u003c/form\u003e \u003cscript\u003e function uploadFile() { let fileInput = document.getElementById(\"fileInput\"); let file = fileInput.files[0]; if (file) { let formData = new FormData(); formData.append(\"f1\", file); fetch(\"/upload\", { method: \"POST\", body: formData, }) .then((response) =\u003e response.json()) .then((result) =\u003e { console.log(result); }) .catch((error) =\u003e { console.error(\"Error:\", error); }); } else { console.error(\"No file selected.\"); } } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2024-05-15","objectID":"/posts/31a491d/:13:1","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"上传多个文件 package main import ( \"awesomeProject/pkg/controller\" \"github.com/gin-gonic/gin\" ) func main() { router := gin.Default() router.LoadHTMLGlob(\"templates/*\") router.GET(\"/\", func(c *gin.Context) { c.HTML(200, \"upload.html\", nil) }) router.POST(\"/upload\", controller.UploadFiles) router.NoRoute(controller.Default_route) router.Run(\":80\") } package controller import ( \"fmt\" \"github.com/gin-gonic/gin\" \"log\" \"net/http\" ) func Default_route(c *gin.Context) { c.HTML(http.StatusNotFound, \"404.html\", nil) } func UploadFiles(c *gin.Context) { err := c.Request.ParseMultipartForm(100 \u003c\u003c 20) // 100 MB limit if err != nil { c.JSON(http.StatusInternalServerError, gin.H{ \"message\": err.Error(), }) return } form := c.Request.MultipartForm if form == nil || form.File == nil { c.JSON(http.StatusBadRequest, gin.H{ \"message\": \"No files provided in the request\", }) return } files := form.File[\"f1\"] for _, file := range files { dst := fmt.Sprintf(\"./tmp/%s\", file.Filename) if err := c.SaveUploadedFile(file, dst); err != nil { c.JSON(http.StatusInternalServerError, gin.H{ \"message\": fmt.Sprintf(\"Failed to save file %s: %s\", file.Filename, err.Error()), }) return } log.Println(file.Filename) } c.JSON(http.StatusOK, gin.H{ \"message\": \"Files uploaded successfully\", }) } \u003c!DOCTYPE html\u003e \u003chtml lang=\"zh-CN\"\u003e \u003chead\u003e \u003ctitle\u003e上传文件示例\u003c/title\u003e \u003cstyle\u003e body { font-family: Arial, sans-serif; background-color: #f2f2f2; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; } form { background-color: #fff; padding: 30px; border-radius: 5px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); text-align: center; } input[type=\"file\"] { margin-bottom: 20px; } input[type=\"submit\"] { background-color: #4caf50; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; } input[type=\"submit\"]:hover { background-color: #45a049; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cform id=\"uploadForm\"\u003e \u003cinput type=\"file\" id=\"fileInput\" name=\"f1\" multiple /\u003e \u003cinput type=\"button\" value=\"上传\" onclick=\"uploadFile()\" /\u003e \u003c/form\u003e \u003cscript\u003e function uploadFile() { let fileInput = document.getElementById(\"fileInput\"); let formData = new FormData(); for (const file of fileInput.files) { formData.append(\"f1\", file); } fetch(\"/upload\", { method: \"POST\", body: formData, }) .then((response) =\u003e response.json()) .then((result) =\u003e { console.log(result); }) .catch((error) =\u003e { console.error(\"Error:\", error); }); } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2024-05-15","objectID":"/posts/31a491d/:13:2","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"判断上传文件的类型 在 Gin 框架中,可以使用binding模块提供的FormFile函数来获取上传的文件,然后检查文件的 MIME 类型。具体步骤如下: 在处理函数中使用c.FormFile获取上传的文件: file, err := c.FormFile(\"file\") if err != nil { c.String(http.StatusBadRequest, \"获取文件失败\") return } 打开文件并读取文件头部的几个字节,以识别文件的 MIME 类型: f, err := file.Open() if err != nil { c.String(http.StatusInternalServerError, \"打开文件失败\") return } defer f.Close() buffer := make([]byte, 512) _, err = f.Read(buffer) if err != nil { c.String(http.StatusInternalServerError, \"读取文件失败\") return } 使用http.DetectContentType函数检测文件的 MIME 类型: contentType := http.DetectContentType(buffer) 判断文件类型是否允许: allowedTypes := []string{\"image/jpeg\", \"image/png\", \"application/pdf\"} allowed := false for _, t := range allowedTypes { if t == contentType { allowed = true break } } if !allowed { c.String(http.StatusBadRequest, \"不支持的文件类型\") return } 完整的示例代码如下: func uploadFile(c *gin.Context) { file, err := c.FormFile(\"file\") if err != nil { c.String(http.StatusBadRequest, \"获取文件失败\") return } f, err := file.Open() if err != nil { c.String(http.StatusInternalServerError, \"打开文件失败\") return } defer f.Close() buffer := make([]byte, 512) _, err = f.Read(buffer) if err != nil { c.String(http.StatusInternalServerError, \"读取文件失败\") return } contentType := http.DetectContentType(buffer) allowedTypes := []string{\"image/jpeg\", \"image/png\", \"application/pdf\"} allowed := false for _, t := range allowedTypes { if t == contentType { allowed = true break } } if !allowed { c.String(http.StatusBadRequest, \"不支持的文件类型\") return } // 处理文件... } 在上面的示例中，我们定义了一个允许的 MIME 类型列表allowedTypes，包括image/jpeg、image/png和application/pdf。如果上传的文件类型不在允许列表中，就会返回错误响应。你可以根据需求修改允许的文件类型列表。 ","date":"2024-05-15","objectID":"/posts/31a491d/:13:3","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"使用 gin 编写文件服务器 package controller import ( \"fmt\" \"github.com/gin-gonic/gin\" \"log\" \"net/http\" \"os\" ) func Default_route(c *gin.Context) { c.HTML(http.StatusNotFound, \"404.html\", nil) } func UploadFiles(c *gin.Context) { err := c.Request.ParseMultipartForm(100 \u003c\u003c 20) // 100 MB limit if err != nil { c.JSON(http.StatusInternalServerError, gin.H{ \"message\": err.Error(), }) return } form := c.Request.MultipartForm if form == nil || form.File == nil { c.JSON(http.StatusBadRequest, gin.H{ \"message\": \"No files provided in the request\", }) return } files := form.File[\"f1\"] for _, file := range files { dst := fmt.Sprintf(\"./tmp/%s\", file.Filename) if err := c.SaveUploadedFile(file, dst); err != nil { c.JSON(http.StatusInternalServerError, gin.H{ \"message\": fmt.Sprintf(\"Failed to save file %s: %s\", file.Filename, err.Error()), }) return } log.Println(file.Filename) } c.JSON(http.StatusOK, gin.H{ \"message\": \"Files uploaded successfully\", }) } func ListFiles(c *gin.Context) { // 读取 ./tmp 目录下的所有文件 files, err := os.ReadDir(\"./tmp\") if err != nil { c.String(http.StatusInternalServerError, err.Error()) return } // 渲染模板 c.HTML(http.StatusOK, \"download.html\", gin.H{ \"Files\": files, }) } package main import ( \"awesomeProject/pkg/controller\" \"github.com/gin-gonic/gin\" ) func main() { r := gin.Default() // 设置静态文件路径为 ./tmp r.Static(\"/tmp\", \"./tmp\") // 设置模板目录 r.LoadHTMLGlob(\"templates/*\") // 定义路由 r.GET(\"/\", func(c *gin.Context) { c.HTML(200, \"upload.html\", nil) }) r.POST(\"/upload\", controller.UploadFiles) //文件列表服务器 r.GET(\"/files\", controller.ListFiles) // 启动HTTP服务器 r.Run(\":8080\") } \u003c!--download.html --\u003e \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eFile List\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eFile List\u003c/h1\u003e \u003cul\u003e {{ range .Files }} \u003cli\u003e\u003ca href=\"/tmp/{{ .Name }}\"\u003e{{ .Name }}\u003c/a\u003e\u003c/li\u003e {{ end }} \u003c/ul\u003e \u003c/body\u003e \u003c/html\u003e \u003c!--美化版--\u003e \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eFile List\u003c/title\u003e \u003cstyle\u003e body { font-family: Arial, sans-serif; background-color: #f5f5f5; padding: 20px; } h1 { color: #333; text-align: center; } ul { list-style-type: none; margin: 0; padding: 0; display: flex; flex-wrap: wrap; justify-content: center; } li { background-color: #fff; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); margin: 10px; padding: 10px; border-radius: 5px; text-align: center; } a { text-decoration: none; color: #333; } a:hover { color: #666; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eFile List\u003c/h1\u003e \u003cul\u003e {{ range .Files }} \u003cli\u003e\u003ca href=\"/tmp/{{ .Name }}\"\u003e{{ .Name }}\u003c/a\u003e\u003c/li\u003e {{ end }} \u003c/ul\u003e \u003c/body\u003e \u003c/html\u003e 请求头相关 ","date":"2024-05-15","objectID":"/posts/31a491d/:13:4","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"获取所有请求头 package main import ( \"fmt\" \"github.com/gin-gonic/gin\" \"net/http\") func main() { router := gin.Default() router.LoadHTMLGlob(\"template/*\") router.Static(\"static\", \"./static\") router.GET(\"/\", func(c *gin.Context) { c.HTML(http.StatusOK, \"index.html\", gin.H{ \"header\": c.Request.Header, }) fmt.Println(c.Request.Header) }) router.Run(\":8080\") } \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e \u003ctitle\u003ePost Form Test\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eHeader Test\u003c/h1\u003e \u003ch3\u003eHeader: {{.header}}\u003c/h3\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2024-05-15","objectID":"/posts/31a491d/:14:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"绑定参数 bind 绑定 post 发送的 json 数据转换为 Student 结构体的成员变量值，然后再把这个结构体转换为 json 对象 package main import ( \"fmt\" \"github.com/gin-gonic/gin\" \"net/http\") type Student struct { Name string `json:\"name\"` Age int `json:\"age\"` } func main() { router := gin.Default() router.POST(\"/\", func(c *gin.Context) { var stu Student err := c.BindJSON(\u0026stu) if err != nil { fmt.Println(\"error: \", err) c.JSON(http.StatusBadGateway, err) return } c.JSON(http.StatusOK, stu) }) router.Run(\":8080\") } 绑定查询参数 package main import ( \"fmt\" \"github.com/gin-gonic/gin\" \"net/http\") type Student struct { Name string `json:\"name\" form:\"name\"` Age int `json:\"age\" form:\"age\"` } func main() { router := gin.Default() router.GET(\"/\", func(c *gin.Context) { var stu Student err := c.BindQuery(\u0026stu) if err != nil { fmt.Println(\"error: \", err) c.JSON(http.StatusBadGateway, err) return } c.JSON(http.StatusOK, stu) }) router.Run(\":8080\") } bind URI package main import ( \"fmt\" \"github.com/gin-gonic/gin\" \"net/http\") type Student struct { Name string `json:\"name\" form:\"name\" uri:\"name\"` Age int `json:\"age\" form:\"age\" uri:\"age\"` } func main() { router := gin.Default() router.GET(\"/uri/:name/:age\", func(c *gin.Context) { var stu Student err := c.ShouldBindUri(\u0026stu) if err != nil { fmt.Println(\"error: \", err) c.JSON(http.StatusBadGateway, err) return } c.JSON(http.StatusOK, stu) }) router.Run(\":8080\") } ","date":"2024-05-15","objectID":"/posts/31a491d/:15:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"常用验证器 // 不能为空，并且不能没有这个字段 required： 必填字段，如：binding:\"required\" // 针对字符串的长度 min 最小长度，如：binding:\"min=5\" max 最大长度，如：binding:\"max=10\" len 长度，如：binding:\"len=6\" // 针对数字的大小 eq 等于，如：binding:\"eq=3\" ne 不等于，如：binding:\"ne=12\" gt 大于，如：binding:\"gt=10\" gte 大于等于，如：binding:\"gte=10\" lt 小于，如：binding:\"lt=10\" lte 小于等于，如：binding:\"lte=10\" // 针对同级字段的 eqfield 等于其他字段的值，如：PassWord string `binding:\"eqfield=Password\"` nefield 不等于其他字段的值 - 忽略字段，如：binding:\"-\" package main import ( \"github.com/gin-gonic/gin\" \"net/http\") type User struct { Name string `json:\"name\" binding:\"required\"` Password string `json:\"password\" binding:\"eqfield=Re_Password\"` Re_Password string `json:\"re_password\"` } type Response struct { Code int `json:\"code\"` Data any `json:\"data\"` Msg string `json:\"msg\"` } func main() { router := gin.Default() router.POST(\"/login\", func(c *gin.Context) { var user User err := c.ShouldBindJSON(\u0026user) if err != nil { c.JSON(http.StatusBadGateway, Response{ Code: http.StatusBadGateway, Data: err.Error(), Msg: \"bad response\", }) return } c.JSON(http.StatusOK, Response{ Code: http.StatusOK, Data: user, Msg: \"post successfully\", }) }) router.Run(\":8080\") } 密码相同 密码不同 我们看到报错对用户不是很友好，我们可以自定义验证的错误信息 TODO ","date":"2024-05-15","objectID":"/posts/31a491d/:16:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"},{"categories":["Go"],"content":"gin 内置验证器 // 枚举 只能是red 或green oneof=red green // 字符串 contains=fengfeng // 包含fengfeng的字符串 excludes // 不包含 startswith // 字符串前缀 endswith // 字符串后缀 // 数组 dive // dive后面的验证就是针对数组中的每一个元素 // 网络验证 ip ipv4 ipv6 uri url // uri 在于I(Identifier)是统一资源标示符，可以唯一标识一个资源。 // url 在于Locater，是统一资源定位符，提供找到该资源的确切路径 // 日期验证 1月2号下午3点4分5秒在2006年 datetime=2006-01-02 Gin 中间件 https://www.liwenzhou.com/posts/Go/gin/#c-0-8-3 Gin 中的中间件必须是一个gin.HandlerFunc类型。 Gin 框架允许开发者在处理请求的过程中，加入用户自己的钩子（Hook）函数。这个钩子函数就叫中间件，中间件适合处理一些公共的业务逻辑，比如登录认证、权限校验、数据分页、记录日志、耗时统计等。 记录接口耗时的中间件 ","date":"2024-05-15","objectID":"/posts/31a491d/:17:0","tags":["Go","Gin"],"title":"Go语言 Web框架Gin","uri":"/posts/31a491d/"}]