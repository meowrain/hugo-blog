---
title: 软考-笔记
subtitle:
date: 2024-05-19T17:00:05+08:00
slug: 831975a
draft: false
description:
keywords:
license: CC
comment: true
weight: 0
tags:
  - 软考
categories:
  - 面向对象
hiddenFromHomePage: false
hiddenFromSearch: false
hiddenFromRss: false
hiddenFromRelated: false
summary:
resources:
  - name: featured-image
    src: featured-image.jpg
  - name: featured-image-preview
    src: featured-image-preview.jpg
toc: true
math: true
lightgallery: true
password:
message:
repost:
  enable: false
  url:

# See details front matter: https://fixit.lruihao.cn/documentation/content-management/introduction/#front-matter
---

# 面向对象设计原则(部分)
>
> https://zhuanlan.zhihu.com/p/60791596


1. 共同重用原则：一个包中里的所有类应该是共同重用的，如果重用了包里的一个类，那么就要重用包中的所有类。
2. 共同封闭原则： 如果一个变化对一个包产生影响，则将对该包里的所有类产生影响，而对其它包不产生任何影响。
3. 开放-封闭原则：对扩展开放，对修改关闭。
4. 接口分离原则： 接口的功能尽可能单一，降低模块的耦合性。

# 面向对象测试的四个层次

1. 算法层 --> 单元测试
2. 类层 --> 模块测试
3. 模板层 --> 主题层
4. 系统层 --> 把各个子系统组装成完整的面向对象软件系统，在组装过程进行测试


# 设计模式

面向对象类关系(继承、实现、依赖、关联、聚合、组合)：https://www.cnblogs.com/zhongj/p/11169780.html

UML: https://blog.csdn.net/quyingzhe0217/article/details/133683814

## 创建型模式

创建型设计模式包括以下几种常见的模式：

[工厂模式（Factory Pattern）](#工厂方法模式-factory_method)：通过工厂方法或抽象工厂来创建对象，将对象的创建过程封装起来，使得客户端代码与具体类解耦。

[抽象工厂模式（Abstract Factory Pattern）](#抽象工厂模式)：提供一个接口，用于创建相关或依赖对象的家族，而不需要指定具体类。

[单例模式（Singleton Pattern）](#单例模式)：确保一个类只有一个实例，并提供一个全局访问点来访问该实例。

[建造者模式（Builder Pattern）](#生成器模式)：将一个复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。

[原型模式（Prototype Pattern）](#原型模式)：通过复制现有对象来创建新对象，而不是通过实例化来创建。

## 结构型模式

结构型设计模式主要包括以下几种常见的模式：
适配器模式（Adapter Pattern）：将一个类的接口转换成客户端所期望的另一个接口，使得原本不兼容的类可以一起工作。

桥接模式（Bridge Pattern）：将抽象部分与实现部分分离，使它们可以独立地变化，从而提高系统的灵活性。

组合模式（Composite Pattern）：将对象组合成树形结构，以表示“部分-整体”的层次结构，使得客户端可以统一地处理单个对象和组合对象。

装饰器模式（Decorator Pattern）：动态地给对象添加额外的职责，同时又不改变其接口。

外观模式（Facade Pattern）：提供一个统一的接口，用于访问子系统中的一组接口，从而简化客户端与子系统之间的交互。

享元模式（Flyweight Pattern）：通过共享细粒度的对象，以减少内存使用和提高性能。

代理模式（Proxy Pattern）：为其他对象提供一个代理，以控制对这个对象的访问。

## 行为模式

行为型设计模式主要包括以下几种常见的模式：

观察者模式（Observer Pattern）：定义了一种一对多的依赖关系，使得多个观察者对象可以同时监听并收到被观察者对象的通知。

策略模式（Strategy Pattern）：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，从而使算法的变化独立于使用算法的客户端。

命令模式（Command Pattern）：将请求封装成对象，以使得可以用不同的请求对客户端进行参数化，同时支持请求的排队、记录和撤销。

迭代器模式（Iterator Pattern）：提供一种顺序访问聚合对象中各个元素的方法，而又不暴露该对象的内部表示。

状态模式（State Pattern）：允许对象在内部状态发生改变时改变其行为，使对象看起来像是修改了其类。

责任链模式（Chain of Responsibility Pattern）：将请求的发送者和接收者解耦，使多个对象都有机会处理请求，从而避免请求的发送者与接收者之间的耦合关系。

访问者模式（Visitor Pattern）：在不改变被访问类的前提下，定义了一种新的访问操作，使得可以在不修改被访问类的情况下对其进行操作。

中介者模式（Mediator Pattern）：定义了一个中介对象，封装了一组对象之间的交互方式，使其能够独立地改变交互方式。

备忘录模式（Memento Pattern）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可以在以后恢复到这个状态。

解释器模式（Interpreter Pattern）：给定一个语言，定义它的文法的一种表示，并定义一个解释器，用于解释语言中的句子。



## 二分查找关键字序列判断
1. 第一个关键字一定是序列的中间元素
2. 第一个关键字以后的数字要么都大于第一个关键字，要么都小于第一个关键字
3. 第二个关键字以后的关键字，要么都位于第一个关键字和第二个关键字之间，要么都在第二个关键字之外
4. 第三个关键字以后的关键字，要么都位于第二个关键字和第三个关键字之间，要么都在第三个关键字之外
